<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heejinlee07.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Today I Learned">
<meta property="og:type" content="website">
<meta property="og:title" content="Heejin">
<meta property="og:url" content="https://heejinlee07.github.io/index.html">
<meta property="og:site_name" content="Heejin">
<meta property="og:description" content="Today I Learned">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Heejin Lee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://heejinlee07.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Heejin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heejin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Front-end Developer</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/07/220307_blockchain04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/220307_blockchain04/" class="post-title-link" itemprop="url">220307_blockchain04</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-07 16:44:50" itemprop="dateCreated datePublished" datetime="2022-03-07T16:44:50+09:00">2022-03-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/06/220307_blockchain03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/06/220307_blockchain03/" class="post-title-link" itemprop="url">블록체인 무엇인가? 3장</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-07 00:00:00 / Modified: 16:44:50" itemprop="dateCreated datePublished" datetime="2022-03-07T00:00:00+09:00">2022-03-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="3-블록체인은-어떻게-작동하는가"><a href="#3-블록체인은-어떻게-작동하는가" class="headerlink" title="3. 블록체인은 어떻게 작동하는가?"></a>3. 블록체인은 어떻게 작동하는가?</h1><h2 id="8-블록체인의-청사진-그리기"><a href="#8-블록체인의-청사진-그리기" class="headerlink" title="8. 블록체인의 청사진 그리기"></a>8. 블록체인의 청사진 그리기</h2><blockquote>
<p>목표: 소유권을 관리하는 블록체인의 개발. <code>완전히 개방된 환경에서 작동하는 원장의 순수 분산 P2P 시스템에서 소유권을 관리하는 소프트웨어 디자인.</code></p>
</blockquote>
<h3 id="출발점-개발-환경-공유하기"><a href="#출발점-개발-환경-공유하기" class="headerlink" title="출발점: 개발 환경 공유하기"></a>출발점: 개발 환경 공유하기</h3><ul>
<li>시스템은 순수 분산 P2P 시스템이고, 각 사용자가 기여한 계산 자원으로 이루어진다.</li>
<li>인터넷을 사용해 개별 노드의 네트워크를 연결한다.</li>
<li>노드의 개수는 물론 노드의 안정성과 신뢰성도 전혀 알 수 없다.</li>
<li>목표는 <code>디지털 재화의 소유권을 관리하는 것.</code></li>
</ul>
<h3 id="진행경로-7가지-과제-해결하기"><a href="#진행경로-7가지-과제-해결하기" class="headerlink" title="진행경로: 7가지 과제 해결하기"></a>진행경로: 7가지 과제 해결하기</h3><ol>
<li>소유권 기술<ol>
<li>블록체인으로 <code>무엇</code>을 하고 싶은지, <code>소유권을 어떻게 기술할 것인지</code>를 결정한다.</li>
<li>트랜잭션은 소유권의 이전을 설명하는 좋은 방법이며, 트랜잭션 전체 이력은 현 소유자를 확인할 수 있는 핵심이 된다.</li>
</ol>
</li>
<li>소유권 보호<ol>
<li>타인이 다른 사람의 자산에 함부로 접근하지 못하도록 보호해줄 장치</li>
<li><code>암호화 기술</code>을 통해 개별적 트랜잭션을 보호한다.</li>
<li>소유권을 보호하는 과정: 소유주 <code>식별</code> -&gt; 소유주 <code>인증</code> -&gt; 소유주 본인에게만 자산 <code>접근 허가</code></li>
</ol>
</li>
<li>트랜잭션 데이터 저장<ol>
<li>트랜잭션 데이터는 소유권을 명확히 하는 핵심 요소이므로 안전한 방법으로 저장</li>
</ol>
</li>
<li>신뢰할 수 없는 환경에 배분할 원장 준비<ol>
<li>신뢰할 수 없는 환경에서 작동하는 원장의 분산 P2P 시스템을 디자인한다.</li>
<li>이 말은 신뢰를 알 수 없는 환경에 있는 각 노드가 신뢰할 수 있는 행동을 할 때 인센티브가 더 돌아가도록 설계해서 전체 환경을 확률적으로 신뢰할 수 있도록 만든다는 것.</li>
<li>신뢰할 수 없는 환경에서 원장의 복사본들이 신뢰할 수 없는 노드들 사이에 흩어져 있고, 원장을 통제하거나 조정하는 중앙 통제 노드가 존재하지 않아서 각 노드에게 원장의 제어를 맡긴다.</li>
<li>이 상황에서 <code>트랜잭션을 바꾸지 못하도록 막아두는 것</code>으로 원장의 위조나 조작을 막을 수 있다.</li>
<li><strong>원장과 트랜잭션 이력은 한번 기록되면 바꿀 수 없게 하는 것이다.</strong></li>
<li>단 블록체인-데이터-구조에서 변경을 못하게 하면서 새로운 트랜잭션을 추가할 수 없으니 <code>추가 전용 블록체인-데이터-구조</code>로 만들어서 새 트랜잭션을 추가할 수 있도록 승인해야 한다.</li>
</ol>
</li>
<li>원장 배분<ol>
<li>원장을 추가 전용으로 만들고 요청하는 <code>누구에게나 복사본을</code> 만들어주면 원장의 분산 P2P 시스템을 구성할 수 있다.</li>
</ol>
</li>
<li>원장에 새 트랜잭션 추가<ol>
<li>분산 P2P 시스템은 개별적으로 추가 전용 블록체인-데이터-구조를 유지하는 구성원들로 구성된다.</li>
<li><em>오직 유효하고 승인된 트랜잭션만 추가될 수 있도록 보장해야 한다.</em> 이를 위해 P2P 시스템의 구성원 모두에게 새로운 데이터를 추가할 수 있도록 허용하고, 각 구성원이 P2P 시스템의 각 피어를 감독하게 한다.</li>
</ol>
</li>
<li>어느 원장이 진실인지 판단<ol>
<li>P2P 시스템에서 개별 원장에 새로운 트랜잭션을 추가할 수 있도록 허용하면 모든 분산 P2P 시스템에서 발생하는 <code>각 피어들이 서로 다른 트랜잭션 데이터를 받을 가능성</code>이 생긴다.</li>
<li>트랜잭션 이력은 합법적 소유자를 찾기 위한 기초가 되므로 시스템 내 서로 다른 이력이 충돌해서는 안되고, <strong>따라서 진실을 담고 있는 트랜잭션을 가려낼 기준이 필요하다.</strong></li>
<li>순수 분산 P2P 시스템에는 어떤 트랜잭션 이력을 선택해야 할지 결정해 줄 중앙 통제 장치가 없기 때문에 <strong>모든 노드가 독립적인 다수 의견을 따라 진실된 트랜잭션 이력을 개별적으로 결정</strong>해서 문제를 해결하도록 한다.</li>
<li>블록체인이 새 트랜잭션을 추가 전용 블록체인-데이터-구조에 추가하도록 허용하여 문제를 해결할 수 있다.</li>
</ol>
</li>
</ol>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/02/220303_blockchain02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/02/220303_blockchain02/" class="post-title-link" itemprop="url">블록체인 무엇인가? 2장</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-03 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-03T00:00:00+09:00">2022-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-07 16:44:50" itemprop="dateModified" datetime="2022-03-07T16:44:50+09:00">2022-03-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2-왜-우리에게-블록체인이-필요한가"><a href="#2-왜-우리에게-블록체인이-필요한가" class="headerlink" title="2. 왜 우리에게 블록체인이 필요한가?"></a>2. 왜 우리에게 블록체인이 필요한가?</h1><h2 id="4-블록체인에게-떨어진-미션"><a href="#4-블록체인에게-떨어진-미션" class="headerlink" title="4. 블록체인에게 떨어진 미션"></a>4. 블록체인에게 떨어진 미션</h2><blockquote>
<p>P2P 시스템의 지속가능성은 신뢰와 무결성에 달려 있다</p>
</blockquote>
<p>신뢰와 무결성은 동전의 양면과 같다. 신뢰가 사전에 형성되고 지속적인 상호작용의 결과에 따라 더욱 굳어지거나 약해진다. P2P 시스템은 시스템을 믿는 사람들이 일단 합류하여 시스템에 기여한다. 이후 상호작용 결과가 만족스러우면 계속해서 시스템의 구성원으로 남는다. 사용자들이 계속해서 구성원으로 참여할 수 있도록 시스템에 대한 신뢰를 강화시키려면 <code>시스템의 무결성</code>이 필요하다. 이것이 부족하면 신뢰가 낮아지고 소비자를 잃게 된다.</p>
<p><em>그렇다면 순수 분산 P2P 시스템의 무결성을 확보하고 유지할 수 있는 방법은 무엇일까?</em></p>
<ul>
<li>전체 노드 또는 피어의 개수를 아는가?</li>
<li>각 피어의 신뢰성에 대해 어느 정도 알고 있는가?</li>
</ul>
<p>분산 P2P 시스템 내의 <code>노드 개수</code>와 <code>각 노드의 신뢰성</code>을 알고 있다면 무결성을 확보할 가능성이 더 커진다.</p>
<h3 id="P2P-시스템의-무결성을-위협하는-두-가지-요소"><a href="#P2P-시스템의-무결성을-위협하는-두-가지-요소" class="headerlink" title="P2P 시스템의 무결성을 위협하는 두 가지 요소"></a>P2P 시스템의 무결성을 위협하는 두 가지 요소</h3><ol>
<li>기술적 결함</li>
</ol>
<p>P2P 시스템은 사용자의 개별 컴퓨터로 구성되는데 기계장비라는 것은 언제든 고장이나 오류를 일으킬 수 있기 때문에 개별 컴퓨터나 네트워크 장비 등이 고장이나 오류를 일으켰을 때 대처할 수 있어야 한다.</p>
<ol>
<li>악의적 피어</li>
</ol>
<p>기술적인 원인이 아닌 시스템을 자신의 이릭을 위해 착취하려는 악의적 사용자들이 있고, 이런 사용자들이 P2P 시스템의 신뢰성을 무너뜨린다. 다른 피어를 믿지 못하게 된다면 시스템 사용자들은 시스템을 떠날 것이다.</p>
<blockquote>
<p>블록체인이 해결해야 할 과제는 <code>개수도 알려져 있지 않고 신뢰성과 안정성도 알 수 없는 피어들로 구성된 순수 분산 P2P 시스템의 무결성을 확보하고 유지하는 것이다.</code> 컴퓨터 과학 분야에서는 비잔틴 장군 문제라 한다.</p>
</blockquote>
<hr>
<h2 id="5-그래서-블록체인이-뭔가요"><a href="#5-그래서-블록체인이-뭔가요" class="headerlink" title="5. 그래서 블록체인이 뭔가요?"></a>5. 그래서 블록체인이 뭔가요?</h2><blockquote>
<ol>
<li>데이터 구조의 명칭</li>
<li>알고리즘의 명칭</li>
<li>기술묶음의 명칭</li>
<li>일반 응용분야를 가지는 순수 분산 P2P 시스템을 포괄하는 용어</li>
</ol>
</blockquote>
<ol>
<li>데이터 구조의 명칭<blockquote>
<p>블록이라 불리는 단위에 모인 모든 데이터</p>
</blockquote>
</li>
</ol>
<p>블록체인은 책을 구성하는 페이지들과 유사하게 마치 체인처럼 서로 연결되어 있어서 블록체인이라는 이름이 붙었다. 데이터 구조에서 데이터 블록의 연결은 책의 페이지 번호 매김 방식과는 다른 특수한 번호 매김 방식을 사용한다.</p>
<ol>
<li><p>알고리즘의 명칭</p>
<blockquote>
<p>순수 분산 P2P 시스템에서 여러 블록체인-데이터-구조 내의 정보 내용을 민주주의 투표 방식과 비슷한 방법을 써서 서로 협상하는 일련의 명령어</p>
</blockquote>
</li>
<li><p>기술묶음의 명칭</p>
<blockquote>
<p>블록체인-데이터-구조, 블록체인-알고리즘, 암호화 및 보안 기술의 조합을 의미.</p>
</blockquote>
</li>
</ol>
<p>이들의 조합은 응용분야와 상관없이 순수 분산 P2P 시스템의 무결성을 확보하는 데 이용될 수 있다.</p>
<ol>
<li><p>일반 응용분야를 가지는 순수 분산 P2P 시스템을 포괄하는 용어</p>
<blockquote>
<p>블록체인-기술묶음을 활용하는 거래장부(원장ledger)들의 순수 분산 P2P 시스템을 지칭하는 포괄적인 용어</p>
</blockquote>
</li>
</ol>
<p>이 맥락에서 쓰이는 블록체인은 순수 분산 시스템을 구성하는 한 부분인 소프트웨어의 단위를 의미하는 것이 아니라 <code>순수 분산 시스템 전체를 의미한다.</code></p>
<p>이 책에서는 블록체인을 블록체인-기술묶음을 활용하는 원장의 순수 분산 P2P 시스템을 지칭하는 포괄적인 의미로 사용.</p>
<h3 id="블록체인이란"><a href="#블록체인이란" class="headerlink" title="블록체인이란?"></a>블록체인이란?</h3><blockquote>
<p>무결성을 확보하고 유지하기 위해 순서에 따라 연결된 블록들의 정보 내용을 암호화 기법과 보안기술을 이용해 협상하는 알고리즘으로 구성된 소프트웨어 요소를 활용하는 원장의 순수 분산 P2P 시스템.</p>
</blockquote>
<p>보통 블록체인의 목적을 디지털 화페의 소유권을 관리하기 위한 것으로 두기 마련인데, <strong>암호화폐의 소유권을 관리하는 것은 블록체인 응용분야의 하나일 뿐이며, 그 자체가 블록체인의 전부는 아니다.</strong></p>
<p>다만 블록체인이 유독 디지털 재화의 소유권 관리 측면이 부각된 것은 <em>1. 이해하고 설명하기 쉽고, 2. 경제에 가장 크게 영향을 미치는 실사례</em>이기 때문이다. 소유와 소유권 강화는 인간사회의 핵심 요소이기 때문에 소유권 관리 방식을 혁신적으로 바꿀 수 있는 블록체인이 엄청난 변혁을 불러올 수 있는 기술이라 여겨진다.</p>
<hr>
<h2 id="6-소유권의-본질-이해하기"><a href="#6-소유권의-본질-이해하기" class="headerlink" title="6. 소유권의 본질 이해하기"></a>6. 소유권의 본질 이해하기</h2><p>소유권을 증명하기 위해 단 한 명의 목격자라도 확보하는 것은 좋은 일인데, <strong>특히 독립적인 다수의 목격자를 확보하는 것이 중요하다.</strong> 이 아이디어가 블록체인의 핵심 개념 중 하나이다.</p>
<h3 id="소유권-입증에-필요한-3요소"><a href="#소유권-입증에-필요한-3요소" class="headerlink" title="소유권 입증에 필요한 3요소"></a>소유권 입증에 필요한 3요소</h3><ul>
<li>소유자가 누구인가</li>
<li>소유 물건은 무엇인가</li>
<li>소유자와 물건의 매핑</li>
</ul>
<p>소유권 사용은 오직 허가박은 사람만 그 자산을 사용하도록 인증하고 승인하면서 식별도 필요하다.</p>
<h3 id="속성으로-보안의-3가지-개념-이해하기"><a href="#속성으로-보안의-3가지-개념-이해하기" class="headerlink" title="속성으로 보안의 3가지 개념 이해하기"></a>속성으로 보안의 3가지 개념 이해하기</h3><ul>
<li>식별 : <code>누구</code>라고 주장하는 것</li>
<li>인증 : 당신과 당신이라고 주장하는 누군가가 <code>일치하는지 증명</code></li>
<li><p>승인 : 사전에 인증된 개체에 대해 무엇인가에 대한 <code>접근을 허가하는 것.</code></p>
</li>
<li><p><code>식별</code>: <strong>이름 또는 다른 식별자를 사용해 ‘누군가’라고 주장하는 것.</strong> 식별을 통해 대상이 ‘누구’라고 주장할 수 있는데 그렇게 주장한 사람과 누구로 주장된 사람이 일치하는지는 증명할 수 없다.</p>
</li>
<li><p><code>인증</code>: <strong>어떤 사람이 다른 누군가를 사칭하는 것을 방지하기 위한 것.</strong> ‘누구’라고 주장한 사람과 ‘누구’로 주장된 사람이 일치하는지를 ‘무엇’을 통해 증명한다. 이때 ‘무엇’은 ‘누구’라고 주장되는 그 사람만의 고유한 무엇이어야 한다. (e.g. 지문, 얼굴 사진 등 고유성을 식별해 줄 수 있는 것.)</p>
</li>
<li><p><code>승인</code>: <strong>식별된 사람의 성질과 특성에 기반해 특정 자원이나 서비스에의 접근을 허가해 주는 것.</strong> 성공적인 인증과 함께 인증된 특정인이 가진 특성과 권리에 대한 평가를 토대로 얻는 최종 결과. 항상 이미 인증된 개체의 특성이나 성질을 특정 규칙과 비교 평가한 다음 이루어진다.</p>
</li>
</ul>
<h3 id="원장은-소유권을-증명하기도-이전하기도-한다"><a href="#원장은-소유권을-증명하기도-이전하기도-한다" class="headerlink" title="원장은 소유권을 증명하기도, 이전하기도 한다"></a>원장은 소유권을 증명하기도, 이전하기도 한다</h3><p>원장은 두 가지 상반된 역할을 수행한다.</p>
<ul>
<li>원장에서 읽은 과거 데이터를 이용해 <strong>소유권을 증명해 주는 수단</strong>의 역할</li>
<li>소유권의 이전이 발생한 경우 <strong>원장에 새로운 데이터를 생성하여 이 사실을 문서화</strong>해두는 역할</li>
</ul>
<p>원장이 누구에게나 공개되어 있다면 소유권 증명은 쉬워진다. 따라서 투명성은 소유권을 증명하는 기초가 되고, 소유권의 이전은 법적인 소유자에게만 배타적으로 허가된다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>원장의 소유권 증명</th>
<th>원장의 소유권 이전</th>
</tr>
</thead>
<tbody>
<tr>
<td>소유권 증명</td>
<td>소유권 이전</td>
</tr>
<tr>
<td>투명성</td>
<td>개인정보 보호</td>
</tr>
<tr>
<td>데이터 읽기</td>
<td>데이터 쓰기</td>
</tr>
<tr>
<td>데이터 이력 사용</td>
<td>신규 데이터 생성</td>
</tr>
<tr>
<td>상태 유지</td>
<td>상태 변경</td>
</tr>
</tbody>
</table>
</div>
<p>원장은 위와 같이 두 가지 상반된 역할들을 수행하는데 블록체인도 이와 비슷하다. <em>누구나 읽을 수 있게 개방된 원장과 유사한 데이터 구조를 사지는 거대한 분산 P2P 시스템이기 때문이다.</em></p>
<h3 id="소유권-관리자로-임명된-블록체인"><a href="#소유권-관리자로-임명된-블록체인" class="headerlink" title="소유권 관리자로 임명된 블록체인"></a>소유권 관리자로 임명된 블록체인</h3><p>정부 규제 원장처럼 형식을 갖춘 목격자를 만드는 것이 자산의 소유권을 명확히 하는 핵심 요소인데, 독립적인 목겨자들이 많아서 상호 영향을 받지 않는 증언을 많이 확보하는 것이 진실을 찾기 위한 이 접근방식의 핵심이다. 이러한 방식을 원장의 소유권 명확화에 적용하면 <em>조작될 위험이 있는 원장을 하나만 유지하는 대신 원장의 순수 분산 P2P 시스템을 활용해 다수의 노드가 동의하는 진실을 이용해 소유권을 확인하면 된다.</em> 즉 하나의 중앙 통제된 원장은 훼손이나 위조의 위험이 있기 때문에 하나의 중앙 통제된 원장 대신 소유권을 기록하는 개별 원장들의 그룹을 형성한 뒤 대다수의 개별 원장이 동의하는 진실을 사용해 소유권을 관리한다.</p>
<ul>
<li>소유권 관리를 위해 사용된 개별 원장은 소유권 관련 데이터를 저장하기 위해 사용된 블록체인-데이터-구조 하나와 같다.</li>
<li>개별 원장들은 P2P 시스템의 컴퓨터(노드)에 저장된다.</li>
<li>블록체인-알고리즘은 개별 노드들이 최종 판결의 기초가 되는 하나의 일관된 소유권 상태에 집단적으로 도달하게 해준다.</li>
<li>시스템의 무결성이란 소유권에 대한 진실을 판단할 능력을 말한다.</li>
<li>식별, 인증, 승인, 데이터 보안을 믿을 수 있는 수단으로 만들기 위해 암호화 기법이 필요하다.</li>
</ul>
<hr>
<h2 id="7-이중사용-블록체인이-해결한다"><a href="#7-이중사용-블록체인이-해결한다" class="headerlink" title="7. 이중사용, 블록체인이 해결한다"></a>7. 이중사용, 블록체인이 해결한다</h2><h3 id="P2P-시스템의-취약성을-이용한-범죄-예방책"><a href="#P2P-시스템의-취약성을-이용한-범죄-예방책" class="headerlink" title="P2P 시스템의 취약성을 이용한 범죄 예방책"></a>P2P 시스템의 취약성을 이용한 범죄 예방책</h3><p><code>이중사용</code>은 이중분양 사기와 비슷한데 두 사람이 동시에 같은 집을 소유할 수 없고, 둘 중 하나만 새로운 합법적 소유자가 되어야 하는 상황을 말한다. 이 책에서는 이중사용을 <em>원장의 순수 분산 P2P 시스템에 발생할 수 있는 취약성을 의미하는 말</em>로 사용하였다. 예를 들어 P2P 시스템에서 소유권이 다른 사람에게 이전될 때 모든 원장이 소유권 이전 사실이 기록된 최신 버전으로 갱신되어야 하는데, 여기에는 시간이 좀 걸리기 때문에 어떤 피어는 최신 정보를 알고 잇고, 다른 피어는 아직 그 정보를 모르는 상태가 있을 수 있다. 그렇기 때문에 예를 들어 만약 A가 B에게 소유권을 이전한 사실을 다른 피어들이 알기 전에 악의적으로 다른 대상에게 소유권 이전을 시도하면 아직 소유권 이전에 대한 사실을 모르는 피어들은 이를 승인하게 된다. 이처럼 소유권을 중복해서 판매할 수 있는 문제점이 생긴다.</p>
<h3 id="대표적인-이중사용-문제-3가지-유형"><a href="#대표적인-이중사용-문제-3가지-유형" class="headerlink" title="대표적인 이중사용 문제 3가지 유형"></a>대표적인 이중사용 문제 3가지 유형</h3><p><strong>1. 디지털 재화를 복사해 발생하는 이중사용 문제</strong></p>
<p>컴퓨터 데이터는 별다른 제약 없이 복사할 수 있는 특성이 있어서 디지털 재화를 비롯한 소유자가 둘 이상일 수 없는 모든 데이터에 문제를 야기한다. 디지털 화폐를 복사해서 동일한 돈을 반복해서 지불에 사용하는 행위이다.</p>
<p><strong>2. 원장의 분산 P2P 시스템에서 발생하는 이중사용 문제</strong></p>
<p>모든 요소들이 소유권 이전과 같은 정보를 전달받기까지 시간이 걸리는 문제 때문에 일부 피어가 상이한 소유권 정보를 가지는 상황이 발생한다. 모든 피어가 동시에 최신 정보를 갖지 못하면 먼저 최신 정보를 습득한 누군가가 이를 악용해서 이중 사용할 우려가 있다.</p>
<p><strong>3. 순수 분산 P2P 시스템의 무결성이 침해된 이중사용 문제</strong></p>
<p>이중사용을 추상화해서 바라보면 <em>분산 P2P 시스템 내 데이터의 일관성을 유지하는 문제이며, 이는 시스템 무결성의 한 측면이기도 하다.</em> 따라서 이중사용은 시스템 무결성이 침해된 특정 사례라 할 수 있다.</p>
<h3 id="이중사용-문제를-해결하는-방법"><a href="#이중사용-문제를-해결하는-방법" class="headerlink" title="이중사용 문제를 해결하는 방법"></a>이중사용 문제를 해결하는 방법</h3><p><strong>1. 디지털 재화를 복사해 이중으로 지불하는 문제 해결</strong></p>
<p>디지털 재화를 나타내는 데이터와 소유자를 매핑하는 수단만 있으면 해결 가능.</p>
<p><strong>2. 원장의 분산 P2P 시스템에서 발생한 이중사용 해결</strong></p>
<p>응용분야는 물론 아키텍처까지 알고 있을 때 블록체인이란 용어 자체가 원장의 분산 P2P 시스템의 이중사용 문제를 없애주는 해결책.</p>
<p><strong>3. 분산 P2P 시스템의 무결성이 침해된 이중사용 해결</strong></p>
<p>시스템의 아키텍처는 특정되었지만 응용분야는 특정되지 않았을 때, 시스템의 구체적인 용도와 상관없이 분산 P2P 시스템의 무결성을 확보하고 유지하는 것에 초점이 있다. <strong>단 분산 P2P 시스템의 <code>용도</code>가 무엇인지에 따라 무결성의 내용과 의미가 결정된다.</strong> 따라서 블록체인-기술묶음이 시스템의 무결성을 확보하고 유지할 수 있는 적절한 도구인가는 <code>응용분야의 목적</code>을 알아야만 판단할 수 있다.</p>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/01/220302_item56to62/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/220302_item56to62/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 56 - 아이템 62</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-02T00:00:00+09:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-07 16:44:50" itemprop="dateModified" datetime="2022-03-07T16:44:50+09:00">2022-03-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-56-정보를-감추는-목적으로-private-사용하지-않기"><a href="#아이템-56-정보를-감추는-목적으로-private-사용하지-않기" class="headerlink" title="아이템 56 정보를 감추는 목적으로 private 사용하지 않기"></a>아이템 56 정보를 감추는 목적으로 private 사용하지 않기</h2><p>자바스크립트는 클래스에 비공개 속성을 만들 수 없다. 비공개 속성임을 나태내기 위해 <code>언더스코어(_)</code>를 접두사로 붙이던 것이 관례로 인정되어 왔던 것 뿐이다. <em>하지만 언더스코어를 붙이는 것은 비공개라고 표시한 것 뿐, 일반적인 속성과 동일하게 클래스 외부로 공개되어 있다.</em></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Diary &#123;</span><br><span class="line">  <span class="keyword">private</span> secret = <span class="string">'cheated on my English test'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> diary = <span class="keyword">new</span> Diary()</span><br><span class="line">;(diary <span class="keyword">as</span> <span class="built_in">any</span>).secret <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>타입스크립트에서 위의 예시처럼 public, protected, private 접근 제어자를 사용하기 때문에 규칙을 강제하는 것으로 오해하기 쉬운데 <strong>이는 타입스크립트 키워드이기 때문에 컴파일 후에 제거된다.</strong> 그래서 타입스크립트의 컴파일되면 위의 예제는 아래의 예제처럼 자바스크립트 코드(target=ES2017)로 변환된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Diary &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.secret = <span class="string">'cheated on my English test'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> diary = <span class="keyword">new</span> Diary()</span><br><span class="line">diary.secret</span><br></pre></td></tr></table></figure>
<p>컴파일 후에 확인해보면 타입스크립트 키워드인 private이 제거되었고, secret은 일반적인 속성이어서 접근할 수 있다. 즉 언더스코어의 관례처럼 타입스크립트의 접근 제어자들도 런타임에는 아무런 효력이 없다. 심지어 타입스크립트 상태에서도 단언문을 사용하면 private에 접근 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">text: string</span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">PasswordChecker</span> </span>&#123;</span><br><span class="line">  checkPassword: <span class="function">(<span class="params">password: string</span>) =&gt;</span> boolean</span><br><span class="line">  <span class="keyword">constructor</span>(passwordHash: number) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkPassword = <span class="function">(<span class="params">password: string</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> hash(password) === passwordHash</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checker = <span class="keyword">new</span> PasswordChecker(hash(<span class="string">'s3cret'</span>))</span><br><span class="line">checker.checkPassword(<span class="string">'s3cret'</span>) <span class="comment">// Returns true</span></span><br></pre></td></tr></table></figure>
<p>따라서 정보를 감추기 위한 목적으로 private을 사용하면 안된다. <em>자바스크립트에서 정보를 숨기기 위한 가장 효과적은 방법은 클로저이다.</em> 위의 예시는 생성자에서 클로저를 만드는 예시이다. 이렇게 작성하면 PasswordChecker의 생성자 외부에서 passwordHash 변수에 접근할 수 없어서 정보를 숨기는 목적은 달성하게 되는데, 주의사항이 있다. passwordHash를 생성자 외부에서 접근할 수 없기 때문에 passwordHash에 접근해야 하는 메서드는 생성자 내부에 정의되어야 한다. 또 메서드 정의가 생성자 내부에 존재하게 되면, 인스턴스를 생성할 때마다 각 메서드의 복사본이 생성되기 때문에 메모리를 낭비하게 된다. 클로저를 쓰지 않으면 현재 표준화가 진행 중인 비공개 필드 기능을 사용할 수 있는데, 접두사 #을 붙여서 타입 체크과 런타임 모두에서 비공개로 만드는 역할을 한다.</p>
<hr>
<h2 id="아이템-57-소스맵을-사용하여-타입스크립트-디버깅하기"><a href="#아이템-57-소스맵을-사용하여-타입스크립트-디버깅하기" class="headerlink" title="아이템 57 소스맵을 사용하여 타입스크립트 디버깅하기"></a>아이템 57 소스맵을 사용하여 타입스크립트 디버깅하기</h2><p>타입스크립트 코드를 실행한다는 것은 타입스크립트 컴파일러가 생성한 자바스크립트 코드를 생성한다는 것이다. 그런데 변환된 자바스크립트 코드는 복잡해서 디버깅하기가 어렵다. <strong>디버깅하기 쉽도록 해결책을 내놓은 것이 소스맵이다.</strong> 소스맵은 변환된 코드의 위치와 심벌들을 원본 코드의 원래 위치와 심벌들로 매핑한다. 보통 자바스크립트로 변환된 코드는 원본 코드와 거의 비슷해서 디버깅하기 쉽지만 복잡하게 변환된다면 소스맵이 필요하다. 타입스크립트가 소스맵을 생성할 수 있도록 tsconfig.json에 소스맵 옵션을 다음과 같이 설정한다.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compiletOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"sourceMap"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-58-모던-자바스크립트로-작성하기"><a href="#아이템-58-모던-자바스크립트로-작성하기" class="headerlink" title="아이템 58 모던 자바스크립트로 작성하기"></a>아이템 58 모던 자바스크립트로 작성하기</h2><p>타입스크립트 코드를 특정 버전의 자바스크립트로 컴파일 할 수 있다. 즉 타입스크립트를 자바스크립트 트랜스 파일러로 사용할 수 있다. 옛날 버전의 자바스크립트 코드를 타입스크립트 컴파일러에서 동작하게 만들면 그 이후 회신 버전의 자바스크립트 기능을 코드에 추가해도 문제가 없다. 이렇게 옛날 버전의 자바스크립트 코드를 최신 버전의 자바스크립트로 바꾸는 작업이 타입스크립트로 전환하는 작업의 일부라 볼 수 있다. <em>타입스크립트는 자바스크립트의 상위 집합이기 때문에 코드를 최신 버전으로 바꾸다 보면 타입스크립트의 일부를 저절로 익힐 수 있다.</em> 타입스크립트 도입 시 가장 중요하나 기능은 ECMAScript 모듈과 ES2015 클래스이다.</p>
<h3 id="ECMA-모듈-사용하기"><a href="#ECMA-모듈-사용하기" class="headerlink" title="ECMA 모듈 사용하기"></a>ECMA 모듈 사용하기</h3><p>ES2015부터 import, export를 사용하는 ECMAScript 모듈이 표준이 되었다. 따라서 자바스크립트 코드가 단일 파일이거나 비표준 모듈 시스템을 사용 중이라면 ES 모듈로 전환해야 한다. 이 과정에서 웹팩이나 ts-node와 같은 도구가 필요할 수도 있다. ES 모듈 시스템은 모듈 단위로 전환할 수 있게 해주기 때문에 점진적 마이그레이션이 원활해진다.</p>
<h3 id="프로토타입-대신-클래스-사용하기"><a href="#프로토타입-대신-클래스-사용하기" class="headerlink" title="프로토타입 대신 클래스 사용하기"></a>프로토타입 대신 클래스 사용하기</h3><p>자바스크립트에서 프로토타입 기반의 객체 모델을 사용하는데, 많은 개발자들이 클래스 기반 모델을 선호했기 때문에 ES2015에서 class 키워드를 사용하는 클래스 기반 모델이 도입되었다. <em>만약 단순한 객체를 다룰 때 프로토타입을 사용하고 있었다면 클래스로 바꾸는 것이 좋다.</em></p>
<h3 id="var-대신-let-const-사용하기"><a href="#var-대신-let-const-사용하기" class="headerlink" title="var 대신 let/const 사용하기"></a>var 대신 let/const 사용하기</h3><p>var 키워드에는 스코프 규칙의 문제가 있었고, let이나 const를 쓰는 것으로 이러한 문제를 피할 수 있었다. var로 되어있던 코드를 let이나 const로 수정하면 일부 코드에서 타입스크립트가 오류를 표시할 수 있다. 만약 오류가 발생했다면 잠재적으로 스코프 문제가 존재하는 코드이니 수정이 필요하다.</p>
<h3 id="for-대신-for-of-또는-배열-메서드-사용하기"><a href="#for-대신-for-of-또는-배열-메서드-사용하기" class="headerlink" title="for(;;) 대신 for-of 또는 배열 메서드 사용하기"></a>for(;;) 대신 for-of 또는 배열 메서드 사용하기</h3><p>과거에는 자바스크립트가 배열을 순회할 때 for 루프를 사용했는데 모던 자바스크립트에는 <code>for~of</code>가 존재하기 때문에 이를 사용하면 된다. for~of가 for문에 비해 코드가 짧고 인덱스 변수를 사용하지 않기 때문에 실수를 줄일 수 있다. 만약 인덱스 변수가 필요하다면 forEach를 사용하면 되고, 비슷한 루프문으로 for~in도 있지만 몇 가지 문제점이 있으므로 쓰지 않는 것이 좋다.</p>
<h3 id="함수-표현식보다-화살표-함수-사용하기"><a href="#함수-표현식보다-화살표-함수-사용하기" class="headerlink" title="함수 표현식보다 화살표 함수 사용하기"></a>함수 표현식보다 화살표 함수 사용하기</h3><p>this 키워드는 일반 변수들과 다른 스코프 규칙을 가지기 때문에 가장 어려운 개념 중 하나이다. 그러나 화살표 함수를 사용하면 상위 스코프의 this를 유지할 수 있다. 컴파일러 옵션에 noImplicitThis(또는 strict)를 설정하면 타입스크립트가 this 바인딩 관련된 오류를 표시해준다.</p>
<h3 id="단축-객체-표현과-구조-분해-할당-사용하기"><a href="#단축-객체-표현과-구조-분해-할당-사용하기" class="headerlink" title="단축 객체 표현과 구조 분해 할당 사용하기"></a>단축 객체 표현과 구조 분해 할당 사용하기</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>,</span><br><span class="line">  y = <span class="number">2</span>,</span><br><span class="line">  z = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123;</span><br><span class="line">  x: x,</span><br><span class="line">  y: y,</span><br><span class="line">  z: z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같은 코드는 아래와 같이 구조 분해 할당을 이용하여 더 간단하게 표현할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>,</span><br><span class="line">  y = <span class="number">2</span>,</span><br><span class="line">  z = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123; x, y, z &#125;</span><br></pre></td></tr></table></figure>
<h3 id="함수-매개변수-기본값-사용하기"><a href="#함수-매개변수-기본값-사용하기" class="headerlink" title="함수 매개변수 기본값 사용하기"></a>함수 매개변수 기본값 사용하기</h3><p>자바스크립트의 함수의 모든 매개변수는 선택적(생략 가능)이며, 매개변수를 지정하지 않았을 때는 undefined로 간주된다. 매개변수에 기본값을 직접 지정할 수도 있는데 이렇게 하면 코드가 간결해진다.</p>
<h3 id="저수준-프로미스나-콜백-대신-async-await-사용하기"><a href="#저수준-프로미스나-콜백-대신-async-await-사용하기" class="headerlink" title="저수준 프로미스나 콜백 대신 async/await 사용하기"></a>저수준 프로미스나 콜백 대신 async/await 사용하기</h3><p>async/await가 코드의 가독성을 높이는 것 뿐 아니라 비동기 코드에 타입 정보가 전달되어 타입 추론을 가능하게 한다.</p>
<h3 id="연관-배열에-객체-대신-Map과-Set-사용하기"><a href="#연관-배열에-객체-대신-Map과-Set-사용하기" class="headerlink" title="연관 배열에 객체 대신 Map과 Set 사용하기"></a>연관 배열에 객체 대신 Map과 Set 사용하기</h3><h3 id="타입스크립트에-use-strict-넣지-않기"><a href="#타입스크립트에-use-strict-넣지-않기" class="headerlink" title="타입스크립트에 use strict 넣지 않기"></a>타입스크립트에 use strict 넣지 않기</h3><p>버그가 될 수 있는 코드 패턴에 오류를 표시해 주는 엄격 모드가 ES5에서 도입되었는데 타입스크립트에서 수행되는 안정성 검사가 엄격 모드보다 훨싼 더 엄격한 체크를 수행한다.</p>
<hr>
<h2 id="아이템-59-타입스크립트-도입-전에-ts-check와-JSDoc으로-시험해-보기"><a href="#아이템-59-타입스크립트-도입-전에-ts-check와-JSDoc으로-시험해-보기" class="headerlink" title="아이템 59 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기"></a>아이템 59 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기</h2><p>@ts-check 지시자를 써서 타입 체커가 파일을 분석하고, 발견된 오류를 보고하도록 지시할 수 있다. 단 매우 느슨한 수준으로 타입 체크를 수행하고, noImplicitAny를 해제한 것보다 헐거운 체크를 수행한다. <em>JSDoc의 @types 구문을 사용해서 타입 단언을 대체할 수 있는데 이때 중요한 것은 타입을 감싸는 중괄호가 필요하다는 것이다.</em> 이처럼 자바스크립트 환경에서도 @ts-check 지시자와 JSDoc 주석으로 타입스크립트와 비슷한 경험의 작업이 가능하다.</p>
<h2 id="아이템-60-allowJs로-타입스크립트와-자바스크립트-같이-사용하기"><a href="#아이템-60-allowJs로-타입스크립트와-자바스크립트-같이-사용하기" class="headerlink" title="아이템 60 allowJs로 타입스크립트와 자바스크립트 같이 사용하기"></a>아이템 60 allowJs로 타입스크립트와 자바스크립트 같이 사용하기</h2><p>마이그레이션 기간 중에 자바스크립트와 타입스크립트가 동시에 동작할 수 있도록 해야 한다. 이 두 가지가 공존할 수 있도록 하는 핵심은 <code>allowJs</code>컴파일러 옵션이다. 타입스크립트 파일과 자바스크립트 파일을 서로 임포트할 수 있게 해준다. 타입 체크와 관련이 없지만 기존 빌드 과정에 타입스크립트 컴파일러를 추가하기 위해서도 allowJs 옵션이 필요하고, 모듈 단위로 타입스크립트로 전환하는 과정에서 테스트를 수행해야 하기 때문에도 이 옵션이 필요하다.</p>
<hr>
<h2 id="아이템-61-의존성-관계에-따라-모듈-단위로-전환하기"><a href="#아이템-61-의존성-관계에-따라-모듈-단위로-전환하기" class="headerlink" title="아이템 61 의존성 관계에 따라 모듈 단위로 전환하기"></a>아이템 61 의존성 관계에 따라 모듈 단위로 전환하기</h2><p>점진적 마이그레이션에서는 모듈 단위로 각개격파하는 것이 이상적인데, 한 모듈을 골라서 타입 정보를 추가하면 <em>해당 모듈이 의존하는 모듈에서 비롯되는 타입 오류</em>가 발생하게 된다. 따라서 다른 모듈에 의존하지 않는 최하단 모듈부터 시작하여 의존성의 최상단에 있는 모듈을 마지막으로 완성해야 한다.</p>
<ul>
<li>서드파티 라이브러리 타입 정보를 가장 먼저 해결한다.</li>
</ul>
<p>프로젝트 내에 존재하는 모듈은 서드파티 라이브러리에 의존하지만 서드파티 라이브러리는 해당 모듈에 의존하지 않기 때문에 가장 먼저 타입 정보를 해결해야 한다. <code>@types</code>모듈을 설치하면 된다. (e.g. @types/lodash)</p>
<ul>
<li>외부 API의 타입 정보 추가</li>
</ul>
<p>프로젝트 내의 모듈은 API에 의존하지만 API는 해당 모듈에 의존하지 않기 떄문에 먼저 해결한다. 단 특별한 문맥이 없어서 타입스크립트가 추론하기 어렵기 때문에 <strong>API에 대한 사양을 기반으로 타입 정보를 생성하도록 한다.</strong></p>
<ul>
<li><p>의존성 관계도에서 가장 의존성이 낮은 모듈부터 타입 정보 추가<br>대부분의 프로젝트 최하단에 유틸리티 종류의 모듈이 위치하는 패턴이 있다. <strong>이때 중요한 것은 타입정보를 추가한 것이지 리팩토링을 하려 해서는 안된다.</strong></p>
</li>
<li><p>선언되지 않은 클래스 멤버</p>
</li>
</ul>
<p>자바스크립트에서 클래스 멤버 변수를 선언할 필요가 없지만 타입스크립트에서는 명시적으로 선언해야 한다.</p>
<ul>
<li>타입이 바뀌는 값</li>
</ul>
<p>자바스크립트일 때 문제가 없다가 타입스크립트가 되는 순간 오류가 발생하는 값들이 많은데, 한꺼번에 객체를 생성하여 간단히 오류를 해결할 수 있다. 한꺼번에 생성이 어렵다면 타입 단언문을 사용할 수 있다. <em>단, 당장 마이그레이션이 최우선이라 임시 방편으로 사용한 것이지 마이그레이션이 완료된 후에는 적절한 방법으로 타입을 선언해야 한다.</em> 또한 자바스크립트에서 JSDoc와 @ts-check를 사용해서 타입 정보를 추가했다면 타입스크립트로 전환하는 순간 타입 정보가 무효화 된다는 것에 유의하도록 한다.</p>
<ul>
<li>테스트 코드를 타입스크립트로 전환<br>로직 코드가 테스트 코드에 의존하지 않기 때문에, 테스트 코드는 항상 의존성 관계도의 최상단에 위치한다. 따라서 최하단의 모듈부터 마이그레이션 하는 중에도 테스트는 정상적으로 수행할 수 있다.</li>
</ul>
<hr>
<h2 id="아이템-62-마이그레이션의-완성을-위해-noImplicitAny-설정하기"><a href="#아이템-62-마이그레이션의-완성을-위해-noImplicitAny-설정하기" class="headerlink" title="아이템 62 마이그레이션의 완성을 위해 noImplicitAny 설정하기"></a>아이템 62 마이그레이션의 완성을 위해 noImplicitAny 설정하기</h2><p>만약 noImplicitAny를 설정하지 않았다면 타입 선언에서 비롯되는 실제 오류를 완벽하게 잡을 수 없으므로 마이그레이션이 완료되었다고 말하기 어렵다. 아래와 같은 코드는 <code>noImplicitAny:true</code>를 설정한 순간 에러가 발생하게 된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsConfig: &#123;"noImplicitAny":true,"strictNullChecks":false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HIDE</span></span><br><span class="line"><span class="keyword">class</span> Chart &#123;</span><br><span class="line">  indices: <span class="built_in">number</span>[]</span><br><span class="line">  <span class="comment">// END</span></span><br><span class="line">  getRanges() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> r of <span class="keyword">this</span>.indices) &#123;</span><br><span class="line">      <span class="keyword">const</span> low = r[<span class="number">0</span>]</span><br><span class="line">      <span class="comment">// ~~~~ Element implicitly has an 'any' type because</span></span><br><span class="line">      <span class="comment">//      type 'Number' has no index signature</span></span><br><span class="line">      <span class="keyword">const</span> high = r[<span class="number">1</span>]</span><br><span class="line">      <span class="comment">// ~~~~ Element implicitly has an 'any' type because</span></span><br><span class="line">      <span class="comment">//      type 'Number' has no index signature</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// HIDE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// END</span></span><br></pre></td></tr></table></figure>
<p>noImplicitAny를 설정할 때는 로컬에만 설정하고 작업을 하여 점진적 마이그레이션이 가능하도록 한다.</p>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/01/220302_blockchain01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/220302_blockchain01/" class="post-title-link" itemprop="url">블록체인 무엇인가? 1장</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-02T00:00:00+09:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-07 16:44:50" itemprop="dateModified" datetime="2022-03-07T16:44:50+09:00">2022-03-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>블록체인의 기본 개념을 제대로 알지 못하면 블록체인의 전반적인 가치나 잠재적인 영향력을 가늠할 수 없을뿐더러 블록체인이 창출하는 부가가치를 이해하기가 어렵다. 또한 (블록체인을 포함해서) 새로운 기술에 대한 개념적 이해가 부족하면 자극적이고 과장된 광고에 휩쓸려 비현실적이고 실현 불가능한 망상에 사로잡히기 쉬워 나중에 실망할 수도 있다. 따라서 이 책은 ‘블록체인의 기본 개념’에 집중한다.<br>&lt;책 서문 발췌&gt;</p>
</blockquote>
<h1 id="1-소프트웨어-공학에서-변하지-않는-주요-개념들"><a href="#1-소프트웨어-공학에서-변하지-않는-주요-개념들" class="headerlink" title="1. 소프트웨어 공학에서 변하지 않는 주요 개념들"></a>1. 소프트웨어 공학에서 변하지 않는 주요 개념들</h1><h2 id="1-시스템을-보는-눈-장착하기"><a href="#1-시스템을-보는-눈-장착하기" class="headerlink" title="1. 시스템을 보는 눈 장착하기"></a>1. 시스템을 보는 눈 장착하기</h2><h3 id="시스템을-계층과-측면으로-분리해-분석하기"><a href="#시스템을-계층과-측면으로-분리해-분석하기" class="headerlink" title="시스템을 계층과 측면으로 분리해 분석하기"></a>시스템을 계층과 측면으로 분리해 분석하기</h3><p>시스템을 개념적으로 분리하기 위해 사용하는 구분 기준은 다음의 두 가지다.</p>
<ul>
<li>응용계층 vs 구현계층</li>
<li>기능적 측면 vs 비기능적 측면</li>
</ul>
<h3 id="1-응용계층-vs-구현계층"><a href="#1-응용계층-vs-구현계층" class="headerlink" title="1. 응용계층 vs 구현계층"></a>1. 응용계층 vs 구현계층</h3><ul>
<li>응용계층: 사용자의 요구사항</li>
<li>구현계층: 요구사항을 실현. 구성요소는 본질적으로 기술적이다. 응용계층에서 사용자의 필요사항을 만족시키기 위한 수단.</li>
</ul>
<h3 id="2-기능적-측면-vs-비기능적-측면"><a href="#2-기능적-측면-vs-비기능적-측면" class="headerlink" title="2. 기능적 측면 vs 비기능적 측면"></a>2. 기능적 측면 vs 비기능적 측면</h3><ul>
<li>기능적 측면: 시스템이 <code>무엇</code>을 하는가? 동사적 역할. e.g. 네트워크를 통한 데이터 전송, 음악 연주 등</li>
<li>비기능적 측면: 시스템이 무엇을 <code>어떻게</code> 하는가? 부사적 역할. e.g. 멋진 인터페이스, 실행속도가 빠른 소프트웨어<ul>
<li>보안: 정확성을 포함하는 개념</li>
<li><code>무결성(integrity)</code>: 시스템이 의도한 대로 작동하는 것. 보안과 정확성 모두를 포함하는 개념</li>
</ul>
</li>
</ul>
<h3 id="사용자는-응용계층의-기능적-측면을-중시한다"><a href="#사용자는-응용계층의-기능적-측면을-중시한다" class="headerlink" title="사용자는 응용계층의 기능적 측면을 중시한다."></a>사용자는 응용계층의 기능적 측면을 중시한다.</h3><p>응용계층의 기능적 측면은 사용자의 명확한 요구사항들이므로 시스템에서 가장 중요하게 부각된다. <strong>반면 구현계층의 비기능적 요소는 시스템의 주요 요소가 아니라 아주 당연한 것으로 여겨진다. 그런데 비기능적 요소 중 무결성 같은 것은 눈에 보이지 않지만 매우 중요하다.</strong></p>
<h3 id="무결성의-주요-요소"><a href="#무결성의-주요-요소" class="headerlink" title="무결성의 주요 요소"></a>무결성의 주요 요소</h3><ul>
<li>데이터 무결성: 시스템에서 사용하고 유지 관리하는 데이터는 완전하고 정확하며 모순이 없다.</li>
<li>작동 무결성: 시스템은 의도한 대로 작동하며 논리적 오류가 없다.</li>
<li>보안: 시스템은 허가받은 사용자에게만 데이터 및 기능에 대한 접근 권한을 부여할 수 있다.</li>
</ul>
<hr>
<h2 id="2-큰-그림으로-바라보기"><a href="#2-큰-그림으로-바라보기" class="headerlink" title="2. 큰 그림으로 바라보기"></a>2. 큰 그림으로 바라보기</h2><p>노드, 컴퓨터, 피어는 동일한 의미를 가질 때가 많지만 반드시 그렇지 않다. 구조에 따라 단일 컴퓨터가 복수의 노드 역할을 할 수 있고, 하나의 노드에 복수의 컴퓨터가 연결되어 있을 수도 있다.</p>
<ul>
<li>피어:<ul>
<li>전체 시스템 노드 중 나와 직접 연결된 노드. 이더리움에서 구분해서 사용한다.</li>
<li>일대일의 의미를 강조하거나 노드를 사용해 특정 행위를 하는 사람의 관점에서 피어라 부름.</li>
</ul>
</li>
<li>노드: 보통의 책에서 전체 시스템 내의 한 요소임을 강조할 때 사용.</li>
<li>컴퓨터: 공유하는 자원 측면에 대해 기술할 때.</li>
</ul>
<h3 id="소프트웨어-아키텍처란-무엇이고-블록체인과-어떤-관계인가"><a href="#소프트웨어-아키텍처란-무엇이고-블록체인과-어떤-관계인가" class="headerlink" title="소프트웨어 아키텍처란 무엇이고 블록체인과 어떤 관계인가?"></a>소프트웨어 아키텍처란 무엇이고 블록체인과 어떤 관계인가?</h3><p>소프트웨어 시스템을 구현하는 방법은 여러가지가 있는데, <code>시스템 아키텍처</code>는 필수적으로 결정해야 한다. <em>시스템 아키텍처는 구성요소를 구조화하고, 구성요소 간 관계를 설정하는 방식을 의미한다.</em> 주로 사용되는 아키텍처는 <code>중앙 통제 방식</code>,<code>분산방식</code>이 있다.</p>
<ul>
<li>중앙 통제 방식<ul>
<li>구성요소들이 하나의 중앙요소에 연결되며, 중앙 요소를 가운데 두고 나머지 요소들이 둘러싸고 있는 구조.</li>
<li>모든 구성요소끼리 직접적으로 연결되지 않고 오직 중앙 요소와만 직접 연결되어 있다.</li>
</ul>
</li>
<li>분산 방식<ul>
<li>시스템을 통제하거나 조정하는 요소 없이 서로 연결된 네트워크 구조를 형성.</li>
<li>모든 구성 요소와 직접적으로 연결된 노드는 단 하나도 없지만 모든 노드는 간접적으로 서로 완전히 연결되어 있다.</li>
</ul>
</li>
</ul>
<h3 id="분산-시스템의-장점"><a href="#분산-시스템의-장점" class="headerlink" title="분산 시스템의 장점"></a>분산 시스템의 장점</h3><ol>
<li><p>계산 능력이 뛰어나다.</p>
<ol>
<li>서로 연결된 모든 컴퓨터의 계산 능력이 합쳐져 발현되기 때문에 단일 컴퓨터보다 더 강력한 계산 능력을 가진다.</li>
</ol>
</li>
<li><p>비용이 절감된다.</p>
<ol>
<li>여러 대의 컴퓨터로 구성되므로 초기 구성 비용은 슈퍼 컴퓨터보다 많지만 유지 운영 비용은 훨씬 적다. 또 슈퍼 컴퓨터와 달리 개별 컴퓨터가 교체 될 때 전체 시스템에 별 영향을 끼치지 않는다.</li>
</ol>
</li>
<li><p>더 안정적이다.</p>
<ol>
<li>시스템을 구성하는 개별 컴퓨터가 고장나면 나머지 구성요소들이 그 일을 대신하기 떄문에 전체 네트워크는 문제없이 잘 작동한다.</li>
</ol>
</li>
<li><p>자연스럽게 확장된다.</p>
<ol>
<li>앞서 계산 능력은 연결된 모든 컴퓨터의 계산 능력을 합친 것이라 했으므로, 시스템에 컴퓨터를 추가하면 손쉽게 전체 계산 능력을 높일 수 있다.</li>
</ol>
</li>
</ol>
<h3 id="분산-시스템의-단점"><a href="#분산-시스템의-단점" class="headerlink" title="분산 시스템의 단점"></a>분산 시스템의 단점</h3><ol>
<li><p>조정 오버헤드가 발생한다.</p>
<ol>
<li>중앙 통제 방식과 달리 중앙 요소가 존재하지 않기 때문에 구성요소들 스스로 조정을 해야하는데 이 조정이 쉽지 않아 많은 자원이 소모되는 오버헤드가 발생한다.</li>
</ol>
</li>
<li><p>통신 오버헤드가 발생한다.</p>
<ol>
<li>조정을 위해서 통신이 필수적이고, 이 통신을 위해 계산 능력의 일부가 통신 프로토콜 지원 및 메시지 송수신 및 처리에 소모된다.</li>
</ol>
</li>
<li><p>네트워크 의존도가 높다.</p>
<ol>
<li>컴퓨터들은 네트워크를 통해 통신하는데, 모든 네트워크는 자체적인 결함과 장애 가능성이 내재되어 있기 때문에 통신과 조정에 영향을 끼친다. 그리고 네트워크가 없으면 각 구성요소 간의 협력이 불가하기 때문에 네트워크 의존도가 높다.</li>
</ol>
</li>
<li><p>프로그램이 복잡해진다.</p>
<ol>
<li>앞서 말한 단점들을 해결하기 위해 중앙 통제 방식에서는 필요없는 조정, 통신, 네트워크 이용에 관련된 추가적인 문제 해결 등이 필요하다.</li>
</ol>
</li>
<li><p>보안에 신경써야 한다.</p>
<ol>
<li>네트워크를 통한 통신은 계산 작업 시 데이터의 전송과 공유가 꼭 필요하다. 그러나 이런 행위로 인해 악의를 가진 개체가 정보에 접근하여 악용하는 보안문제가 발생할 수 있다.</li>
</ol>
</li>
</ol>
<h3 id="사용자가-많아질수록-더-강력해지는-분산-P2P-시스템"><a href="#사용자가-많아질수록-더-강력해지는-분산-P2P-시스템" class="headerlink" title="사용자가 많아질수록 더 강력해지는 분산 P2P 시스템"></a>사용자가 많아질수록 더 강력해지는 분산 P2P 시스템</h3><blockquote>
<p>Peer to Peer 네트워크 또는 P2P 네트워크. 분산 네트워크의 특수한 형태</p>
</blockquote>
<p>개별 컴퓨터(노드)로 구성된 시스템으로 중앙 노드의 조정 없이 네트워크의 모든 구성원이 서로에게 계산 자원을 제공한다. <strong>네트워크의 각 노드는 시스템 내에서 동등한 권리와 역할을 가지고, 모두가 자원의 공급자인 동시에 소비자이다.</strong> 사용자들의 컴퓨터를 분산 시스템을 구성하는 노드로 만든다는 아이디어를 배경으로 다양한 분야에 응용이 가능하다.</p>
<h3 id="중앙-통제와-분산-시스템의-장점만-모은-혼합-시스템"><a href="#중앙-통제와-분산-시스템의-장점만-모은-혼합-시스템" class="headerlink" title="중앙 통제와 분산 시스템의 장점만 모은 혼합 시스템"></a>중앙 통제와 분산 시스템의 장점만 모은 혼합 시스템</h3><p>중앙 통제 시스템과 분산 시스템은 정반대의 구조를 가지고 있는데, 이 각각의 강점만 결합한 혼합 시스템이 있다.</p>
<ul>
<li><p>분산 시스템 내의 중앙 통제<br>분산 시스템 내부에 중앙 통제 요소를 구축한 아키텍처로 겉보기에 분산 시스템을 이루는 것처럼 보이지만 <strong>모든 노드는 중앙의 큰 원에 직접 연결되어 있다.</strong></p>
</li>
<li><p>중앙 통제 시스템 내의 분산 시스템<br>겉보기에 주변 노드가 모드 중앙의 큰 원에 직접 연결되어 있는 중앙 통제 시스템처럼 보이는데, 중앙의 큰 원 내부를 들여다보면 분산 시스템으로 구성되어 있다. 심지어 주변 구성요소들은 중앙 요소가 분산 시스템으로 이루어져 있는지 모를 수도 있다.</p>
</li>
</ul>
<h3 id="분산-시스템인지-구분하는-방법"><a href="#분산-시스템인지-구분하는-방법" class="headerlink" title="분산 시스템인지 구분하는 방법"></a>분산 시스템인지 구분하는 방법</h3><p>전체 시스템을 동시에 종료할 수 있는 단일 구성요소가 있는지 찾는다. 이런 요소가 있다면 분산 시스템이 아니다.</p>
<h3 id="큰-그림으로-본-블록체인의-목적"><a href="#큰-그림으로-본-블록체인의-목적" class="headerlink" title="큰 그림으로 본 블록체인의 목적"></a>큰 그림으로 본 블록체인의 목적</h3><p>소프트웨어 시스템 디자인에서 아키텍처의 선정은 시스템 구현 관점에서 목적 달성을 위한 수단이기 때문에 분산 방식 또는 중앙 통제 방식 중 어떤 것으로도 구현할 수 있다. 다만 어떤 아키텍처를 선택하느냐에 따라 시스템이 기능적, 비기능적 측면을 달성하는 방법에 영향을 미친다. <strong>특히 무결성에 대해서 두 가지 아키텍처가 매우 다른 방식으로 접근하기 때문에 이런 점에서 블록 체인이 중요하다.</strong> <code>블록체인은 분산 시스템이 무결성을 확보하게 해주는 도구이며, 분산 시스템의 무결성을 구현하고 유지하는 것이 바로 블록체인의 목적이다.</code>즉 구현계층의 비기능적 측면을 성취하게 해주는 도구이다.</p>
<hr>
<h2 id="3-P2P-시스템의-엄청난-잠재력"><a href="#3-P2P-시스템의-엄청난-잠재력" class="headerlink" title="3. P2P 시스템의 엄청난 잠재력"></a>3. P2P 시스템의 엄청난 잠재력</h2><h3 id="P2P-시스템이-세상을-어떻게-바꿀-것인가"><a href="#P2P-시스템이-세상을-어떻게-바꿀-것인가" class="headerlink" title="P2P 시스템이 세상을 어떻게 바꿀 것인가?"></a>P2P 시스템이 세상을 어떻게 바꿀 것인가?</h3><p>P2P 시스템이 음악산업을 어떻게 변화시켰는지를 보면서 블록체인과 어떤 관계가 있는지 살펴본다. 전통적인 음악산업은 음악가와 스튜디오가 계약을 맺고, 스튜디오가 음악가의 노래를 녹음해서 다양한 유통채널을 통해 판매하는 구조로 운영되어 왔다. 스튜디오가 사실상 음악가와 음악을 청취하고자 하는 사람들 사이의 <code>중개자</code>역할을 한 것이다. 중개자로서 스튜디오는 음반제작 전반에 관한 독점적 지식을 가지고 있었는데 2000년대 이후 음악의 디지털화, 개인 PC 보급 확대, 인터넷의 등장 등이 스튜디오를 더이상 필요하지 않게 만들었다. 즉 스튜디오가 가지고 있던 독점적인 지식인 제작, 마케팅, 판매를 스튜디오를 거치지 않고도 가능하게 된 것이다. 특히 냅스터라는 소프트웨어의 등장은 P2P 접근방식으로 MP3 파일을 공유하는 방식으로 음악을 소비하게 해주었기 때문에 스튜디오의 효용성이 더욱 떨어지게 되었다. 냅스터의 사례처럼 <strong>중개자 역할을 개인간의 상호작용으로 대체한다.</strong>는 아이디어를 기반으로 P2P 시스템이 음악 산업이 생태계 전쳬를 뒤흔든 것이다.</p>
<p>그런데 이런 P2P 시스템은 앞으로도 무형의 상품이나 디지털화된 상품 또는 서비스를 중개하는 역할을 주업으로 하는 산업에 큰 영향을 미치게 될 것이고, 결국은 이런 산업의 생태계도 P2P로 대체될 가능성이 높다. 금융업이 대표적인 예라고 할 수 있다. 대부분의 돈과 자산은 물리적인 지폐나 동전으로 거래되기 보다는 금융회사의 중앙 정보 기술 시스템에 저장되어 있고, 은행은 소비하는 사람들과 회사 사이의 중개자 역할을 주로 수행한다. 다만 간단한 거래 하나에도 상당수 많은 중개자가 관여하고 있어서 오랜 처리 시간과 많은 거래 비용을 필요로 하는 상황이다. 만약 P2P 거래 시스템을 사용한다면 훨씬 적은 시간과 비용을 들여 거래를 진행할 수 있다. 현재 은행의 중앙 통제 시스템에 비해 P2P 시스템은 중개자를 통해 간접적으로 상호작용하지 않고 거래 당사자끼리 직접 상호작용하기 때문에 처리 시간과 비용이 줄어든다.</p>
<h3 id="P2P-시스템과-블록체인은-어떤-관련이-있나"><a href="#P2P-시스템과-블록체인은-어떤-관련이-있나" class="headerlink" title="P2P 시스템과 블록체인은 어떤 관련이 있나?"></a>P2P 시스템과 블록체인은 어떤 관련이 있나?</h3><ol>
<li>P2P 시스템의 정의</li>
</ol>
<blockquote>
<p>여러 노드(개별 컴퓨터)들로 구성된 분산 소프트웨어 시스템. <code>한 노드의 자원을 다른 노드들이 직접 사용</code>할 수 있다는 특징이 있다.</p>
</blockquote>
<p>P2P 시스템에 참여하면 사용자의 컴퓨터는 시스템의 노드로 전환되고, 모든 노드에게는 동등한 권리와 역할이 주어진다. <strong>즉 시스템의 모든 노드는 동일한 기능과 책임을 가지고, 모든 사용자의 컴퓨터는 자원의 공급자인 동시에 소비자가 된다.</strong></p>
<ol>
<li>P2P 시스템의 아키텍처</li>
</ol>
<blockquote>
<p>P2P 시스템의 구조는 <code>분산 컴퓨터 시스템</code></p>
</blockquote>
<p>개별 노드로 구성된 컴퓨터들은 서로 자원을 공유한다. 순수 분산 P2P 시스템은 중앙에서 통제하거나 조정하는 어떤 요소도 없다. 따라서 모든 노드는 동일한 과제를 수행하고, 자원과 서비스의 생산자인 동시에 소비자 역할을 한다. 물론 중앙 통제 요소를 가지는 P2P 시스템도 존재한다. 이 시스템은 중앙 통제와 분산 시스템이 장점만을 뽑아 만들어진 것으로 중앙 노드를 이용해 노드 간 상호작용을 중개하고, 피어 노드가 제공하는 서비스 목록들을 유지 관리하고 노드를 검색하고 식별한다.</p>
<ol>
<li>P2P 시스템과 블록체인의 연관성</li>
</ol>
<blockquote>
<p>블록체인은 분산 시스템에서 무결성을 확보하고 유지하는 도구이다. <code>즉 순수 분산 P2P 시스템은 무결성의 확보와 유지를 위해 블록체인을 사용한다.</code></p>
</blockquote>
<p>이러한 P2P 시스템과 블록체인의 연관성 때문에 블록체인이 중요한 요소가 된 것이고, 무결성을 유지하고 확보하기 위한 도구라는 점보다 더욱 중요한 점은 <code>탈중개화</code>이다. 블록체인은 단지 <code>탈중개화</code>를 위한 도구일 뿐이다.</p>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/22/220223_item49to55/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/22/220223_item49to55/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 49 - 아이템 55</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-23 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-23T00:00:00+09:00">2022-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-07 16:44:50" itemprop="dateModified" datetime="2022-03-07T16:44:50+09:00">2022-03-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-49-콜백에서-this에-대한-타입-제공하기"><a href="#아이템-49-콜백에서-this에-대한-타입-제공하기" class="headerlink" title="아이템 49 콜백에서 this에 대한 타입 제공하기"></a>아이템 49 콜백에서 this에 대한 타입 제공하기</h2><p>this는 let,const와 달리 dynamic scope이기 때문에 정의된 방식이 아닌 <code>호출된 방식</code>에 따라 값이 달라진다. 아래 코드는 현재의 객체 인스턴스를 참조하는 <code>클래스</code>에서 많이 쓰이는 this이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">  vals = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  logSquares() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> val of <span class="keyword">this</span>.vals) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val * val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> C()</span><br><span class="line"><span class="keyword">const</span> method = c.logSquares</span><br><span class="line">method()</span><br></pre></td></tr></table></figure>
<p>이 코드는 런타임에 <em>uncaught TypeError: undefined의 ‘vals’속성을 읽을 수 없습니다.</em>는 오류를 발생시킨다. 그 이유는 <code>c.logSquares</code>가 <code>C.prototype.logSquares</code>를 호출하고, <code>this 값을 c로 바인딩</code>하는 두 가지 작업을 수행하기 때문이다. 이 작업에 따르면 this의 값은 undefined로 설정된다. 이런 문제를 해결하는 첫 번째 방법은 <code>call</code>을 사용해서 명시적으로 this를 바인딩하는 것이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> C()</span><br><span class="line"><span class="keyword">const</span> method = c.logSquares</span><br><span class="line">method.call(c) <span class="comment">// 제곱 출력</span></span><br></pre></td></tr></table></figure>
<p>이처럼 명시적인 <code>this 바인딩</code>을 통해 this의 타입에 대해 구체화할 수 있다. this 바인딩은 어떤 것에도 가능하며, 콜백 함수에도 쓰일 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">makeButton</span>(<span class="params">props: &#123; text: <span class="built_in">string</span>; onClick: () =&gt; <span class="built_in">void</span> &#125;</span>): <span class="title">void</span></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">ResetButton</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> makeButton(&#123; text: <span class="string">'Reset'</span>, onClick: <span class="keyword">this</span>.onClick &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  onClick() &#123;</span><br><span class="line">    alert(<span class="string">`Reset <span class="subst">$&#123;<span class="keyword">this</span>&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그런데 여기서도 this 바인딩 문제로 인해 <em>Reset이 정의되지 않았다는 에러가 발생한다.</em> 이때 해결하는 방법은 아래와 같이 <code>생성자에서 메서드에 this를 바인딩시키는 것이다.</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">makeButton</span>(<span class="params">props: &#123; text: <span class="built_in">string</span>; onClick: () =&gt; <span class="built_in">void</span> &#125;</span>): <span class="title">void</span></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">ResetButton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onClick = <span class="keyword">this</span>.onClick.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> makeButton(&#123; text: <span class="string">'Reset'</span>, onClick: <span class="keyword">this</span>.onClick &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  onClick() &#123;</span><br><span class="line">    alert(<span class="string">`Reset <span class="subst">$&#123;<span class="keyword">this</span>&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onClick()은 ResetButton.proptotype의 속성을 정의한다. 따라서 ResetButton의 모든 인스턴스에 공유된다. 그런데 위와 같이 생성자 함수에 바인딩하게 되면 onClick 속성에 this가 바인딩되어 해당 인스턴스에 생성된다. onClick 인스턴스 속성은 프로토타입 속성보다 앞에 놓이므로 <code>render() 메서드의 this.onClick은 바인딩된 함수를 참조하게 된다.</code> 하지만 onClick을 화살표 함수로 바꾸는 방법으로 좀 더 간단하게 해결할 수도 있다. 그 이유는 화살표 함수 내부에서 this를 참조하면 상위 컨텍스트의 this를 그대로 참조하기 때문이다. 따라서 ResetButton이 생성될 때 마다 제대로 바인딩된 this를 가지는 새 함수를 생성한다.</p>
<hr>
<h2 id="아이템-50-오버로딩-타입보다는-조건부-타입을-사용하기"><a href="#아이템-50-오버로딩-타입보다는-조건부-타입을-사용하기" class="headerlink" title="아이템 50 오버로딩 타입보다는 조건부 타입을 사용하기"></a>아이템 50 오버로딩 타입보다는 조건부 타입을 사용하기</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">any</span></span>) </span>&#123;</span></span><br><span class="line"><span class="function">  <span class="title">return</span> <span class="title">x</span> + <span class="title">x</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span></span><br><span class="line"><span class="function">  <span class="title">return</span> <span class="title">x</span> + <span class="title">x</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>함수 오버로딩(동일한 이름에 매개변수만 다른 여러 버전의 함수를 허용하는 것.단, 타입 수준에서 동작)의 개념을 통해 위와 같이 함수의 타입 정보를 추가한다. 그런데 이렇게 작성하면 선언문에서 number타입을 매개변수로 넣고, string타입을 반환하는 경우도 포함되어 있어서 모호한 지점이 생긴다. 이런 상황에서 <code>첫 번째 해결법은 제너릭을 사용하는 것</code>이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">number</span> | <span class="title">string</span>&gt;(<span class="params">x: T</span>): <span class="title">T</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">any</span></span>) </span>&#123;</span></span><br><span class="line"><span class="function">  <span class="title">return</span> <span class="title">x</span> + <span class="title">x</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">num</span> = <span class="title">double</span>(<span class="params">12</span>) // <span class="title">Type</span> <span class="title">is</span> 12</span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">str</span> = <span class="title">double</span>(<span class="params">'x'</span>) // <span class="title">Type</span> <span class="title">is</span> "<span class="title">x</span>"</span></span><br></pre></td></tr></table></figure>
<p>제너릭 타입을 쓰면서 앞서 말했던 number로 선언되어 string 타입을 반환하는 경우에 대해서 해결은 되었으나 지나치게 구체적인 타입이 되었다. string을 넣으면 string만 반환해야 하게 되었다. 좀 더 다른 방법으로 <code>여러 가지 타입 선언으로 분리</code>해 볼 수 있다. 함수의 구현체는 하나여도 타입 선언은 여러 개 만들 수 있기 때문에 함수 타입을 보다 명확하게 할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">any</span></span>) </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">return</span> <span class="title">x</span> + <span class="title">x</span></span></span></span><br><span class="line"><span class="function"><span class="function">&#125;</span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="title">const</span> <span class="title">num</span> = <span class="title">double</span>(<span class="params">12</span>) // <span class="title">Type</span> <span class="title">is</span> <span class="title">number</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="title">const</span> <span class="title">str</span> = <span class="title">double</span>(<span class="params">'x'</span>) // <span class="title">Type</span> <span class="title">is</span> <span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">return</span> <span class="title">double</span>(<span class="params">x</span>)</span></span></span><br><span class="line"><span class="function"><span class="function">  // ~ <span class="title">Argument</span> <span class="title">of</span> <span class="title">type</span> '<span class="title">string</span> | <span class="title">number</span>' <span class="title">is</span> <span class="title">not</span> <span class="title">assignable</span></span></span></span><br><span class="line"><span class="function"><span class="function">  //   <span class="title">to</span> <span class="title">parameter</span> <span class="title">of</span> <span class="title">type</span> '<span class="title">string</span>'</span></span></span><br><span class="line"><span class="function"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>단 유니온 타입에 대해서는 문제가 발생한다. <strong>타입스크립트는 오버로딩 타입 중에서 일치하는 타입을 찾을 때까지 순차적으로 검색한다.</strong> 마지막 선언인 string까지 검색했을 때 string | number 타입은 string에 할당할 수 없기 때문에 에러가 발생하는 것이다. 이때는 <code>오버로딩 타입으로 string|number를 추가</code>하여 문제를 해결할 수 있고, 더 좋은 방법은 아래와 같이 <code>조건부 타입</code>을 사용하는 것이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">number</span> | <span class="title">string</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  x: T</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">T</span> <span class="title">extends</span> <span class="title">string</span> ? <span class="title">string</span> : <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">any</span></span>) </span>&#123;</span></span><br><span class="line"><span class="function">  <span class="title">return</span> <span class="title">x</span> + <span class="title">x</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>조건부 타입을 사용하면 아래와 같이 반환 타입이 정교해진다.</p>
<ul>
<li>T가 string의 부분 집합이면 반환 타입이 string이다.</li>
<li>그 외의 경우는 반환 타입이 number이다.</li>
</ul>
<p>이처럼 조건부 타입은 개별 타입의 유니온으로 일반화하기 때문에 타입이 더욱 정확해진다. 조건부 타입은 타입 체커가 단일 표현식으로 받아들이기 때문에 타입 오버로딩에서 유니온 문제가 발생했을 때 문제를 해결할 수 있다.</p>
<hr>
<h2 id="아이템-51-의존성-분리를-위해-미러-타입-사용하기"><a href="#아이템-51-의존성-분리를-위해-미러-타입-사용하기" class="headerlink" title="아이템 51 의존성 분리를 위해 미러 타입 사용하기"></a>아이템 51 의존성 분리를 위해 미러 타입 사용하기</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseCSV</span>(<span class="params">contents: <span class="built_in">string</span> | Buffer</span>): </span>&#123; [column: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125;[] &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> contents === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="comment">// It's a buffer</span></span><br><span class="line">    <span class="keyword">return</span> parseCSV(contents.toString(<span class="string">'utf8'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// COMPRESS</span></span><br><span class="line">  <span class="keyword">return</span> []</span><br><span class="line">  <span class="comment">// END</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>다음 코드는 NodeJs 사용자를 위해 매개변수에 Buffer 타입을 허용한 예시이다. 그리고 Buffer의 타입 정의는 npm install —save-dev @types/node로 설치하여 얻을 수 있다. 단 타입 선언이 @types/node에 의존하기 때문에 devDependencies로 포함해야 하는데 이를 포함하면 <em>@types와 무관한 자바스크립트 개발자 또는 NodeJS와 무관한 타입스크립트 웹 개발자</em>에게 혼란을 줄 수 있다. 그 이유는 두 그룹 사용자가 사용하지 않는 모듈이 포함되어 있기 때문이다. Buffer는 NodeJS 개발자에게만 필요하다. 따라서 Buffer를 사용하는 대신 아래와 같이 필요한 메서드와 속성만 별도로 작성하는 방식으로 개선할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CsvBuffer &#123;</span><br><span class="line">  toString(encoding: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseCSV</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  contents: <span class="built_in">string</span> | CsvBuffer</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): </span>&#123; [column: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125;[] &#123;</span><br><span class="line">  <span class="comment">// COMPRESS</span></span><br><span class="line">  <span class="keyword">return</span> []</span><br><span class="line">  <span class="comment">// END</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>만약 작성 중인 라이브러리가 의존하는 라이브러리의 구현과 무관하게 타입에만 의존한다면, 필요한 선언부만 추출해서 작성 중인 라이브러리에 넣는 미러링을 고려해 볼 수 있다.</strong></p>
<hr>
<h2 id="아이템-52-테스팅-타입의-함정에-주의하기"><a href="#아이템-52-테스팅-타입의-함정에-주의하기" class="headerlink" title="아이템 52 테스팅 타입의 함정에 주의하기"></a>아이템 52 테스팅 타입의 함정에 주의하기</h2><p>타입 선언도 테스트를 거쳐야 하고, dtslint 또는 타입 시스템 외부의 타입을 검사하는 도구를 사용할 수 있다. 타입 선언이 예상한 타입으로 결과를 내는지 체크할 수 있는 한 가지 방법은 <code>함수를 호출하는 테스트 파일의 작성</code>이다. 그러나 단순히 함수를 실행만 하는 테스트 코드를 작성하는 것보다는 <code>반환 타입을 체크하는 것이 중요하다.</code> 반환값을 특정 타입의 변수에 할당하여 간단히 반환 타입을 체크할 수 있는 방법은 다음과 같다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lengths: <span class="built_in">number</span>[] = map([<span class="string">'john'</span>, <span class="string">'paul'</span>], <span class="function"><span class="params">name</span> =&gt;</span> name.length)</span><br></pre></td></tr></table></figure>
<p>이 코드는 불필요한 타입 선언에 해당하지만 테스트 관점에서는 매우 중요하다. 그런데 테스팅을 위해서 할당하는 방법에는 두 가지 문제가 있다.</p>
<ul>
<li><p>불필요한 변수를 만들어야 하고, 일부 린팅 규칙을 비활성화해야한다.</p>
<ul>
<li><strong>변수를 도입하는 대신 헬퍼 함수를 정의하는 것으로 해결한다.</strong></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertType</span>&lt;<span class="title">T</span>&gt;(<span class="params">x: T</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">assertType&lt;<span class="built_in">number</span>[]&gt;(map([<span class="string">'john'</span>, <span class="string">'paul'</span>], <span class="function"><span class="params">name</span> =&gt;</span> name.length))</span><br></pre></td></tr></table></figure>
</li>
<li><p>두 타입이 동일한지에 대한 체크 대신 <strong>할당 가능성을 체크한다.</strong></p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">12</span></span><br><span class="line">assertType&lt;<span class="built_in">number</span>&gt;(n) <span class="comment">//정상</span></span><br></pre></td></tr></table></figure>
<p>n 심벌은 타입이 숫자 리터럴 12인데, 12는 number의 서브타입이라서 할당 가능성 체크를 통과한다. 그러나 객체 타입 체크해서 문제가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> beatles = [<span class="string">'john'</span>, <span class="string">'paul'</span>, <span class="string">'george'</span>, <span class="string">'ringo'</span>]</span><br><span class="line">assertType&lt;&#123; name: <span class="built_in">string</span> &#125;[]&gt;(</span><br><span class="line">  map(beatles, <span class="function"><span class="params">name</span> =&gt;</span> (&#123;</span><br><span class="line">    name,</span><br><span class="line">    inYellowSubmarine: name === <span class="string">'ringo'</span></span><br><span class="line">  &#125;))</span><br><span class="line">) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>map은 {name: string, inYellowSubmarine: boolean}객체의 배열을 반환하는데, 반환된 배열은 {name: string}[]에 할당 가능하지만 inYellowSubmarine 속성에 대해 체크되지 않는다.</p>
<h3 id="assertType-사용-방법"><a href="#assertType-사용-방법" class="headerlink" title="assertType 사용 방법"></a>assertType 사용 방법</h3><p>아래 예제처럼 parameters와 ReturnType 제너릭 타입을 이용해서 함수의 매개변수 타입과 반환 타입만 분리하여 테스트한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">2</span> * x</span><br><span class="line"><span class="keyword">let</span> p: Parameters&lt;<span class="keyword">typeof</span> double&gt; = <span class="literal">null</span>!</span><br><span class="line">assertType&lt;[<span class="built_in">number</span>, <span class="built_in">number</span>]&gt;(p)</span><br><span class="line"><span class="comment">//                           ~ Argument of type '[number]' is not</span></span><br><span class="line"><span class="comment">//                             assignable to parameter of type [number, number]</span></span><br><span class="line"><span class="keyword">let</span> r: ReturnType&lt;<span class="keyword">typeof</span> double&gt; = <span class="literal">null</span>!</span><br><span class="line">assertType&lt;<span class="built_in">number</span>&gt;(r) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-53-타입스크립트-기능보다는-ECMAScript-기능을-사용하기"><a href="#아이템-53-타입스크립트-기능보다는-ECMAScript-기능을-사용하기" class="headerlink" title="아이템 53 타입스크립트 기능보다는 ECMAScript 기능을 사용하기"></a>아이템 53 타입스크립트 기능보다는 ECMAScript 기능을 사용하기</h2><p>타입스크립트 초기 버전에는 자바스크립트가 가진 결함들도 수용해야 했기 때문에 독립적으로 개발한 클래스, 열거형, 모듈 시스템을 포함시켰다. 시간이 흐르면서 부족했던 부분들을 내장 기능으로 추가하게 되었는데 <em>자바스크립트에 새로 추가된 기능은 타입스크립트 초기 버전에서 독립적으로 개발했던 기능과 호환성 문제를 발생시킨다.</em> 그래서 타입스크립트는 <strong>자바스크립트의 신규 기능을 그대로 채택하고 타입스크립트 초기 버전</strong>과 호환성을 포기하는 방법을 택했다. 그런데 이 기능과 타입스크립트 팀은 타입만 발전시킨다는 원칙이 세워지기 이전에 이미 사용되던 몇 가지 기능들이 있고, 이런 것들이 타입 공간(타입스크립트), 값 공간(자바스크립트)의 경계를 혼란스럽게 하기 때문에 사용을 지양해야 한다.</p>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/20/220221_item42to48/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/20/220221_item42to48/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 42 - 아이템 48</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-21 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-21T00:00:00+09:00">2022-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-07 16:44:50" itemprop="dateModified" datetime="2022-03-07T16:44:50+09:00">2022-03-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-42-모르는-타입의-값에는-any-대신-unknown을-사용하기"><a href="#아이템-42-모르는-타입의-값에는-any-대신-unknown을-사용하기" class="headerlink" title="아이템 42 모르는 타입의 값에는 any 대신 unknown을 사용하기"></a>아이템 42 모르는 타입의 값에는 any 대신 unknown을 사용하기</h2><h3 id="any의-특성"><a href="#any의-특성" class="headerlink" title="any의 특성"></a>any의 특성</h3><ul>
<li>어떠한 타입이든 any 타입에 할당 가능하다.</li>
<li>any 타입은 never를 제외한 어떠한 타입으로도 할당 가능하다.</li>
</ul>
<p>이러한 any의 특성은 집합 기반의 타입시스템과 상충된다. 따라서 any를 쓰면 타입 체커가 무용지물이 된다. 마치 any와 같은 역할을 하면서 타입시스템에 부합하는 타입이 바로 <code>unknown</code>이다.</p>
<h3 id="unknown의-특성"><a href="#unknown의-특성" class="headerlink" title="unknown의 특성"></a>unknown의 특성</h3><ul>
<li>어떠한 타입도 unknown에 할당 가능하다.</li>
<li>오직 unknown과 any에만 할당 가능하다.</li>
</ul>
<h3 id="never의-특성"><a href="#never의-특성" class="headerlink" title="never의 특성"></a>never의 특성</h3><ul>
<li>어떤 타입도 never에 할당 할 수 없다.</li>
<li>어떠한 타입으로도 할당 가능하다.</li>
</ul>
<hr>
<h3 id="1-unknown의-함수의-반환값과-관련된-형태"><a href="#1-unknown의-함수의-반환값과-관련된-형태" class="headerlink" title="1. unknown의 함수의 반환값과 관련된 형태"></a>1. unknown의 함수의 반환값과 관련된 형태</h3><p><em>함수의 반환타입으로 any를 쓰는 것은 좋지 않기 때문에</em> 그보다는 함수를 호출한 곳에서 반환값을 원하는 타입으로 할당하는 것이 바람직하다. 그러나 함수의 반환값에 타입 선언을 강제할 수 없기 때문에 호출한 곳에서 타입 선언을 생략하면 아래 예제를 예시로 들었을 때 1️⃣, 2️⃣처럼 book 변수가 암시적 any타입이 되고, 사용되는 곳마다 타입 오류가 발생한다. 이런 경우에 any 대신 unknown을 쓰면 훨씬 안전하다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseYAML</span>(<span class="params">yaml: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Book &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  author: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeParseYAML</span>(<span class="params">yaml: <span class="built_in">string</span></span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parseYAML(yaml)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> book = safeParseYAML(<span class="string">`</span></span><br><span class="line"><span class="string">  name: The Tenant of Wildfell Hall</span></span><br><span class="line"><span class="string">  author: Anne Brontë</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">alert(book.title)</span><br><span class="line"><span class="comment">// 1️⃣ - No error, alerts "undefined" at runtime</span></span><br><span class="line"><span class="comment">// ~~~~ Object is of type 'unknown'</span></span><br><span class="line">book(<span class="string">'read'</span>)</span><br><span class="line"><span class="comment">// No error, throws "TypeError: book is not a</span></span><br><span class="line"><span class="comment">// 2️⃣ - function" at runtime</span></span><br><span class="line"><span class="comment">// ~~~~~~~~~~ Object is of type 'unknown'</span></span><br></pre></td></tr></table></figure>
<p>하지만 unknown인 타입의 값을 사용하려고 하거나 함수 호출 또는 연산을 진행할 때 오류가 발생하기 때문에 적절한 타입으로 변환하도록 강제할 수 있다.</p>
<h3 id="2-변수선언과-관련된-unknown"><a href="#2-변수선언과-관련된-unknown" class="headerlink" title="2. 변수선언과 관련된 unknown"></a>2. 변수선언과 관련된 unknown</h3><p>어떠한 값이 있지만 그 타입을 모르는 경우에 사용한다.</p>
<hr>
<h2 id="아이템-43-몽키-패치보다는-안전한-타입을-사용하기"><a href="#아이템-43-몽키-패치보다는-안전한-타입을-사용하기" class="headerlink" title="아이템 43 몽키 패치보다는 안전한 타입을 사용하기"></a>아이템 43 몽키 패치보다는 안전한 타입을 사용하기</h2><p>몽키 패치는 프로그램이 런타임 되는 동안 사용되는 모듈이나 클래스를 변경하는 것이다. 자바스크립트는 객체와 클래스에 임의의 속성을 추가할 수 있을 만큼 유연하기 때문에 이 성질을 이용해서 전역 변수를 만들 수도 있다. 예를 들어 window나 document에 값을 할당해서 전역 변수를 만드는 것이다. 그런데 window 또는 DOM 노드에 데이터를 추가하면 그 데이터는 기본적으로 전역 변수기 때문에 프로그랢 내에서 의존성을 만들고, 사이드 이펙트를 만들 수 있다. 그리고 타입스크립트의 타입 체커는 아래와 같이 임의로 추가한 속성에 대해서 알지 못한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.monkey = <span class="string">'Tamarin'</span></span><br><span class="line"><span class="comment">// ~~~~~~ Property 'monkey' does not exist on type 'Document'</span></span><br></pre></td></tr></table></figure>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/15/220216_item35to41/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/15/220216_item35to41/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 35 - 아이템 41</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-16 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-16T00:00:00+09:00">2022-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-07 16:44:50" itemprop="dateModified" datetime="2022-03-07T16:44:50+09:00">2022-03-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-35-데이터가-아닌-API와-명세를-보고-타입-만들기"><a href="#아이템-35-데이터가-아닌-API와-명세를-보고-타입-만들기" class="headerlink" title="아이템 35 데이터가 아닌, API와 명세를 보고 타입 만들기"></a>아이템 35 데이터가 아닌, API와 명세를 보고 타입 만들기</h2><p>파일 형식, API, 명세 등 우리가 다루는 타입 중 최소한 몇 개는 프로젝트 외부에서 비롯된 것이다. <em>이런 경우 자동으로 타입 생성이 가능하다.</em> 단 중요한 포인트는 예시 데이터가 아니라 <code>명세</code>를 참고해서 타입을 생성한다는 것이다. 명세를 참고하지 않고 예시 데이터를 참고해서 타입을 작성하게 되면 눈앞에 있는 데이터만 고려하게 되므로 오류 발생을 야기하기 쉽다. 그래서 명세가 존재한다면 아래 예시처럼 이미 존재하는 타입스크립트 타입 선언을 명시해서 사용할 수 있다. 다만 이미 존재하는 타입 선언을 import해서 쓰더라도 GeometryCollection에 coordinates의 속성이 없다면 에러가 발생할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requires node modules: @types/geojson</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BoundingBox &#123;</span><br><span class="line">  lat: [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line">  lng: [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> &#123; Feature, Geometry &#125; <span class="keyword">from</span> <span class="string">'geojson'</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> f: Feature;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">coordinates: <span class="built_in">any</span>[]</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> geometryHelper = <span class="function">(<span class="params">g: Geometry</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (geometry.type === <span class="string">'GeometryCollection'</span>) &#123;</span><br><span class="line">    geometry.geometries.forEach(geometryHelper);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    helper(geometry.coordinates); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; geometry &#125; = f;</span><br><span class="line"><span class="keyword">if</span> (geometry) &#123;</span><br><span class="line">  geometryHelper(geometry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이럴 때는 아래와 같이명시적으로 해당하는 타입을 차단하는 방법을 사용할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; geometry &#125; = f;</span><br><span class="line"><span class="keyword">if</span> (geometry) &#123;</span><br><span class="line">  <span class="keyword">if</span> (geometry.type === <span class="string">'GeometryCollection'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'GeometryCollection are not supported.'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    helper(geometry.coordinates); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>하지만 명시적 타입 차단보다는 모든 타입을 지원하되 조건을 분기하여 helper함수를 지원하는 방식으로 작성해야 한다.</p>
<hr>
<h2 id="아이템-36-해당-분야의-용어로-타입-이름-짓기"><a href="#아이템-36-해당-분야의-용어로-타입-이름-짓기" class="headerlink" title="아이템 36 해당 분야의 용어로 타입 이름 짓기"></a>아이템 36 해당 분야의 용어로 타입 이름 짓기</h2><blockquote>
<p>엄선된 타입, 속성, 변수의 이름은 의도를 명확히 하고, 코드와 타입의 추상화 수준을 높여 준다.</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 속성에 대한 정보가 모호하고,</span></span><br><span class="line"><span class="comment">// 선언된 용어로 그 의미를 파악하기 어렵다.</span></span><br><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  endangered: <span class="built_in">boolean</span>;</span><br><span class="line">  habitat: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> leopard: Animal = &#123;</span><br><span class="line">  name: <span class="string">'Snow Leopard'</span>,</span><br><span class="line">  endangered: <span class="literal">false</span>,</span><br><span class="line">  habitat: <span class="string">'tundra'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//위의 코드를 전문용어를 베이스로 하여</span></span><br><span class="line"><span class="comment">//보다 분명한 의미를 나타내도록 변경하였다.</span></span><br><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  commonName: <span class="built_in">string</span>;</span><br><span class="line">  genus: <span class="built_in">string</span>;</span><br><span class="line">  species: <span class="built_in">string</span>;</span><br><span class="line">  status: ConservationStatus;</span><br><span class="line">  climates: KoppenClimate[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ConservationStatus = <span class="string">'EX'</span> | <span class="string">'EW'</span> | <span class="string">'CR'</span> | <span class="string">'EN'</span> | <span class="string">'VU'</span> | <span class="string">'NT'</span> | <span class="string">'LC'</span>;</span><br><span class="line"><span class="keyword">type</span> KoppenClimate =</span><br><span class="line">  | <span class="string">'Af'</span></span><br><span class="line">  | <span class="string">'Am'</span></span><br><span class="line">  | <span class="string">'As'</span></span><br><span class="line">  | <span class="string">'Aw'</span></span><br><span class="line">  | <span class="string">'BSh'</span></span><br><span class="line">  | <span class="string">'BSk'</span></span><br><span class="line">  | <span class="string">'BWh'</span></span><br><span class="line">  | <span class="string">'BWk'</span></span><br><span class="line">  | <span class="string">'Cfa'</span>;</span><br><span class="line"><span class="keyword">const</span> snowLeopard: Animal = &#123;</span><br><span class="line">  commonName: <span class="string">'Snow Leopard'</span>,</span><br><span class="line">  genus: <span class="string">'Panthera'</span>,</span><br><span class="line">  species: <span class="string">'Uncia'</span>,</span><br><span class="line">  status: <span class="string">'VU'</span>, <span class="comment">// vulnerable</span></span><br><span class="line">  climates: [<span class="string">'ET'</span>, <span class="string">'EF'</span>, <span class="string">'Dfd'</span>], <span class="comment">// alpine or subalpine</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>이처럼 코드로 표현하고자 하는 모든 분야에는 <strong>주제를 설명하기 위한 전문 용어들이 존재한다.</strong> 전문 용어가 있다면 자체적으로 용어를 만들어 내기 보다 전문 용어를 사용하는 것이 좋지만 잘못 사용하여 혼란을 주지 않도록 아래의 세가지를 주의하여 정확하게 사용해야 한다.</p>
<ul>
<li>동일한 의미를 나타낼 때는 같은 용어를 사용한다.</li>
<li>data, info, thing, item, object, entity와 같이 모호하고 의미없는 이름은 붙이지 않는다.</li>
<li><strong>이름을 지을 때 포함된 내용이나 계산 방식이 아닌 데이터 자체가 무엇인지를 고려한다.</strong></li>
</ul>
<hr>
<h2 id="아이템-37-공식-명칭에는-상표를-붙이기"><a href="#아이템-37-공식-명칭에는-상표를-붙이기" class="headerlink" title="아이템 37 공식 명칭에는 상표를 붙이기"></a>아이템 37 공식 명칭에는 상표를 붙이기</h2><p>타입스크립트가 가진 <em>구조적 타이핑 특성 때문에 코드가 이상한 결과를 낼 수 있다.</em> 1️⃣은 구조적 타이핑 관점에서는 문제가 없는데, 수학적으로는 2차원 벡터를 사용해야 이치에 맞다. 만약 calculateNorm 함수가 3차원 벡터를 허용하지 않게 하려면 2️⃣의 _brand처럼 <code>공식 명칭</code>을 사용한다. <strong>공식 명칭이란 상표(_brand)를 붙이는 것이다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="keyword">interface</span> Vector2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateNorm</span>(<span class="params">p: Vector2D</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(p.x * p.x + p.y * p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calculateNorm(&#123; x: <span class="number">3</span>, y: <span class="number">4</span> &#125;); <span class="comment">// OK, result is 5</span></span><br><span class="line"><span class="keyword">const</span> vec3D = &#123; x: <span class="number">3</span>, y: <span class="number">4</span>, z: <span class="number">1</span> &#125;;</span><br><span class="line">calculateNorm(vec3D); <span class="comment">// OK! result is also 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">interface</span> Vector2D &#123;</span><br><span class="line">  _brand: <span class="string">'2d'</span>;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vec2D</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; x, y, _brand: <span class="string">'2d'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateNorm</span>(<span class="params">p: Vector2D</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(p.x * p.x + p.y * p.y); <span class="comment">// Same as before</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calculateNorm(vec2D(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// OK, returns 5</span></span><br><span class="line"><span class="keyword">const</span> vec3D = &#123; x: <span class="number">3</span>, y: <span class="number">4</span>, z: <span class="number">1</span> &#125;;</span><br><span class="line">calculateNorm(vec3D);</span><br><span class="line"><span class="comment">// ~~~~~ Property '_brand' is missing in type...</span></span><br></pre></td></tr></table></figure>
<p>위 예시처럼 <code>공식명칭(_brand)</code>을 붙여두면 Vector2D함수가 Vector2D만 받는 것을 보장하게 된다. <em>이 기법은 타입 시스템 내에서 표현할 수 없는 수많은 속성들을 모델링하는 데 사용하기도 한다.</em> 아래와 같이 number 타입에 상표도 단위를 붙여서 사용하는 것처럼 숫자의 단위를 문서화하는데 사용할 수도 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Meters = <span class="built_in">number</span> &amp; &#123; _brand: <span class="string">'meters'</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> Seconds = <span class="built_in">number</span> &amp; &#123; _brand: <span class="string">'seconds'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> meters = <span class="function">(<span class="params">m: <span class="built_in">number</span></span>) =&gt;</span> m <span class="keyword">as</span> Meters;</span><br><span class="line"><span class="keyword">const</span> seconds = <span class="function">(<span class="params">s: <span class="built_in">number</span></span>) =&gt;</span> s <span class="keyword">as</span> Seconds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> oneKm = meters(<span class="number">1000</span>); <span class="comment">// Type is Meters</span></span><br><span class="line"><span class="keyword">const</span> oneMin = seconds(<span class="number">60</span>); <span class="comment">// Type is Seconds</span></span><br><span class="line"><span class="keyword">const</span> tenKm = oneKm * <span class="number">10</span>; <span class="comment">// Type is number</span></span><br><span class="line"><span class="keyword">const</span> v = oneKm / oneMin; <span class="comment">// Type is number</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-38-any-타입은-가능한-한-좁은-범위에서만-사용하기"><a href="#아이템-38-any-타입은-가능한-한-좁은-범위에서만-사용하기" class="headerlink" title="아이템 38 any 타입은 가능한 한 좁은 범위에서만 사용하기"></a>아이템 38 any 타입은 가능한 한 좁은 범위에서만 사용하기</h2><p>전통적으로 프로그래밍 언어들의 타입 시스템은 완전히 정적이거나 완전히 동적으로 구분되어 있다. 그러나 타입스크립트의 타입 시스템은 선택적이고 점진적이기 때문에 정적이면서도 동적인 특성을 동시에 가진다. 그래서 프로그램의 일부에만 타입스크립트를 적용할 수 있어 점진적 마이그레이션이 가능하다. 이 마이그레이션 단계에서 any 타입이 아주 중요한 역할을 하는데, any를 어떻게 현명하게 사용할 수 있을지 잘 고민해보아야 한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  foo: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Bar &#123;</span><br><span class="line">  bar: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">expressionReturningFoo</span>(<span class="params"></span>): <span class="title">Foo</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processBar</span>(<span class="params">b: Bar</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x: <span class="built_in">any</span> = expressionReturningFoo(); <span class="comment">// Don't do this</span></span><br><span class="line">  processBar(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = expressionReturningFoo();</span><br><span class="line">  processBar(x <span class="keyword">as</span> <span class="built_in">any</span>); <span class="comment">// Prefer this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 예제에서 x가 Foo와 Bar에 동시에 할당가능하다면 위와 같이 any를 사용한 두 가지 방법으로 해결할 수 있는데 1️⃣보다 2️⃣가 권장된다. 그 이유는 any 타입이 processBar 함수의 매개변수에만 사용된 표현식이라서 다른 코드에 영향을 미치지 않기 때문이다. 그래서 1️⃣의 x는 끝까지 any타입이고, 2️⃣에서 x는 Foo 타입을 유지한다. 1️⃣의 x가 끝까지 any 타입이기 때문에 아래와 같이 x를 반환하는 코드에서는 문제가 된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x: <span class="built_in">any</span> = expressionReturningFoo();</span><br><span class="line">  processBar(x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> foo = f1(); <span class="comment">// Type is any</span></span><br><span class="line">  foo.fooMethod(); <span class="comment">// This call is unchecked!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>객체에서 any를 사용할 때도 조심해야 하는데, 아래와 같이 오류를 발생하는 코드가 있다고 생각해본다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config: Config = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: &#123;</span><br><span class="line">    key: value,</span><br><span class="line">    <span class="comment">// ~~~ Property ... missing in type 'Bar' but required in type 'Foo'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>여기서 발생하는 오류를 해결하기 위해 아래의 두 가지 방법으로 any를 쓸 수 있다. 하지만 1️⃣처럼 사용하면 다른 속성들인 a,b의 타입도 체크되지 않는다. 따라서 2️⃣와 같이 사용하도록 한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="keyword">const</span> config: Config = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: &#123;</span><br><span class="line">    key: value,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="built_in">any</span>; <span class="comment">// Don't do this!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">const</span> config: Config = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>, <span class="comment">// These properties are still checked</span></span><br><span class="line">  c: &#123;</span><br><span class="line">    key: value <span class="keyword">as</span> <span class="built_in">any</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-39-any를-구체적으로-변형해서-사용하기"><a href="#아이템-39-any를-구체적으로-변형해서-사용하기" class="headerlink" title="아이템 39 any를 구체적으로 변형해서 사용하기"></a>아이템 39 any를 구체적으로 변형해서 사용하기</h2><ul>
<li>any는 타입의 범위가 매우 넓기 때문에 사용할 때는 정말로 모든 값이 허용되어야하만 하는지 면밀히 검토한다.</li>
<li>any보다 더 정확하게 모델링할 수 있도록 <code>any[]</code> 또는 <code>{[id:string]:any}</code>또는 <code>() =&gt; any</code>를 사용한다.</li>
<li><code>{[id:string]:any}</code>는 함수의 매개변수가 객체인데 값을 알 수 없는 경우에 쓰인다.</li>
</ul>
<hr>
<h2 id="아이템-40-함수-안으로-타입-단언문-감추기"><a href="#아이템-40-함수-안으로-타입-단언문-감추기" class="headerlink" title="아이템 40 함수 안으로 타입 단언문 감추기"></a>아이템 40 함수 안으로 타입 단언문 감추기</h2><p>프로젝트 전반에 위험한 타입 단언문이 드러나 있는 것보다 <em>제대로 타입이 정의된 함수 안으로 타입 단언문을 감추는 것이 좋다.</em></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): <span class="title">boolean</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cacheLast</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Function</span>&gt;(<span class="params">fn: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastArgs: <span class="built_in">any</span>[] | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> lastResult: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lastArgs || !shallowEqual(lastArgs, args)) &#123;</span><br><span class="line">      lastResult = fn(...args);</span><br><span class="line">      lastArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastResult;</span><br><span class="line">  &#125; <span class="keyword">as</span> unknown <span class="keyword">as</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 예제함수에서 함수 내부에는 any가 많이 보이지만 타입 정의에는 any가 없기 때문에 cacheLast를 호출하는 쪽에는 any가 사용됐는지 알 수 없다. 아래 예제에서 shallowobjectEqual은 객체를 매개변수로 하는 함수로 타입 정의는 간단하지만 구현이 복잡하다. 여기서 <code>b as any</code>로 선언할 수 있었던 것은 체크를 통해 <code>k in b</code>를 체크하였기 때문이다. 이 타입 단언문이 없다면 <code>k in b</code>가 b 객체에 k 속성이 있다는 것이 확인되었음에도 불구하고, <em>Element implicitly has an ‘any’ type because type ‘{}’ has no index signature</em> 에러가 발생한다. 이는 실제 에러가 아니기 때문에 any로 타입을 단언한 것이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): <span class="title">boolean</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowObjectEqual</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params">a: T, b: T</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [k, aVal] of <span class="built_in">Object</span>.entries(a)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(k <span class="keyword">in</span> b) || aVal !== (b <span class="keyword">as</span> <span class="built_in">any</span>)[k]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(a).length === <span class="built_in">Object</span>.keys(b).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이처럼 타입 선언문은 일반적으로 타입을 위험하게 만들지만 상황에 따라 필요하기도 하고 현실적이 해결책이 되기도 한다. 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 한다.</p>
<hr>
<h2 id="아이템-41-any의-진화를-이해하기"><a href="#아이템-41-any의-진화를-이해하기" class="headerlink" title="아이템 41 any의 진화를 이해하기"></a>아이템 41 any의 진화를 이해하기</h2><p><strong>타입스크립트에서 일반적으로 변수의 타입을 선언할 때 타입이 결정된다.</strong> null 체크 등을 통해 타입을 정제할 수는 있지만 새로운 값이 추가되도록 확장할 수 없다. 단 any 타입은 예외이다. 타입은 진화하는데 이는 타입 좁히기의 개념과 전혀 다르다.</p>
<h3 id="배열에-다양한-타입의-요소를-넣으면-배열의-타입이-확장되며-진화한다"><a href="#배열에-다양한-타입의-요소를-넣으면-배열의-타입이-확장되며-진화한다" class="headerlink" title="배열에 다양한 타입의 요소를 넣으면 배열의 타입이 확장되며 진화한다."></a>배열에 다양한 타입의 요소를 넣으면 배열의 타입이 확장되며 진화한다.</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = []; <span class="comment">// Type is any[]</span></span><br><span class="line">result.push(<span class="string">'a'</span>);</span><br><span class="line">result; <span class="comment">// Type is string[]</span></span><br><span class="line">result.push(<span class="number">1</span>);</span><br><span class="line">result; <span class="comment">// Type is (string | number)[]</span></span><br></pre></td></tr></table></figure>
<h3 id="조건문에서-분기에-따라-타입이-변한다"><a href="#조건문에서-분기에-따라-타입이-변한다" class="headerlink" title="조건문에서 분기에 따라 타입이 변한다."></a>조건문에서 분기에 따라 타입이 변한다.</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val; <span class="comment">// Type is any</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">  val = <span class="regexp">/hello/</span>;</span><br><span class="line">  val; <span class="comment">// Type is RegExp</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  val = <span class="number">12</span>;</span><br><span class="line">  val; <span class="comment">// Type is number</span></span><br><span class="line">&#125;</span><br><span class="line">val; <span class="comment">// Type is number | RegExp</span></span><br></pre></td></tr></table></figure>
<h3 id="변수의-초기값이-null일-때-진화한다"><a href="#변수의-초기값이-null일-때-진화한다" class="headerlink" title="변수의 초기값이 null일 때 진화한다."></a>변수의 초기값이 null일 때 진화한다.</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">somethingDangerous</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> val = <span class="literal">null</span>; <span class="comment">// Type is any</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  somethingDangerous();</span><br><span class="line">  val = <span class="number">12</span>;</span><br><span class="line">  val; <span class="comment">// Type is number</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">'alas!'</span>);</span><br><span class="line">&#125;</span><br><span class="line">val; <span class="comment">// Type is number | null</span></span><br></pre></td></tr></table></figure>
<h3 id="noImplicitAny가-설정된-상태에서-변수의-타입이-암시적-any이다"><a href="#noImplicitAny가-설정된-상태에서-변수의-타입이-암시적-any이다" class="headerlink" title="noImplicitAny가 설정된 상태에서 변수의 타입이 암시적 any이다."></a>noImplicitAny가 설정된 상태에서 변수의 타입이 암시적 any이다.</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val: <span class="built_in">any</span>; <span class="comment">// Type is any</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">  val = <span class="regexp">/hello/</span>;</span><br><span class="line">  val; <span class="comment">// Type is any</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  val = <span class="number">12</span>;</span><br><span class="line">  val; <span class="comment">// Type is any</span></span><br><span class="line">&#125;</span><br><span class="line">val; <span class="comment">// Type is any</span></span><br></pre></td></tr></table></figure>
<p>any타입의 진화는 암시적 any 타입에 어떤 값을 할당할 때만 발생한다. 그래서 어떤 변수가 암시적 any 상태일 때 어떠한 변수에도 할당하지 않고 값을 읽으려 하면 오류가 발생한다.</p>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/13/220214_item28to34/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/13/220214_item28to34/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 28 - 아이템 34</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-14 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-14T00:00:00+09:00">2022-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-07 16:44:50" itemprop="dateModified" datetime="2022-03-07T16:44:50+09:00">2022-03-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-28-유효한-상태만-표현하는-타입을-지향하기"><a href="#아이템-28-유효한-상태만-표현하는-타입을-지향하기" class="headerlink" title="아이템 28 유효한 상태만 표현하는 타입을 지향하기"></a>아이템 28 유효한 상태만 표현하는 타입을 지향하기</h2><blockquote>
<p>효과적으로 타입을 설계하려면 유효한 상태만 표현할 수 있는 타입을 만드는 것이 중요하다.</p>
</blockquote>
<h3 id="유효하지-않은-상태"><a href="#유효하지-않은-상태" class="headerlink" title="유효하지 않은 상태"></a>유효하지 않은 상태</h3><ul>
<li>A,B가 있다고 했을 때, 상태 값의 두 가지 속성이 동시에 정보가 부족하다. (A가 성공인지 실패인지 알 수 없다.)</li>
<li>A,B의 두 가지 속성이 충돌한다. (A이면서 B인 상태가 있다.)</li>
</ul>
<p>이런 무효한 상태가 존재하면 두 가지 모두를 제대로 구현할 수 없게 된다. 유효한 상태를 구현하려면 아래와 같이 명시적으로 모델링하는 <code>태그된 유니온(또는 구별된 유니온)</code>을 사용해서 나타낸다. 이렇게 작성하면 코드가 길어지고 작성하기 어렵지만 무효한 상태를 허용하지 않도록 개선할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> RequestPending &#123;</span><br><span class="line">  state: <span class="string">'pending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> RequestError &#123;</span><br><span class="line">  state: <span class="string">'error'</span>;</span><br><span class="line">  error: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> RequestSuccess &#123;</span><br><span class="line">  state: <span class="string">'ok'</span>;</span><br><span class="line">  pageText: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RequestState = RequestPending | RequestError | RequestSuccess;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">  currentPage: <span class="built_in">string</span>;</span><br><span class="line">  requests: &#123; [page: <span class="built_in">string</span>]: RequestState &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>타입을 설계할 때 어떤 값들을 포함하고, 어떤 값들을 제외할지 신중하게 생각하도록 한다. 유효한 상태를 표현하는 값만 허용하면 코드를 작성하기 쉬워지고 타입 체크가 용이해진다.</p>
<hr>
<h2 id="아이템-29-사용할-때는-너그럽게-생성할-때는-엄격하게"><a href="#아이템-29-사용할-때는-너그럽게-생성할-때는-엄격하게" class="headerlink" title="아이템 29 사용할 때는 너그럽게, 생성할 때는 엄격하게"></a>아이템 29 사용할 때는 너그럽게, 생성할 때는 엄격하게</h2><p>함수의 시그니처는 <code>당신의 작업은 엄격하게, 다른 사랆의 작업은 너그럽게 받아들인다</code>는 일반적인 원칙을 따라야 한다. 즉 함수의 매개변수는 타입의 범위가 넓어도 되지만 결과를 반환할 때는 타입의 범위가 더 구체적이어야 한다.</p>
<ul>
<li>viewportForBounds의 타입의 선언이 만들어지고 사용될 때처럼 너무 자유로우면 오류가 발생하기 쉽다.</li>
<li>너무 자유롭다는 것은 수많은 선택적 속성(?)을 가지는 반환 타입을 가지고 있거나 유니온 타입을 사용하는 경우를 말한다.</li>
<li>유니온 타입의 요소별 분기를 위한 방법: 좌표를 위한 기본 형식을 구분한다.<ul>
<li>e.g. 배열과 배열 같은 것: LngLat, LngLatLike</li>
</ul>
</li>
<li>완전하게 정의된 버전과 부분적으로 정의된 부분을 구분한다.<ul>
<li>완전하게 정의된 버전: Camera</li>
<li>부분적으로 정의된 버전: Camera option</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Feature = <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">calculateBoundingBox</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  f: Feature</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">number</span>, <span class="title">number</span>, <span class="title">number</span>, <span class="title">number</span>]</span>;</span><br><span class="line"><span class="keyword">interface</span> LngLat &#123;</span><br><span class="line">  lng: <span class="built_in">number</span>;</span><br><span class="line">  lat: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LngLatLike = LngLat | &#123; lon: <span class="built_in">number</span>; lat: <span class="built_in">number</span> &#125; | [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Camera &#123;</span><br><span class="line">  center: LngLat;</span><br><span class="line">  zoom: <span class="built_in">number</span>;</span><br><span class="line">  bearing: <span class="built_in">number</span>;</span><br><span class="line">  pitch: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> CameraOptions <span class="keyword">extends</span> Omit&lt;Partial&lt;Camera&gt;, 'center'&gt; &#123;</span><br><span class="line">  center?: LngLatLike;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LngLatBounds =</span><br><span class="line">  | &#123; northeast: LngLatLike; southwest: LngLatLike &#125;</span><br><span class="line">  | [LngLatLike, LngLatLike]</span><br><span class="line">  | [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">setCamera</span>(<span class="params">camera: CameraOptions</span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">viewportForBounds</span>(<span class="params">bounds: LngLatBounds</span>): <span class="title">Camera</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">focusOnFeature</span>(<span class="params">f: Feature</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bounds = calculateBoundingBox(f);</span><br><span class="line">  <span class="keyword">const</span> camera = viewportForBounds(bounds);</span><br><span class="line">  setCamera(camera);</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    center: &#123; lat, lng &#125;,</span><br><span class="line">    zoom,</span><br><span class="line">  &#125; = camera; <span class="comment">// OK</span></span><br><span class="line">  zoom; <span class="comment">// Type is number</span></span><br><span class="line">  <span class="built_in">window</span>.location.search = <span class="string">`?v=@<span class="subst">$&#123;lat&#125;</span>,<span class="subst">$&#123;lng&#125;</span>z<span class="subst">$&#123;zoom&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-30-문서에-타입-정보를-쓰지-않기"><a href="#아이템-30-문서에-타입-정보를-쓰지-않기" class="headerlink" title="아이템 30 문서에 타입 정보를 쓰지 않기"></a>아이템 30 문서에 타입 정보를 쓰지 않기</h2><p>코드에 대한 정보가 주석으로 남아있을 때 그 주석의 정보와 코드가 맞이 않을 때가 있다. 타입스크립트의 타입 구문 시스템은 간결하고 구체적이며, 쉽게 읽을 수 있도록 설계되었기 때문에 코드에 대한 설명 및 타입 정보를 주석으로 남기기 보다 타입스크립트의 타입 구문을 사용하도록 한다. <em>타입 구문은 타입스크립트 컴파일러가 체크해 주기 때문에 구현체와의 정합성이 어긋나지도 않는다.</em> 또 주석은 누군가 고치기 전에 강제로 동기화 되지 않는다. 타입스크립트는 타입 체커가 타입 정보를 동기화하도록 강제한다.</p>
<p>타입스크립트는 명시적으로 사용하는 것이 좋다. ageNum이라는 변수를 선언하는 것보다 age로 변수 선언 후 타입은 num임을 명시하는 것이 더 좋다. 단 단위가 있는 숫자들은 단위가 무엇인지 확실하지 않다면 변수명 또는 속성 이름에 단위를 포한한다. 예를 들어 temperature보다 temperatureC가 훨씬 명확하다.</p>
<hr>
<h2 id="아이템-31-타입-주변에-null-값-배치하기"><a href="#아이템-31-타입-주변에-null-값-배치하기" class="headerlink" title="아이템 31 타입 주변에 null 값 배치하기"></a>아이템 31 타입 주변에 null 값 배치하기</h2><p>어떤 변수가 null인지 아닌지를 분명히 해야한다. null과 null이 아닌 값을 섞어서 사용하면 문제가 생긴다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extent</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> min, max;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num of nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!min) &#123;</span><br><span class="line">      min = num;</span><br><span class="line">      max = num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      min = <span class="built_in">Math</span>.min(min, num);</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, num);</span><br><span class="line">      <span class="comment">// ~~~ Argument of type 'number | undefined' is not</span></span><br><span class="line">      <span class="comment">//     assignable to parameter of type 'number'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [min, max];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [min, max] = extent([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">const</span> span = max - min;</span><br><span class="line"><span class="comment">// ~~~   ~~~ Object is possibly 'undefined'</span></span><br></pre></td></tr></table></figure>
<p>위 예제에서 extent의 반환값이 (number | undefined)[]로 추론된다. 이렇게 되면 extent를 호출하는 곳마다 타입 오류의 형태로 나타난다. 더 나은 해법으로는 min, max를 한 객체 안에 넣고 null이거나 null이 아니게 하는 아래와 같은 방법으로 작성한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extent</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: [<span class="built_in">number</span>, <span class="built_in">number</span>] | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num of nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">      result = [num, num];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = [<span class="built_in">Math</span>.min(num, result[<span class="number">0</span>]), <span class="built_in">Math</span>.max(num, result[<span class="number">1</span>])];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TL;DR</p>
<ul>
<li>한 값의 null 여부가 다른 값의 null 여부에 암시적으로 관련되도록 설계하면 안된다.</li>
<li>API 작성 시에는 반환 타입을 큰 객체로 만들고 반환 타입 전체가 null이거나 null이 아니게 만들어야 한다.</li>
<li>클래스를 만들 때는 필요한 모든 값이 준비되었을 때 생성하여 null이 존재하지 않도록 한다.</li>
<li>strictNullChecks를 설정하면 코드에 많은 오류가 표시되갰지만, null 값과 관련된 문제점을 찾아낼 수 있기 때문에 반드시 필요하다.</li>
</ul>
<hr>
<h2 id="아이템-32-유니온의-인터페이스보다는-인터페이스의-유니온을-사용하기"><a href="#아이템-32-유니온의-인터페이스보다는-인터페이스의-유니온을-사용하기" class="headerlink" title="아이템 32 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기"></a>아이템 32 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기</h2><p>유니온 타입의 속성을 가지는 인터페이스를 작성 중이라면, 인터페이스의 유니온 타입을 사용하는 게 더 알맞지 않을지 검토해보아야 한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Layer &#123;</span><br><span class="line">  layout: FillLayout | LineLayout | PointLayout;</span><br><span class="line">  paint: FillPaint | LinePaint | PointPaint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 예제는 벡터를 그리는 프로그램을 작성 중이고, 특정한 기하학적 타입을 가지는 계층의 인터페이스를 정의한다고 가정하는 코드이다. 그런데 이 코드에서 layout이 LineLayout(직선)이면서 paint 속성이 FillPaint타입이 되는 조합은 성립하지 않는다. 그런데 위의 코드는 그런 조합을 허용하는 코드이기 때문에 오류가 발생하기 쉽다. 이런 상황에서는 layout과 paint 속성이 지금처럼 잘못된 조합으로 섞이지 않도록 아래와 같이 <strong>각각 타입의 계층을 분리된 인터페이스로 작성하도록 한다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> FillLayer &#123;</span><br><span class="line">  layout: FillLayout;</span><br><span class="line">  paint: FillPaint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> LineLayer &#123;</span><br><span class="line">  layout: LineLayout;</span><br><span class="line">  paint: LinePaint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> PointLayer &#123;</span><br><span class="line">  layout: PointLayout;</span><br><span class="line">  paint: PointPaint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Layer = FillLayer | LineLayer | PointLayer;</span><br></pre></td></tr></table></figure>
<p>이렇게 작성하면 유효한 상태만을 표현하게 된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Layer &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'fill'</span> | <span class="string">'line'</span> | <span class="string">'point'</span>;</span><br><span class="line">  layout: FillLayout | LineLayout | PointLayout;</span><br><span class="line">  paint: FillPaint | LinePaint | PointPaint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같은 태그된 유니온에서도 유효하지 못한 상태가 섞이는 문제가 발생한다. 태그된 유니온은 여러개의 타입을 유니온으로 선언할 때 각 타입에 태그가 있어서 이것으로 구분하는 것을 말한다. 여기서 Layer 속성 중 하나는 문자열 타입의 유니온인데, 이 역시 type: ‘fill’일 때 LineLayout과 PointPaint 타입이 함께 쓰이는 것은 유효하지 않다. 그래서 아래와 같이 Layer의 인터페이스를 유니온으로 변환하는 방식으로 개선할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> FillLayer &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'fill'</span>;</span><br><span class="line">  layout: FillLayout;</span><br><span class="line">  paint: FillPaint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> LineLayer &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'line'</span>;</span><br><span class="line">  layout: LineLayout;</span><br><span class="line">  paint: LinePaint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> PointLayer &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'paint'</span>;</span><br><span class="line">  layout: PointLayout;</span><br><span class="line">  paint: PointPaint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Layer = FillLayer | LineLayer | PointLayer;</span><br></pre></td></tr></table></figure>
<p>이와 같이 어떤 데이터 타입을 <code>태그된 유니온</code>으로 표현할 수 있다면 그렇게 하는 것이 좋다. 특히 여러 개의 선택적 필드가 동시에 값이 있거나 동시에 undefined일 때 이 패턴이 적절하다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// These will either both be present or not be present</span></span><br><span class="line">  placeOfBirth?: <span class="built_in">string</span>;</span><br><span class="line">  dateOfBirth?: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 주석으로 타입에 대한 정보를 남기 코드가 있다고 했을 때, 이 타입 정보는 placeOfBirth와 dateOfBirth의 관계가 정확하게 표현되어 있지 않다. 이런 경우에는 아래와 같이 타입의 구조를 변경하여 <strong>두 개의 속성을 하나의 객체로 모으는 것이 더 나은 설계이다. 이는 null 값을 경계로 두는 아이템 31의 방법과 비슷하다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  birth?: &#123;</span><br><span class="line">    place: <span class="built_in">string</span>;</span><br><span class="line">    date: <span class="built_in">Date</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>하지만 타입의 구조를 손 댈 수 없는 경우라면(e.g.API response) 아래와 같이 <strong>인터페이스의 유니온을 사용해서 속성 사이의 관계를 모델링한다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  birth?: &#123;</span><br><span class="line">    place: <span class="built_in">string</span>;</span><br><span class="line">    date: <span class="built_in">Date</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PersonWithBirth <span class="keyword">extends</span> Name &#123;</span><br><span class="line">  placeOfBirth: <span class="built_in">string</span>;</span><br><span class="line">  dateOfBirth: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person = Name | PersonWithBirth;</span><br></pre></td></tr></table></figure>
<p>TL;DR</p>
<ul>
<li>유니온 타입의 속성을 여러 개 가지는 인터페이스에서는 속성 간의 관계가 분명하지 않기 때문에 실수가 자주 발생하므로 주의하도록 한다.</li>
<li>유니온의 인터페이스보다 인터페이스의 유니온이 더 정확하고 타입스크립트가 이해하기 좋다.</li>
<li>타입스크립트가 제어된 흐름을 분석할 수 있도록 타입에 태그를 넣는 것을 고려하도록 한다. 태그된 유니온은 타입스트립트와 매우 잘 맞아서 자주 볼 수 있는 패턴이다.</li>
</ul>
<hr>
<h2 id="아이템-33-string-타입보다-더-구체적인-타입-사용하기"><a href="#아이템-33-string-타입보다-더-구체적인-타입-사용하기" class="headerlink" title="아이템 33 string 타입보다 더 구체적인 타입 사용하기"></a>아이템 33 string 타입보다 더 구체적인 타입 사용하기</h2><p>string 타입의 범위는 매우 넓어서 ‘x’와 같은 한 글자와 , ‘call me ishmael….’로 시작하는 모비딕의 전체 내용과 같이 긴 텍스트도 string 타입이다. <strong>그러므로 타입으로 변수를 선언 할 때, 더 좁은 타입이 적절하지 않을 지 검토해보아야 한다.</strong> string은 any와 비슷한 문제를 가지고 있어서 잘못 사용하면 무효한 값을 허용하고, 타입 간의 관계를 감추어 버리기 때문이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Album &#123;</span><br><span class="line">  artist: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  releaseDate: <span class="built_in">string</span>; <span class="comment">// YYYY-MM-DD</span></span><br><span class="line">  recordingType: <span class="built_in">string</span>; <span class="comment">// E.g., "live" or "studio"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> kindOfBlue: Album = &#123;</span><br><span class="line">  artist: <span class="string">'Miles Davis'</span>,</span><br><span class="line">  title: <span class="string">'Kind of Blue'</span>,</span><br><span class="line">  releaseDate: <span class="string">'August 17th, 1959'</span>, <span class="comment">// Oops!</span></span><br><span class="line">  recordingType: <span class="string">'Studio'</span>, <span class="comment">// Oops!</span></span><br><span class="line">&#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>위의 Album은 string이 남발되어 타입이 모델링 되었다.(stringly typed) 이 경우 releaseDate, recordinType이 Album에 정의된 주석과 다른 형태로 모델링되었지만 string이기 때문에 타입 체커를 통과한다. 아래와 같이 함수 호출시 매개변수의 순서가 바뀐 경우에도 둘 다 문자열이기 때문에 타입 체커를 통과한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recordRelease</span>(<span class="params">title: <span class="built_in">string</span>, date: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line">recordRelease(kindOfBlue.releaseDate, kindOfBlue.title); <span class="comment">// OK, should be error</span></span><br></pre></td></tr></table></figure>
<p>이런 경우 아래와 같이 타입을 좁히는 방식으로 개선할 수 있다. releaseDate는 날짜형식으로 제한하고, recordingType은 두 개의 값을 가진 유니온 타입으로 정의할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RecordingType = <span class="string">'studio'</span> | <span class="string">'live'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Album &#123;</span><br><span class="line">  artist: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  releaseDate: <span class="built_in">Date</span>;</span><br><span class="line">  recordingType: RecordingType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이렇게 작성하면 앞서 오류가 발생할 상황에서도 타입체커를 통과했던 것과 다르게 타입스크립트가 타입 체커를 세밀하게 체크할 수 있어서 타입 오류를 잘 검사하게 된다.</p>
<h3 id="string-타입-좁히기의-장점"><a href="#string-타입-좁히기의-장점" class="headerlink" title="string 타입 좁히기의 장점"></a>string 타입 좁히기의 장점</h3><ul>
<li>타입을 명시적으로 정의하여 다른 곳으로 값이 전달되어도 타입 정보가 유지된다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//recordingType 매개변수에 대한 타입을 RecordingType과 같이 사용하면 편집기에서 자동완성을 통해 타입에 대한 설명을 확인할 수 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAlbumsOfType</span>(<span class="params">recordingType: RecordingType</span>): <span class="title">Album</span>[] </span>&#123;</span><br><span class="line">  <span class="comment">// COMPRESS</span></span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">  <span class="comment">// END</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>타입을 명시적으로 정의히고, 해당 타입의 의미를 설명하는 주석을 함께 쓸 수 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** What type of environment was this recording made in?  */</span></span><br><span class="line"><span class="keyword">type</span> RecordingType = <span class="string">'live'</span> | <span class="string">'studio'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>keyof 연산자로 더욱 세밀하게 객체의 속성 체크가 가능하다.<ul>
<li><ol>
<li>underscore 라이브러리의 pluck함수의 시그니처를 작성한다.</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>(<span class="params">record: <span class="built_in">any</span>[], key: <span class="built_in">string</span></span>): <span class="title">any</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> record.map(<span class="function">(<span class="params">r</span>) =&gt;</span> r[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.타입 체크가 되지만 정밀하지 못하다. 반환값에 any를 쓰는 것도 바람직 하지 않다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//제너릭 타입을 도입하여 개선한다.하지만 매개변수가 string이므로 오류를 발생시킨다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>&gt;(<span class="params">record: T[], key: <span class="built_in">string</span></span>): <span class="title">any</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> record.map(<span class="function">(<span class="params">r</span>) =&gt;</span> r[key]);</span><br><span class="line">  <span class="comment">// ~~~~~~ Element implicitly has an 'any' type</span></span><br><span class="line">  <span class="comment">//        because type '&#123;&#125;' has no index signature</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.매개변수로 Album의 배열을 전달했기 때문에 string이었던 타입이 type k와 같이 좁혀졌다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RecordingType = <span class="string">'studio'</span> | <span class="string">'live'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Album &#123;</span><br><span class="line">  artist: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  releaseDate: <span class="built_in">Date</span>;</span><br><span class="line">  recordingType: RecordingType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> K = keyof Album;</span><br><span class="line"><span class="comment">// Type is "artist" | "title" | "releaseDate" | "recordingType"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>&gt;(<span class="params">record: T[], key: keyof T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> record.map(<span class="function">(<span class="params">r</span>) =&gt;</span> r[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>keyof T의 부분 집합(아마도 단일값)으로 두 번째 제너릭 매개변수를 도입한다.</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T[key of]T는 T 객체 내에 가능한 모든 값의 타입이라서 string보다는 범위가 좁지만 여전히 넓다.</span></span><br><span class="line"><span class="comment">//또 key에 문자열 하나를 넣게 되면 그에 비해 범위는 너무 넓어서 적절하지 않다.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> albums: Album[];</span><br><span class="line"><span class="keyword">const</span> releaseDates = pluck(albums, <span class="string">'releaseDate'</span>); <span class="comment">// Type is (string | Date)[]</span></span><br></pre></td></tr></table></figure>
<p>아래와 같이 두 번째 제너릭 매개변수를 도입한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">record: T[], key: K</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> record.map(<span class="function">(<span class="params">r</span>) =&gt;</span> r[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-34-부정확한-타입보다는-미완성-타입을-사용하기"><a href="#아이템-34-부정확한-타입보다는-미완성-타입을-사용하기" class="headerlink" title="아이템 34 부정확한 타입보다는 미완성 타입을 사용하기"></a>아이템 34 부정확한 타입보다는 미완성 타입을 사용하기</h2><p>타입이 구체적일수록 버그를 더 잘 잡고, 타입스크립트가 제공하는 도구를 활용할 수 있는데, <em>잘못된 타입은 차라리 타입이 없는 것만 못하기 때문에 주의를 기울여야 한다.</em></p>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/09/220210_item21to27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/09/220210_item21to27/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 21 - 아이템 27</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-10 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-10T00:00:00+09:00">2022-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-07 16:44:50" itemprop="dateModified" datetime="2022-03-07T16:44:50+09:00">2022-03-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-21-타입-넓히기"><a href="#아이템-21-타입-넓히기" class="headerlink" title="아이템 21 타입 넓히기"></a>아이템 21 타입 넓히기</h2><p>런타임에 모든 변수는 유일한 <code>값</code>을 가지고, 타입스크립트가 코드를 체크하는 정적 분석 시점에 변수는 가능한 값들의 집합인 <code>타입</code>을 가진다. 그래서 상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커가 타입을 결정해야 한다. <em>즉 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다.</em>는 뜻이다. 그리고 이를 <code>넓히기(widening)</code>라고 부른다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixed = [<span class="string">'x'</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//추론 가능한 타입</span></span><br><span class="line">(<span class="string">'x'</span> | <span class="number">1</span>)[]</span><br><span class="line">[<span class="string">'x'</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line">(<span class="built_in">string</span>|<span class="built_in">number</span>)[]</span><br><span class="line"></span><br><span class="line"><span class="comment">//생략</span></span><br></pre></td></tr></table></figure>
<p>위 예제에서 mixed는 추론 가능한 타입이 여러개이다. 만약 mixed에 대한 타입이 충분하지 않다면 어떤 타입으로 추론되어야 하는지 할 수 없어서 타입스크립트는 작성자의 의도를 추측한다.</p>
<h3 id="넓히기-과정을-제어하는-방법"><a href="#넓히기-과정을-제어하는-방법" class="headerlink" title="넓히기 과정을 제어하는 방법"></a>넓히기 과정을 제어하는 방법</h3><ul>
<li>const의 사용 : let 대신 const로 변수를 선언한다. const는 재할당이 불가하기 때문에 타입스크립트가 추론 가능한 타입이 여러개여서 모호한 과정에 빠지지 않는다. 다만 객체와 배열의 경우 const를 써도 문제가 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v = &#123;</span><br><span class="line">  x: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">v.x = <span class="number">3</span> <span class="comment">// OK</span></span><br><span class="line">v.x = <span class="string">'3'</span></span><br><span class="line"><span class="comment">// ~ Type '"3"' is not assignable to type 'number'</span></span><br><span class="line">v.y = <span class="number">4</span></span><br><span class="line"><span class="comment">// ~ Property 'y' does not exist on type '&#123; x: number; &#125;'</span></span><br><span class="line">v.name = <span class="string">'Pythagoras'</span></span><br><span class="line"><span class="comment">// ~~~~ Property 'name' does not exist on type '&#123; x: number; &#125;'</span></span><br></pre></td></tr></table></figure>
<p><strong>타입스크립트는 명확성과 유연성 사이의 균형을 유지하려고 한다.</strong> 그래서 구체적으로 타입을 추론해야 하지만, 잘못된 추론을 할 정도로 구체적으로 수행하진 않는다. 만약 타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의한다.</p>
<h3 id="타입스크립트의-기본-동작-제어방법"><a href="#타입스크립트의-기본-동작-제어방법" class="headerlink" title="타입스크립트의 기본 동작 제어방법"></a>타입스크립트의 기본 동작 제어방법</h3><ul>
<li>명시적 타입 구문 제공</li>
<li>타입 체커에 추가적인 문맥 제공</li>
<li>const 단언만 사용<ul>
<li>이 const는 변수 선언에 쓰이는 const와 가른 것이므로 헷갈려서는 안된다. <em>const 단언문은 온전히 타입 공간의 기법이다.</em></li>
<li>아래 예제에서 값 뒤에 <code>as const</code>를 작성하면 최대한 좁은 타입으로 추론하기 때문에 v3에서 넓히기가 동작하지 않는다.</li>
<li>배열을 튜플로 추론할 때도 <code>as const</code>를 쓸 수 있다.</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Vector3 &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">  z: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params">vector: Vector3, axis: 'x' | 'y' | 'z'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> vector[axis]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span></span><br><span class="line">&#125; <span class="comment">// Type is &#123; x: number; y: number; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">  x: <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">const</span>,</span><br><span class="line">  y: <span class="number">2</span></span><br><span class="line">&#125; <span class="comment">// Type is &#123; x: 1; y: number; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v3 = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span> <span class="comment">// Type is &#123; readonly x: 1; readonly y: 2; &#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-22-타입-좁히기"><a href="#아이템-22-타입-좁히기" class="headerlink" title="아이템 22 타입 좁히기"></a>아이템 22 타입 좁히기</h2><p><code>타입 넓히기의 반대개념이다.</code> 타입스크립트가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말한다.</p>
<ul>
<li>null 체크</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>) <span class="comment">// Type is HTMLElement | null</span></span><br><span class="line"><span class="keyword">if</span> (el) &#123;</span><br><span class="line">  el <span class="comment">// Type is HTMLElement</span></span><br><span class="line">  el.innerHTML = <span class="string">'Party Time'</span>.blink()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  el <span class="comment">// Type is null</span></span><br><span class="line">  alert(<span class="string">'No element #foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>) <span class="comment">// Type is HTMLElement | null</span></span><br><span class="line"><span class="keyword">if</span> (!el) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unable to find #foo'</span>)</span><br><span class="line">el <span class="comment">// Now type is HTMLElement</span></span><br><span class="line">el.innerHTML = <span class="string">'Party Time'</span>.blink()</span><br></pre></td></tr></table></figure>
<p>위 예시에서 1️⃣의 el이 null이면 첫번 째 블록의 <em>const el = document.getElementById(‘foo’); // Type is HTMLElement | null</em> 을 실행하지 않기 때문에 <em>Type is HTMLElement | null</em>에서 null을 제외하므로 더 좁은 타입이 된다. 2️⃣와 같이 분기문에서 예외를 던지거나 함수를 반환해서 블록의 나머지 부분에서 변수의 타입을 좁힐 수도 있다.</p>
<ul>
<li>instanceof사용</li>
<li>속성 체크</li>
<li>Array.isArray 사용</li>
<li>조건문 사용</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>) <span class="comment">// type is HTMLElement | null</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> el === <span class="string">'object'</span>) &#123;</span><br><span class="line">  el <span class="comment">// Type is HTMLElement | null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>조건문이 가장 타입을 좁히는 데 능숙한 방법이지만 위와 같은 예제처럼 실수를 일으키기 쉽다. 위 예제에서 <code>typeof null은 object</code>이기 때문에 if문에서 null이 제외되지 않는다. 다음과 같은 기본형에서도 기본형 값이 잘못되어도 제대로 좁혀지지 않는다. 빈 문자열 ‘’와 0 모두 false가 되기 때문에 좁혀지지 않는다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x?: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">    x <span class="comment">// Type is string | number | null | undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>명시적 태그를 붙이기 (태그된 유니온 또는 구별된 유니온</li>
<li>사용자 정의 타입 가드 사용: 타입스크립트가 타입을 식별하지 못할 때 커스텀 함수를 도입할 수 있다.</li>
<li>타입 가드 사용</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jackson5 = [<span class="string">'Jackie'</span>, <span class="string">'Tito'</span>, <span class="string">'Jermaine'</span>, <span class="string">'Marlon'</span>, <span class="string">'Michael'</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDefined</span>&lt;<span class="title">T</span>&gt;(<span class="params">x: T | <span class="literal">undefined</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> members = [<span class="string">'Janet'</span>, <span class="string">'Michael'</span>]</span><br><span class="line">  .map(<span class="function"><span class="params">who</span> =&gt;</span> jackson5.find(<span class="function"><span class="params">n</span> =&gt;</span> n === who))</span><br><span class="line">  .filter(isDefined) <span class="comment">// Type is string[]</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-23-한꺼번에-객체-생성하기"><a href="#아이템-23-한꺼번에-객체-생성하기" class="headerlink" title="아이템 23 한꺼번에 객체 생성하기"></a>아이템 23 한꺼번에 객체 생성하기</h2><blockquote>
<p>타입스크립트의 타입은 변경되지 않기 때문에 객체를 생성할 때는 속성을 하나씩 추가하는 것 보다 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//에러 발생</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123;&#125;</span><br><span class="line">pt.x = <span class="number">3</span></span><br><span class="line"><span class="comment">// ~ Property 'x' does not exist on type '&#123;&#125;'</span></span><br><span class="line">pt.y = <span class="number">4</span></span><br><span class="line"><span class="comment">// ~ Property 'y' does not exist on type '&#123;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//에러 발생</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pt: Point = &#123;&#125;</span><br><span class="line"><span class="comment">// ~~ Type '&#123;&#125;' is missing the following properties from type 'Point': x, y</span></span><br><span class="line">pt.x = <span class="number">3</span></span><br><span class="line">pt.y = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//통과 - 객체 한꺼번에 생성</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pt = &#123;</span><br><span class="line">  x: <span class="number">3</span>,</span><br><span class="line">  y: <span class="number">4</span></span><br><span class="line">&#125; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>객체를 반드시 제각각 나눠서 만들어야 한다면 <code>타입 단언문(as)</code>를 사용한다. 그러나 객체를 한꺼번에 만드는 것이 더욱 권장된다. 작은 객체들을 조합해서 큰 객체를 만들어야 할 때는 <code>전개 연산자</code>를 사용해서 객체를 한꺼번에 만든다. 이렇게 하면 타입 걱정 없이 필드 단위로 객체를 생성할 수 있는데 이때 중요한 점은 <strong>모든 업데이트마다 새 변수를 사용하여 새로운 타입을 얻도록 하는 것이다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//전개 연산자 사용</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pt = &#123; x: <span class="number">3</span>, y: <span class="number">4</span> &#125;</span><br><span class="line"><span class="keyword">const</span> id = &#123; name: <span class="string">'Pythagoras'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> namedPoint = &#123; ...pt, ...id &#125;</span><br><span class="line">namedPoint.name <span class="comment">// OK, type is string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//전개 연산자를 사용할 때 모든 업데이트 시</span></span><br><span class="line"><span class="comment">//새 변수를 사용하여 새로운 타입을 얻도록 한다.</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pt0 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> pt1 = &#123; ...pt0, x: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">const</span> pt: Point = &#123; ...pt1, y: <span class="number">4</span> &#125; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>타입에 안전한 방식으로 조건부 속성을 추가하려면 속성을 추가하지 않는 null 또는 {}로 객체 전개를 사용한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ 조건부 속성의 추가 - &#123;&#125;</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> hasMiddle: <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">const</span> firstLast = &#123; first: <span class="string">'Harry'</span>, last: <span class="string">'Truman'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> president = &#123; ...firstLast, ...(hasMiddle ? &#123; middle: <span class="string">'S'</span> &#125; : &#123;&#125;) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣전개 연산자로 한꺼번에 여러 속성을 추가한다.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> hasDates: <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">const</span> nameTitle = &#123; first: <span class="string">'Harry'</span>, last: <span class="string">'Truman'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> pharaoh = &#123;</span><br><span class="line">  ...nameTitle,</span><br><span class="line">  ...(hasDates ? &#123; start: <span class="number">-289</span>, end: <span class="number">-22</span> &#125; : &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2️⃣의 타입은 <code>유니온</code>으로 추론된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pharaoh:</span><br><span class="line">   &#123;</span><br><span class="line">      start: number;</span><br><span class="line">      end: number;</span><br><span class="line">      name: string;</span><br><span class="line">      title: string;</span><br><span class="line">    &#125;</span><br><span class="line">  | &#123; <span class="attr">name</span>: string; title: string &#125;;</span><br></pre></td></tr></table></figure>
<p>이 경우 pharaoh.start로 접근하면 start와 end는 항상 함께 정의되기 때문에 속성이 없다는 에러가 표시된다. <strong>따라서 유니온을 사용하는 것이 가능한 값의 집합을 더 정확히 표현하는 것이다.</strong> 다만 유니온보다 선택적 필드가 다루기에 더 쉬울 수 있다. 아래와 같이 헬퍼 함수를 사용해서 표현한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> hasMiddle: <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">const</span> firstLast = &#123; first: <span class="string">'Harry'</span>, last: <span class="string">'Truman'</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOptional</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">U</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  a: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  b: U | <span class="literal">null</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">T</span> &amp; <span class="title">Partial</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...a, ...b &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> president = addOptional(firstLast, hasMiddle ? &#123; middle: <span class="string">'S'</span> &#125; : <span class="literal">null</span>)</span><br><span class="line">president.middle <span class="comment">// OK, type is string | undefined</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-24-일관성-있는-별칭-사용하기"><a href="#아이템-24-일관성-있는-별칭-사용하기" class="headerlink" title="아이템 24 일관성 있는 별칭 사용하기"></a>아이템 24 일관성 있는 별칭 사용하기</h2><p>별칭의 값을 변경하면 원래 속성값에서도 변경된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> borough = &#123; name: <span class="string">'Brooklyn'</span>, location: [<span class="number">40.688</span>, <span class="number">-73.979</span>] &#125;</span><br><span class="line"><span class="keyword">const</span> loc = borough.location</span><br><span class="line"></span><br><span class="line">loc[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">borough.location <span class="comment">// [0, -73.979]</span></span><br></pre></td></tr></table></figure>
<p>이렇게 별칭을 사용할 때 남발해서 사용하면 제어 흐름을 분석하기 어렵다. 제어 흐름을 분석하기 어려워서 오류가 발생할 수 있는데, <code>별칭은 일관성있게 사용한다</code>는 기본 원칙을 지키면 오류를 방지할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Coordinate &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BoundingBox &#123;</span><br><span class="line">  x: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">  y: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Polygon &#123;</span><br><span class="line">  exterior: Coordinate[]</span><br><span class="line">  holes: Coordinate[][]</span><br><span class="line">  bbox?: BoundingBox</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//객체 비구조화 사용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPointInPolygon</span>(<span class="params">polygon: Polygon, pt: Coordinate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; bbox &#125; = polygon</span><br><span class="line">  <span class="keyword">if</span> (bbox) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = bbox</span><br><span class="line">    <span class="keyword">if</span> (pt.x &lt; x[<span class="number">0</span>] || pt.x &gt; x[<span class="number">1</span>] || pt.y &lt; x[<span class="number">0</span>] || pt.y &gt; y[<span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>위와 같이 별칭 대신 객체 비구조화를 사용해서 일관된 이름을 사용할 수 있는데,</strong> 배열과 중첩된 구조에서도 사용 가능하다. 다만 아래의 두 가지 문제를 주의한다.</p>
<ul>
<li>전체 bbox 속성이 아니라 x와 y가 선택적 속성일 경우 속성 체크가 더 필요하다. 따라서 타입의 경계에 null 값을 추가하는 것이 좋다.</li>
<li>bbox에는 선택적 속성이 적합했지만 holes에는 그렇지 않다. holes가 선택적이라면 값이 없거나 빈 배열이었을 것이다. 차이가 없는데 이름을 구별한 것이다. 빈 배열은 ‘holes없음’을 나타내는 좋은 방법이다.</li>
</ul>
<p>별칭은 타입 체커 뿐 아니라 런타임에도 혼동을 야기할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Coordinate &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BoundingBox &#123;</span><br><span class="line">  x: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">  y: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Polygon &#123;</span><br><span class="line">  exterior: Coordinate[]</span><br><span class="line">  holes: Coordinate[][]</span><br><span class="line">  bbox?: BoundingBox</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1️⃣ 런타임에 혼동을 야기한다.</span></span><br><span class="line"><span class="comment">// HIDE</span></span><br><span class="line"><span class="keyword">const</span> polygon: Polygon = &#123; exterior: [], holes: [] &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculatePolygonBbox</span>(<span class="params">polygon: Polygon</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// END</span></span><br><span class="line"><span class="keyword">const</span> &#123; bbox &#125; = polygon</span><br><span class="line"><span class="keyword">if</span> (!bbox) &#123;</span><br><span class="line">  calculatePolygonBbox(polygon) <span class="comment">// Fills in polygon.bbox</span></span><br><span class="line">  <span class="comment">// Now polygon.bbox and bbox refer to different values!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ 객체 속성에 대해 주의한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">p: Polygon</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">polygon.bbox <span class="comment">// Type is BoundingBox | undefined</span></span><br><span class="line"><span class="keyword">if</span> (polygon.bbox) &#123;</span><br><span class="line">  polygon.bbox <span class="comment">// Type is BoundingBox</span></span><br><span class="line">  fn(polygon)</span><br><span class="line">  polygon.bbox <span class="comment">// Type is still BoundingBox</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2️⃣의 경우 fn(polygon)을 호출하면 polygon.bbox를 제거할 가능성이 있다. 따라서 타입은 BoundingBox | undefined로 되돌리는 것이 안전하다. 그러나 함수를 호출할 때마나 속성 체크를 반복해야한다는 문제가 있다. <strong>그래서 타입스크립트는 함수가 타입 정제를 무효화하지 않는다고 가정하지만 실제로는 무효화될 가능성이 있다.</strong></p>
<h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h3><ul>
<li>별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때 일관되게 사용해야 한다.</li>
<li>비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.</li>
<li>함수 호출이 객체 속성의 타입 정제를 무효화하 수 있다는 점에 주의한다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.</li>
</ul>
<hr>
<h2 id="아이템-25-비동기-코드에는-콜백-대신-async-함수-사용하기"><a href="#아이템-25-비동기-코드에는-콜백-대신-async-함수-사용하기" class="headerlink" title="아이템 25 비동기 코드에는 콜백 대신 async 함수 사용하기"></a>아이템 25 비동기 코드에는 콜백 대신 async 함수 사용하기</h2><p>자바스크립트는 비동기 동작을 모델링하기 위해 <code>콜백 패턴</code>을 사용했는데, 필연적으로 콜백 지옥을 마주하여 직관적으로 코드를 이해하기 어려운 상황에 부딪히게 된다. 이를 극복하기 위해 프로미스, async await 키워드가 도입되어서 콜백 지옥을 간단하게 해결할 수 있게 되었다. ES5 또는 그 이전 버전을 대상으로 할 때 타입스크립트 컴파일러는 async와 await가 동작하도록 정교한 변환을 수행한다. <strong>즉 런타임에 관계없이 async/await를 사용할 수 있다.</strong> async 함수는 항상 프로미스를 반환하도록 강제된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _cache: &#123; [url: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchWithCache</span>(<span class="params">url: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (url <span class="keyword">in</span> _cache) &#123;</span><br><span class="line">    <span class="keyword">return</span> _cache[url]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url)</span><br><span class="line">  <span class="keyword">const</span> text = <span class="keyword">await</span> response.text()</span><br><span class="line">  _cache[url] = text</span><br><span class="line">  <span class="keyword">return</span> text</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> requestStatus: <span class="string">'loading'</span> | <span class="string">'success'</span> | <span class="string">'error'</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">userId: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  requestStatus = <span class="string">'loading'</span></span><br><span class="line">  <span class="keyword">const</span> profile = <span class="keyword">await</span> fetchWithCache(<span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span>)</span><br><span class="line">  requestStatus = <span class="string">'success'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드에서 async/await를 사용했기 때문에 requestStatus가 ‘success’로 끝나는 것이 명백해졌다. 콜백이나 프로미스를 사용하면 의도치한게 동기코드를 작성하게 되는 것처럼 실수로 반(half)동기 코드를 작성할 수 있지만 async를 사용하면 항상 비동기 코드를 작성하게 된다. 또한 async함수에서 프로미스를 반환하면 또 다른 프로미스로 래핑되지 않기 때문에 <code>Promise&lt;Promise&lt;T&gt;&gt;</code>가 아닌 <code>Promise&lt;T&gt;</code>가 된다.</p>
<h3 id="TL-DR-1"><a href="#TL-DR-1" class="headerlink" title="TL;DR"></a>TL;DR</h3><ul>
<li>콜백보다는 프로미스를 사용하는 게 코드 작성과 타입 추론 면에서 유리하다.</li>
<li>가능하면 프로미스를 생성하기보다 async와 await를 사용하는 것이 좋다. 간결하고 직관적인 코드를 작성할 수 있고 모든 종류의 오류를 제거할 수 있기 때문이다.</li>
<li>어떤 함수가 프로미스를 반환한다면 async로 선언하는 것이 좋다.</li>
</ul>
<hr>
<h2 id="아이템-26-타입-추론에-문맥이-어떻게-사용되는지-이해하기"><a href="#아이템-26-타입-추론에-문맥이-어떻게-사용되는지-이해하기" class="headerlink" title="아이템 26 타입 추론에 문맥이 어떻게 사용되는지 이해하기"></a>아이템 26 타입 추론에 문맥이 어떻게 사용되는지 이해하기</h2><p><strong>타입스크립트는 타입 추론 시 값만 고려하는 것이 아니라 그 값이 존재하는 곳의 문맥도 살핀다.</strong> 그렇기 때문에 가끔 이상한 결과가 나오기도 해서 타입 추론에 문맥이 어떻게 사용되는지 이해하는 것이 중요하다.</p>
<p>자바스크립트는 코드의 동작과 실행 순서를 바꾸지 않으면서 표현식을 상수로 분리해 낼 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLanguage</span>(<span class="params">language: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setLanguage(<span class="string">'JavaScript'</span>) <span class="comment">// OK, 인라인 형태</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> language = <span class="string">'JavaScript'</span></span><br><span class="line">setLanguage(language) <span class="comment">// OK, 참조 형태</span></span><br></pre></td></tr></table></figure>
<p>인라인 형태의 타입스크립트는 함수 선언을 통해 <em>매개변수가 language 타입</em>이어야 한다는 것을 알고 있다. 타입스크립트는 일반적으로 값이 처음 등장할 때 타입을 결정하기 때문이다. 그러나 이 값으르 변수로 분리해내면 타입스크립트는 할당 시점에 타입을 추론한다. 그래서 아래와 같이 string으로 추론하고, Language 타입에 할당이 불가능해서 오류가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Language = <span class="string">'JavaScript'</span> | <span class="string">'TypeScript'</span> | <span class="string">'Python'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLanguage</span>(<span class="params">language: Language</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setLanguage(<span class="string">'JavaScript'</span>) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> language = <span class="string">'JavaScript'</span></span><br><span class="line">setLanguage(language)</span><br><span class="line"><span class="comment">// ~~~~~~~~ Argument of type 'string' is not assignable</span></span><br><span class="line"><span class="comment">//          to parameter of type 'Language'</span></span><br></pre></td></tr></table></figure>
<h3 id="해결-방법"><a href="#해결-방법" class="headerlink" title="해결 방법"></a>해결 방법</h3><ul>
<li>타입 선언에서 language의 가능한 값을 제한한다.</li>
<li>language를 상수로 만든다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//타입 선언에서 language의 가능한 값을 제한한다.</span></span><br><span class="line"><span class="keyword">let</span> language: Language = <span class="string">'JavaScript'</span></span><br><span class="line">setLanguage(language) <span class="comment">//정상</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//language를 상수로 만든다.</span></span><br><span class="line"><span class="keyword">const</span> language = <span class="string">'JavaScript'</span></span><br><span class="line">setLanguage(language) <span class="comment">//정상</span></span><br></pre></td></tr></table></figure>
<h3 id="튜플-사용-시-주의점"><a href="#튜플-사용-시-주의점" class="headerlink" title="튜플 사용 시 주의점"></a>튜플 사용 시 주의점</h3><p>튜플은 요소의 타입과 개수가 고정된 배열을 표현할 수 있는 타입이다. 따라서 아래와 같이 사용하면 에러가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Language = <span class="string">'JavaScript'</span> | <span class="string">'TypeScript'</span> | <span class="string">'Python'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLanguage</span>(<span class="params">language: Language</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Parameter is a (latitude, longitude) pair.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panTo</span>(<span class="params">where: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">panTo([<span class="number">10</span>, <span class="number">20</span>]) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loc = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">panTo(loc)</span><br><span class="line"><span class="comment">//    ~~~ Argument of type 'number[]' is not assignable to</span></span><br><span class="line"><span class="comment">//        parameter of type '[number, number]'</span></span><br></pre></td></tr></table></figure>
<p>loc로 선언하여서 타입이 number[]로 추론된다. 이는 길이를 알 수 없는 숫자의 배열이어서 <code>[10,20]</code>과 맞지 않는 수의 요소이기 때문에 튜플에 할당할 수 없다. 이 에러를 해결하는 방법은 다음과 같다.</p>
<ul>
<li>타입스크립트가 의도를 정확히 파악할 수 있도록 타입 선언 제공</li>
<li>상수 문맥 제공: as const로 값이 가리키는 참조와 그 값이 내부까지 상수임을 알려준다. 단 as const는 타입 정의에 실수가 있을 때 타입 정의가 아니라 호출되는 곳에서 에러가 발생해서 근본적인 원인을 찾기 어렵게 한다.</li>
<li>readonly의 사용</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Language = <span class="string">'JavaScript'</span> | <span class="string">'TypeScript'</span> | <span class="string">'Python'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLanguage</span>(<span class="params">language: Language</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Parameter is a (latitude, longitude) pair.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panTo</span>(<span class="params">where: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1️⃣ 타입 선언</span></span><br><span class="line"><span class="keyword">const</span> loc: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">panTo(loc) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ as const로 상수 문맥 제공 - 이 케이스에서는 에러발생</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panTo</span>(<span class="params">where: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> loc = [<span class="number">10</span>, <span class="number">20</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line">panTo(loc)</span><br><span class="line"><span class="comment">// ~~~ Type 'readonly [10, 20]' is 'readonly'</span></span><br><span class="line"><span class="comment">//     and cannot be assigned to the mutable type '[number, number]'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3️⃣ 타입 시그니처에 readonly 사용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panTo</span>(<span class="params">where: readonly [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> loc = [<span class="number">10</span>, <span class="number">20</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line">panTo(loc) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h3 id="객체-사용-시-주의점"><a href="#객체-사용-시-주의점" class="headerlink" title="객체 사용 시 주의점"></a>객체 사용 시 주의점</h3><p>객체 사용 시에도 에러를 발생시키는 문제가 생기는데 아래와 같은 방법으로 해결한다.</p>
<ul>
<li>타입 선언 추가</li>
<li>상수 단언(as const)사용</li>
</ul>
<h3 id="콜백-사용-시-주의점"><a href="#콜백-사용-시-주의점" class="headerlink" title="콜백 사용 시 주의점"></a>콜백 사용 시 주의점</h3><p>콜백을 다른 함수로 전달할 때 콜백의 매개변수 타입을 추론하기 위해 문맥을 사용한다. 그런데 아래 예시에서 fn으로 콜백을 상수로 뽑아내면 문맥이 소실되어 noImplicitAny오류가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callWithRandomNumbers</span>(<span class="params">fn: (n1: <span class="built_in">number</span>, n2: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  fn(<span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ~    Parameter 'a' implicitly has an 'any' type</span></span><br><span class="line">  <span class="comment">//    ~ Parameter 'b' implicitly has an 'any' type</span></span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line">callWithRandomNumbers(fn)</span><br><span class="line"></span><br><span class="line"><span class="comment">//해결방법</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line">callWithRandomNumbers(fn)</span><br></pre></td></tr></table></figure>
<p>해결방법은 아래와 같다.</p>
<ul>
<li>매개변수에 타입 구문을 추가한다.</li>
<li>가능하다면 전체 함수 표현식에 타입 선언</li>
</ul>
<hr>
<h2 id="아이템-27-함수형-기법과-라이브러리로-타입-흐름-유지하기"><a href="#아이템-27-함수형-기법과-라이브러리로-타입-흐름-유지하기" class="headerlink" title="아이템 27 함수형 기법과 라이브러리로 타입 흐름 유지하기"></a>아이템 27 함수형 기법과 라이브러리로 타입 흐름 유지하기</h2><p>로대시(lodash)와 같은 라이브러리의 일부 기능은 순수 자바스크립트로 구현되어 있고, 루프를 대체할 수 있기 때문에 유용하게 사용되고, 타입스크립트와 조합했을 때 더욱 유용하게 사용된다. <strong>타입 정보는 유지하면서 타입 흐름이 계속 전달되도록 하기 때문이다.</strong> 하지만 서드파티 라이브러리 기반으로 코드를 짧게 줄이는데 시간이 많이 든다면 사용하지 않는게 낫다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rows = rawRows</span><br><span class="line">  .slice(<span class="number">1</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">rowStr</span> =&gt;</span></span><br><span class="line">    rowStr</span><br><span class="line">      .split(<span class="string">','</span>)</span><br><span class="line">      .reduce(<span class="function">(<span class="params">row, val, i</span>) =&gt;</span> ((row[headers[i]] = val), row), &#123;&#125;)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">//lodash zipObject사용</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"><span class="keyword">const</span> rows = rawRows</span><br><span class="line">  .slice(<span class="number">1</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">rowStr</span> =&gt;</span> _.zipObject(headers, rowStr.split(<span class="string">','</span>)))</span><br></pre></td></tr></table></figure>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Heejin Lee</p>
  <div class="site-description" itemprop="description">Today I Learned</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">118</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heejin Lee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
