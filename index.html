<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heejinlee07.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Today I Learned">
<meta property="og:type" content="website">
<meta property="og:title" content="Heejin">
<meta property="og:url" content="https://heejinlee07.github.io/index.html">
<meta property="og:site_name" content="Heejin">
<meta property="og:description" content="Today I Learned">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Heejin Lee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://heejinlee07.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Heejin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heejin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Front-end Developer</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/05/19/220520_os3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/19/220520_os3/" class="post-title-link" itemprop="url">Operating Systems - 프로세스 관리</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-20 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-20T00:00:00+09:00">2022-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-22 16:29:50" itemprop="dateModified" datetime="2022-06-22T16:29:50+09:00">2022-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="프로세스의-개념"><a href="#프로세스의-개념" class="headerlink" title="프로세스의 개념"></a>프로세스의 개념</h2><ul>
<li><code>프로세스</code>: 수행중인 프로그램</li>
<li><code>프로세스 문맥(context)</code>: 프로세스가 현재 어떤 상태에서 수행되고 있는지를 정확히 규명하기 위해 필요한 정보</li>
<li><code>프로세스 문맥이 중요한 이유</code> : 타임 쉐어링, 멀티태스킹 등 프로세스들이 번갈아가며 실행되기 때문에 프로세스의 문맥을 파악하고 있어야 이미 실행되던 프로세스를 처음부터 다시 실행한다던가 하는 문제가 생기지 않는다.</li>
</ul>
<p>프로세스 문맥을 파악하려면 다음의 3가지 요소를 알아야 한다.</p>
<ul>
<li>프로그램 카운터가 어디를 가리키고 있는가? (code의 어느 부분까지 실행했는가?)</li>
<li>메모리에 어떤 내용을 담고 있는가?</li>
<li>레지스터에 어떤 값을 넣어두고, 어떤 instruction(프로그램의 기계어를 읽어서 CPU 안으로 불러들임)까지 실행했는가?</li>
</ul>
<h3 id="프로세스-문맥의-분류"><a href="#프로세스-문맥의-분류" class="headerlink" title="프로세스 문맥의 분류"></a>프로세스 문맥의 분류</h3><ul>
<li>하드웨어 문맥: <strong>CPU의 수행상태.</strong> 카운터 값, 각종 레지스터에 저장하고 있는 값들</li>
<li>프로세스의 주소 공간: <strong>프로세스는 코드, 데이터, 스택으로 구성되는 자기만의 독자적인 주소 공간을 가지고 있고,</strong> 이것이 프로세스의 문맥을 결정짓는 중요한 요소이다.</li>
<li>커널 상의 문맥: 프로그램이 수행되어 프로세스가 되면 <strong>프로세스를 관리하기 위한 자료 구조를 유지하게 된다.</strong> PCB, 커널 스택이 이에 해당한다.</li>
</ul>
<h2 id="프로세스의-상태"><a href="#프로세스의-상태" class="headerlink" title="프로세스의 상태"></a>프로세스의 상태</h2><blockquote>
<p>프로세스는 상태가 변경되며 수행되고, 항상 아래 상태 중 어느 한 상태에 머물러 있게 된다.</p>
</blockquote>
<ul>
<li><code>실행 상태(running)</code>: 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태. CPU는 하나 뿐이기 때문에 여러 프로세스가 동시에 실행된다고 해도 <strong>실제 실행 상태에 있는 프로세스는 매 시점 하나 뿐이다.</strong></li>
<li><code>준비 상태(ready)</code>: 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태.</li>
<li><code>봉쇄 상태(blocked, wait, sleep)</code>: 프로세스에게 CPU를 주어도 당장 명령을 실행할 수 없는 상태.</li>
<li><code>시작 상태(new)</code>: 프로세스가 시작되어 각종 자료 구조가 생성되었지만 아직 메모리 획득을 승인받지 못한 상태</li>
<li><code>완료 상태(terminated)</code>: 프로세스가 종료되었으나 운영 체제가 프로세스와 관련된 자료 구조를 완전히 정리하지 못한 상태</li>
<li><p><code>중지(stopped, suspended)</code>: 중기 스케줄러의 등장으로 추가된 상태. 외부적인 이유로 프로세스의 수행이 정지된 상태이다.</p>
<ul>
<li><code>중지 준비(suspended ready)</code>: <strong>준비 상태에 있던</strong> 프로세스가 중기 스케줄러에 의해 디스크로 스왑 아웃되면 중지 준비 상태가 된다. 외부에서 재개시키지 않는 이상 다시 활성화되지 않는다.</li>
<li><p><code>중지 봉쇄(suspended block)</code>: <strong>봉쇄 상태에 있던</strong> 프로세스가 중기 스케줄러에 의해 스왑 아웃된다. 이 상태에서 프로세스가 봉쇄되었던 조건을 만족하면 중지 준비 상태로 바뀐다.</p>
</li>
<li><p><strong>봉쇄 상태와 중지 상태의 차이</strong></p>
<ul>
<li>봉쇄 상태: 자신이 요청한 이벤트가 만족되어야 Ready</li>
<li>중지 상태: 외부에서 resume를 해주어야 Active</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>프로세스의 상태는 시간의 흐름에 따라 변화한다. <em>준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정을 <code>CPU 디스패치</code>라고 한다.</em><br><code>new</code> -&gt; <code>메모리 적재</code> -&gt; <code>ready(in memory)</code> -&gt; <code>CPU 획득(디스패치)</code> -&gt; <code>running</code> -&gt; <code>terminated</code></li>
<li><p>타이머 인터럽트가 발생한 경우 원래 진행하던 프로세스의 문맥을 저장하고, ready 상태에 있는 프로세스 중 하나에 새롭게 CPU 제어권을 부여하고 실행한다. <em>실행시킬 프로세스를 변경하기 위해 원래 수행중이던 프로세스의 문맥을 저장하고, 새로운 프로세스의 문맥을 세팅하는 과정을 <code>문맥 교환(context switch)</code>이라 한다.</em><br><code>new</code> -&gt; <code>메모리 적재</code> -&gt; <code>ready(in memory)</code> -&gt; <code>CPU 획득(디스패치)</code> -&gt; <code>running</code> -&gt; <em><code>타이머 인터럽트</code></em> -&gt; <code>ready</code></p>
<h3 id="문맥교환"><a href="#문맥교환" class="headerlink" title="문맥교환"></a>문맥교환</h3><blockquote>
<p>하나의 사용자 프로세스로부터 다른 사용자 프로세스로 <em>CPU의 제어권이 이양되는 과정</em></p>
</blockquote>
<h4 id="문맥-교환의-과정"><a href="#문맥-교환의-과정" class="headerlink" title="문맥 교환의 과정"></a>문맥 교환의 과정</h4><ul>
<li>원래 CPU를 보유하고 있던 프로세스가 프로세스 카운터 값 등 <strong>프로세스의 문맥을 자신의 PCB에 저장</strong></li>
<li>새롭게 CPU를 할당받을 프로세스가 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원</li>
<li>타이머 인터럽트나 I/O 요청으로 프로그램이 봉쇄 상태인 경우 문맥 교환이 발생하지만 <strong>그 밖의 인터럽트나 시스템 콜 발생 시에는 모드 변경만 있다.</strong> 프로세스의 실행 모드가 사용자에서 커널로 변경된 것일 뿐, CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 것이 아니기 때문이다.</li>
<li><p>프로세스 간 문맥 교환이 빈번해지면 오버헤드도 상당히 커진다.</p>
<ul>
<li><p>문맥 교환이 발생하지 않는 경우<br><code>user mode(사용자 프로세스 A)</code> -&gt; <em><code>interrupt or system call</code></em> -&gt; <code>kernel mode(ISR or system call 함수)</code> -&gt; -&gt; <em><code>문맥 교환 없이 user mode 복귀</code></em> -&gt; <code>user mode(사용자 프로세스 A)</code></p>
</li>
<li><p>문맥 교환이 발생하는 경우<br><code>user mode(사용자 프로세스 A)</code> -&gt; <em><code>timer interrupt or I/O 요청 system call</code></em> -&gt; <code>kernel mode</code> -&gt; <em><code>문맥 교환 발생</code></em> -&gt; <code>user mode(사용자 프로세스 B)</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O 요청이 발생한 경우에도 실행 상태에 있던 프로세스가 봉쇄 상태로 바뀌는 문맥 교환이 발생한다.<br><code>new</code> -&gt; <code>메모리 적재</code> -&gt; <code>ready(in memory)</code> -&gt; <code>CPU 획득(디스패치)</code> -&gt; <code>running</code> -&gt; <em><code>I/O 또는 사건 대기</code></em> -&gt; <em><code>waiting(blocked)</code></em> -&gt; <em><code>I/O 또는 사건 완료</code></em> -&gt; <code>ready</code></p>
</li>
</ol>
<hr>
<h2 id="프로세스-제어-블록-PCB-Process-Control-Block"><a href="#프로세스-제어-블록-PCB-Process-Control-Block" class="headerlink" title="프로세스 제어 블록 (PCB: Process Control Block)"></a>프로세스 제어 블록 (PCB: Process Control Block)</h2><p>운영 체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스당 유지하는 정보를 담는 커널 내의 자료 구조</p>
<table>
  <tr>
    <td rowspan="2">1.<br> 
    OS가 사용하는 정보</td>
    <td>pointer</td>
    <td>process state</td>
  </tr>
  <tr>
    <td colspan="3">process number</td>
  </tr>
    <tr>
    <td rowspan="2">2.<br>CPU 수행 관련 하드웨어 값</td>
    <td colspan="3">process counter</td>
  </tr>
    <tr>
    <td colspan="3">registers</td>
  </tr>
    <tr>
    <td>3.<br>메모리 관련</td>
    <td colspan="3">memory limits</td>
  </tr>
  </tr>
    <tr>
    <td rowspan="2">4.<br>파일 관련</td>
    <td colspan="3">open files</td>
  </tr>
    </tr>
    <tr>
    <td colspan="3">...</td>
  </tr>
</table>

<hr>
<h2 id="프로세스를-스케줄링하기-위한-큐"><a href="#프로세스를-스케줄링하기-위한-큐" class="headerlink" title="프로세스를 스케줄링하기 위한 큐"></a>프로세스를 스케줄링하기 위한 큐</h2><blockquote>
<p>프로세스는 각 큐를 오가며 수행한다.</p>
</blockquote>
<ul>
<li><code>작업 큐(job queue)</code>: 시스템 내 모든 프로세스를 관리하기 위한 큐. <em>프로세스 상태와 무관하게 모든 프로세스 상태가 속하지만 작업 큐에 있다고 해서 반드시 메모리를 가진 것은 아니다.</em></li>
<li><code>준비 큐(ready queue)</code>: CPU를 할당받고 실행되기 위해 기다리고 있는 프로세스의 집합. <em>프로세스는 준비 상태</em></li>
<li><code>장치 큐(device queue)</code>: 각각의 장치마다 서비스를 기다리며 줄 서 있는 프로세스의 큐. <em>프로세스는 봉쇄 상태</em></li>
</ul>
<hr>
<h2 id="스케줄러"><a href="#스케줄러" class="headerlink" title="스케줄러"></a>스케줄러</h2><blockquote>
<p>어떤 프로세스에게 자원을 할당할지를 결정하는 운영 체제 커널의 모듈</p>
</blockquote>
<ul>
<li><code>장기 스케줄러(job scheduler)</code>: <strong>어떤 프로세스를 준비 큐에 삽입할지를 결정한다.</strong> 준비 큐는 CPU만 얻으면 당장 실행 가능한 프로세스이기 때문에 메모리를 보유해야 하고, <strong>메모리 또는 각종 자원을 얼마나 할당할지에 대해서도 관여한다.</strong></li>
<li>수십 초 내 수 분 단위로 가끔 호출되므로 상대적으로 속도가 느려도 된다.</li>
<li>메모리에 동시에 올라가 있는 프로세스의 수를 조절한다.</li>
<li>현대 시분할 시스템에서는 보통 장기 스케줄러가 없다.</li>
</ul>
<p>중기 스케줄러: 현대 시분할 시스템용 운영체제에서 사용한다. 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하될 때 메모리에 적재된 프로세스의 수를 동적으로 조절한다.<br>프로세스당 보유 메모리량이 지나치게 적으면 일부 프로세스를 메모리에서 디스크로 스왑 아웃시킨다.</p>
<ul>
<li><code>단기 스케줄러(CPU scheduler)</code>: 준비 상태의 프로세스 중에서 <strong>어떤 프로세스를 다음 번에 실행 상태로 만들 것인지 결정한다.</strong> 준비 큐에 있는 프로세스 중 어떤 프로세스에게 CPU를 할당할지를 결정하고, <em>시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다.</em></li>
<li>ms 이하 단위로 매우 빈번하게 호출되므로 속도가 빨라야 한다.</li>
</ul>
<hr>
<h2 id="프로세스의-생성"><a href="#프로세스의-생성" class="headerlink" title="프로세스의 생성"></a>프로세스의 생성</h2><blockquote>
<p>시스템 부팅 후 최초의 프로세스는 운영 체제가 생성하고, 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성</p>
</blockquote>
<ul>
<li>부모 프로세스: 프로세스를 생성한 프로세스</li>
<li>자식 프로세스: 새롭게 생성된 프로세스</li>
</ul>
<p>부모 프로세스가 자식 프로세스를 생성하는 방식으로 족보(Tree)와 같은 계층 구조를 형성한다.</p>
<h3 id="프로세스의-작업-수행"><a href="#프로세스의-작업-수행" class="headerlink" title="프로세스의 작업 수행"></a>프로세스의 작업 수행</h3><p>프로세스가 작업을 하려면 자원이 필요한데 아래와 같은 세가지 유형으로 자원을 공유한다.</p>
<ul>
<li>부모-자식이 모든 자원을 공유</li>
<li>일부를 공유</li>
<li>전혀 공유하지 않음</li>
</ul>
<h3 id="프로세스가-수행되는-모델"><a href="#프로세스가-수행되는-모델" class="headerlink" title="프로세스가 수행되는 모델"></a>프로세스가 수행되는 모델</h3><ul>
<li>부모-자식이 공존하며 수행: 자식과 부모가 CPU를 획득하기 위해 경쟁하는 관계.</li>
<li>자식이 종료될 때까지 부모가 기다림: 자식 프로세스가 종료될 때까지 부모 프로세스는 봉쇄 상태에 있다가 자식 프로세스가 종료되면 부모는 준비 상태가 되어 다시 CPU를 얻을 권한이 생긴다.</li>
</ul>
<h3 id="프로세스의-생성-절차"><a href="#프로세스의-생성-절차" class="headerlink" title="프로세스의 생성 절차"></a>프로세스의 생성 절차</h3><blockquote>
<p>프로세스는 생성되면 자신만의 독자적인 주소 공간을 갖고, <strong>자식 프로세스는 부모 프로세스의 주소 공간 내용을 그대로 복사해서 생성한다.</strong></p>
</blockquote>
<ul>
<li><p><code>생성</code>: 유닉스에서는 fork() 시스템 콜로 새로운 프로세스를 생성하고, 자식 프로세스를 생성할 때 부모 프로세스의 내용을 그대로 복제 생성한다. 부모 프로세스의 모든 문맥을 복제해서 생성되었기 때문에 부모 프로세스가 현재 수행한 시점(프로그램 카운터 지점)부터 수행할 수 있다.</p>
</li>
<li><p><code>종료</code>: 부모 프로세스 종료 전에 자식 프로세스부터 종료되어야 한다.</p>
<ul>
<li><code>자발적 종료</code>: 프로세스가 마지막 명령 수행 후 exit() 시스템 콜로 운영 체제에게 알린다.</li>
<li><code>비자발적 종료</code>: 부모 프로세스가 abort()를 호출하여 자식 프로세스의 수행을 강제 종료시킨다.</li>
</ul>
</li>
</ul>
<h2 id="프로세스-간의-협력"><a href="#프로세스-간의-협력" class="headerlink" title="프로세스 간의 협력"></a>프로세스 간의 협력</h2><blockquote>
<p>프로세스는 각자 자신의 독립적인 주소 공간을 가지고 수행하므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없다.</p>
</blockquote>
<p>하지만 독립적인 프로세스들이 서로 협력할 때 효율적인 경우 <code>협력 매커니즘</code>을 제공하여 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있도록 한다.</p>
<h3 id="IPC-Inter-Process-Communication"><a href="#IPC-Inter-Process-Communication" class="headerlink" title="IPC(Inter-Process Communication)"></a>IPC(Inter-Process Communication)</h3><p>대표적인 협력 매커니즘으로 하나의 컴퓨터 안에서 실행중인 서로 다른 프로세스 간에 발생하는 통신. 의사 소통 기능과 동기화가 보장되어야 한다.</p>
<ul>
<li>메시지 전달: 프로세스 간 공유 변수를 사용하지 않고, 커널을 통해 메시지를 전달하는 방법으로 통신</li>
<li>공유 메모리: 프로세스 간 공유 변수를 사용하여 주소 공간의 일부를 공유한다.</li>
</ul>
<h3 id="스레드"><a href="#스레드" class="headerlink" title="스레드"></a>스레드</h3><p>스레드는 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 <strong>동일한 프로세스를 구성하는 스레드 간에는 주소 공간을 공유하므로 협력이 가능하다.</strong></p>
<ul>
<li>program counter, register set, stack space로 구성된다.</li>
<li>스레드가 동료 스레드와 공유하는 부분(task): code section, data section, OS resource</li>
</ul>
<hr>
<p><em>References</em><br><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323" target="_blank" rel="noopener">운영체제</a><br>[운영 체제와 정보 기술의 원리] 반효경 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/05/19/220520_os4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/19/220520_os4/" class="post-title-link" itemprop="url">Operating Systems - CPU 스케줄링</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-20 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-20T00:00:00+09:00">2022-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-22 16:29:50" itemprop="dateModified" datetime="2022-06-22T16:29:50+09:00">2022-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>CPU: 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙 처리 장치</p>
</blockquote>
<p>CPU는 일반적으로 시스템 내에 하나 뿐이기 때문에 여러 프로그램이 동시에 수행되는 시분할 환경에서 매우 효율적으로 관리되어야 한다.</p>
<p>프로그램 실행에는 CPU 내에서 수행되는 기계어 명령은 다음의 세 가지가 있다.</p>
<ol>
<li>CPU 내에서 수행되는 명령</li>
<li>메모리 접근을 필요로 하는 명령</li>
<li>입출력을 동반하는 명령</li>
</ol>
<ul>
<li><code>CPU 버스트(CPU burst)</code>: 1,2는 사용자 프로그램이 직접 CPU를 가지고 수행하는 비교적 빠른 명령. 프로그램이 I/O를 한 번 수행한 후 다음번 I/O를 수행하기까지 직접 CPU가지고 명령을 수행하는 일련의 작업이다.</li>
<li><code>I/O 버스트</code>: 3은 I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하기 때문에 비교적 느린 명령이다. I/O 작업이 요청된 후 완료되어 다시 CPU 버트스토 돌아가기까지 일어나는 일련의 작업이다.</li>
</ul>
<p>각 프로그램마다 CPU버스트와 I/O 버스트가 차지하는 비율은 균일하지 않지만 아래와 같이 프로세스를 분류해볼 수 있다.</p>
<ul>
<li><code>I/O 바운드 프로세스</code>: I/O 요청이 빈번해서 CPU 버스트가 짧게 나타난다. e.g. 대화형 프로그램</li>
<li><code>CPU 바운드 프로세스</code>: I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타난다. e.g. 계산위주 job</li>
</ul>
<p>CPU는 이와 같이 사용하는 패턴이 상이한 여러 프로그램이 동일한 시스템 내에서 실행되기 때문에 효율적인 스케줄링이 매우 중요하다. CPU 스케줄링 시 <strong>CPU 버스터가 짧은 프로세스(I/O 바운드 프로세스)에게 우선적으로 CPU를 사용할 수 있도록 한다.</strong> CPU 바운드 프로세스를 먼저 CPU에 할당하면 그 프로세스가 CPU를 다 사용할 때까지 I/O 바운드 프로세스의 응답 시간이 길어지고, 해당 I/O 장치도 그 시간동안 작업을 수행하지 않기 때문이다.</p>
<hr>
<h2 id="CPU-스케줄러"><a href="#CPU-스케줄러" class="headerlink" title="CPU 스케줄러"></a>CPU 스케줄러</h2><blockquote>
<p>준비 상태에 있는 프로세스 중 <em>어떠한 프로세스에게 CPU를 할당할지 결정</em>하는 운영 체제의 코드</p>
</blockquote>
<h3 id="스케줄링-방식"><a href="#스케줄링-방식" class="headerlink" title="스케줄링 방식"></a>스케줄링 방식</h3><ol>
<li>비선점형 방식(nonpreemptive): CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지 CPU를 빼앗기지 않음.<ol>
<li>실행 상태 -&gt; I/O 요청 -&gt; blocked</li>
<li>CPU에서 실행 중이던 프로세스 종료</li>
</ol>
</li>
<li>선점형 방식(preemptive): 프로세스가 CPU를 계속 사용하기 원하더라도 강제로 빼앗을 수 있음.<ol>
<li>실행 상태 -&gt; 타이머 인터럽트 -&gt; Ready</li>
<li>I/O 요청 -&gt; 봉쇄 -&gt; I/O 작업 완료 -&gt; 인터럽트 -&gt; Ready</li>
</ol>
</li>
</ol>
<h2 id="디스패치"><a href="#디스패치" class="headerlink" title="디스패치"></a>디스패치</h2><p>CPU 스케줄러가 어떤 프로세스에세 CPU를 할당할지 결정하고 나면 <em>새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경 설정을 하는 커널 모듈</em></p>
<h2 id="스케줄링의-성능-평가"><a href="#스케줄링의-성능-평가" class="headerlink" title="스케줄링의 성능 평가"></a>스케줄링의 성능 평가</h2><ul>
<li><code>시스템 관점</code>: 시스템 입장에서의 성능 척도. CPU 활용도와 처리량</li>
<li><code>사용자 관점</code>: 프로그램 입장에서의 성능 척도. 소요 시간, 대기 시간, 응답 시간 등 기다린 시간과 관련된 지표</li>
</ul>
<ol>
<li><code>CPU 활용도</code>: 전체 시간 중 CPU가 명령을 수행한 시간의 비율. 휴면(idle) 상태에 머무르는 시간을 최대한 줄이는 것이 중요하다.</li>
<li><code>처리량</code>: 주어진 시간 동안 CPU 버스트를 완료한 프로세스의 개수. CPU 버스트가 짧은 프로세스에게 우선적으로 할당하는 것이 유리하다.</li>
<li><code>소요 시간</code>: 프로세스가 CPU 요청 시점부터 CPU 버스터가 끝날 때까지 걸린 시간. 준비 큐에서 기다린 시간 + 실제로 CPU를 사용한 시간</li>
<li><code>대기 시간</code>: 프로세스가 CPU 버스트 기간 중 준비 큐에서 기다린 시간의 합</li>
<li><code>응답 시간</code>: 프로세스가 CPU 요청 시점부터 처음으로 CPU를 얻을 때까지 걸린 시간. 시분할 환경에서 매우 중요함.</li>
</ol>
<hr>
<h2 id="스케줄링-알고리즘"><a href="#스케줄링-알고리즘" class="headerlink" title="스케줄링 알고리즘"></a>스케줄링 알고리즘</h2><h3 id="1-FCFS-First-Come-First-Served"><a href="#1-FCFS-First-Come-First-Served" class="headerlink" title="1. FCFS (First-Come First-Served)"></a>1. FCFS (First-Come First-Served)</h3><blockquote>
<p>프로세스가 <code>준비 큐에 도착한 시간 순서대로</code> CPU를 할당</p>
</blockquote>
<p>비선점형으로 먼저 요청한 프로세스가 자발적으로 CPU를 반납할 때까지 선점하지 않는다. 따라서 먼저 도착한 프로세스가 작업 시간이 길 경우 다수의 프로세스들이 앞 작업이 끝날 때까지 기다려야 해서 평균 대기 시간이 길어질 수 있다. <em>이렇게 CPU 버스트가 긴 프로세스 다음에 짧은 프로세스가 도착해서 오랜 시간을 기다려야 한다면</em> 이를 <code>콘보이 현상</code>이라고 한다. 이런 경우 I/O 장치의 활용도까지도 떨어지게 된다. 그래서 짧은 프로세스가 도착하면 평균 대기 시간은 짧아지고, 프로세스의 성격에 따라 긴 프로세스가 먼저 도착하면 평균 대기 시간이 길어진다.</p>
<h3 id="2-SJF-Shortest-Job-First"><a href="#2-SJF-Shortest-Job-First" class="headerlink" title="2. SJF (Shortest-Job-First)"></a>2. SJF (Shortest-Job-First)</h3><blockquote>
<p>CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당</p>
</blockquote>
<p>평균 대기 시간을 가장 짧게 하는 최적을 알고리즘이다.</p>
<ul>
<li>비선점형 방식: 현재 CPU에서 실행중인 프로세스의 남은 CPU 버스트 시간보다 더 짧은 프로세스가 도착하면 CPU를 빼앗긴다. (SRTF: Shortest Remaining Time First)</li>
<li>선점형 방식: 현재 CPU를 점유하고 있는 프로세스가 CPU 버스트를 모두 수행하고 스스로 CPU를 내어놓을 때까지 스케줄링을 하지 않는다.</li>
</ul>
<p>시분할 환경에서는 중간중간 새로운 프로세스가 도착하는 경우가 발생하기 때문에 선점형 방식이 평균 대기 시간을 가장 많이 줄일 수 있다. 하지만 프로세스의 CPU 버스트 시간을 미리 알 수 없기 때문에 과거의 CPU 버스트 시간을 통해 시간을 예측해서 프로세스에 CPU를 할당한다. <em>그런데 어떠한 프로세스가 시작되었는데, 그 다음으로 CPU 버스트가 짧은 프로세스가 계속 도착해서 CPU를 빼앗기게 되고, 짧은 프로세스가 계속 도착하게 되면 처음 프로세스는 영원히 CPU를 할당받을 수 없을 수 있고,</em> 이를 <code>기아(starvation) 현상</code>이라 한다.</p>
<h3 id="3-우선순위-스케줄링"><a href="#3-우선순위-스케줄링" class="headerlink" title="3. 우선순위 스케줄링"></a>3. 우선순위 스케줄링</h3><blockquote>
<p>준비 큐에서 기다리는 프로세스들 중에 <code>우선순위가 가장 높은 프로세스</code>에게 제일 먼저 할당</p>
</blockquote>
<p>우선순위는 우선순위값을 통해 표시해서 그 값이 작을수록 높은 우선순위를 가지는 것이다. 우선순위 스케줄링도 SJF처럼 기아 현상이 있을 수 있는데, 우선순위가 높은 프로세스가 계속 도착하면 우선순위가 낮은 프로세스는 CPU를 얻지 못하고, 계속 대기해야 하기 때문이다. 이를 해결하기 위해서 <code>노화 기업(aging)</code>을 사용하고, 이는 <em>기다리는 시간이 길어지면 우선순위를 조금씩 높여 언젠가는 가장 높은 우선순위가 되어 CPU를 할당받을 수 있게 하는 것이다.</em></p>
<h3 id="4-라운드-로빈-스케줄링"><a href="#4-라운드-로빈-스케줄링" class="headerlink" title="4. 라운드 로빈 스케줄링"></a>4. 라운드 로빈 스케줄링</h3><blockquote>
<p>시분할 시스템의 성질을 가장 잘 활용한 새로운 의미의 스케줄링 방식</p>
</blockquote>
<p>각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 제한되며, 시간이 경과한 프로세스가 있으면 CPU를 회수해서 준비 큐에 있는 다른 프로세스에게 CPU를 할당한다. <strong>각 프로세스마다 한 번에 CPU를 연속적으로 사용할 수 있는 최대 시간은 할당 시간이라 부른다.</strong> 할당시간이 너무 길면 FCFS처럼 콘보이 현상이 발생할 수 있고, 반대로 너무 짧으면 CPU 프로세스 교체가 빈번해서 문맥 교환에 오버헤드가 커진다. 따라서 할당 시간은 수십 밀리세컨드 정도의 규모로 설정한다. <em>라운드 로빈은 여러 종류의 이질적인 프로세스가 같이 실행되는 환경에서 효과적이고, 대화형 프로세스의 빠른 응답 시간을 보장할 수 있다는 장점이 있다.</em></p>
<hr>
<p><em>References</em><br><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323" target="_blank" rel="noopener">운영체제</a><br>[운영 체제와 정보 기술의 원리] 반효경 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/05/15/220516_os2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/15/220516_os2/" class="post-title-link" itemprop="url">Operating Systems - 컴퓨터 시스템의 동작 원리</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-16 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-16T00:00:00+09:00">2022-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-22 16:29:50" itemprop="dateModified" datetime="2022-06-22T16:29:50+09:00">2022-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="컴퓨터-시스템의-구조"><a href="#컴퓨터-시스템의-구조" class="headerlink" title="컴퓨터 시스템의 구조"></a>컴퓨터 시스템의 구조</h2><p>컴퓨터의 업무 처리 방식: 컴퓨터 외부 장치에서 컴퓨터 내부로 데이터를 읽어와서 각종 연산을 수행 후, 그 결과를 컴퓨터 외부 장치로 다시 내어 보내는 방식. 컴퓨터 내부로 데이터가 들어오는 것이 입력(input), 외부 장치로 데이터가 나가는 것은 출력(output)이다.</p>
<ul>
<li>입출력 장치: 컴퓨터 외부 장치를 입출력 장치라고도 한다.</li>
<li>컨트롤러: 컴퓨터 내의 하드웨어 장치에 존재하는 일종의 작은 CPU</li>
<li>커널: 운영 체제 중 항상 메모리에 올라가 있는 부분</li>
</ul>
<p><img src='/image/computerStructure.png' alt='CPU와 각종 컨트롤 디바이스의 모습'></p>
<h2 id="CPU와-I-O-연산"><a href="#CPU와-I-O-연산" class="headerlink" title="CPU와 I/O 연산"></a>CPU와 I/O 연산</h2><ul>
<li><code>CPU</code>: 컴퓨터 내에서 수행되는 연산을 담당한다. 매시점 메모리에서 명령을 하나씩 읽어와서 수행한다.<ul>
<li><code>인터럽트 라인</code>: CPU 옆에 있는데, CPU가 자신의 작업을 하던 중 인터럽트 라인에 신호가 들어오면 하던 일을 멈추고 인터럽트와 관련된 일을 처리한다. <em>작업이 다 끝났는지 어떤지 전달받는 역할을 한다.</em></li>
</ul>
</li>
<li><p><code>I/O 연산</code>: 입출력 장치의 I/O 연산은 I/O 컨트롤러가 담당한다.</p>
<ul>
<li><code>컨트롤러</code>: 입출력 장치와 메인 CPU는 동시 수행이 가능한데, 이를 제어하기 위해 장치 컨트롤러가 있다. 키보드 입력 등의 <em>이벤트를 CPU에게 알려 줄 필요가 있는 경우 컨트롤러가 발생시킨다.</em><ul>
<li>디스크나 키보드 등의 장치에서 로컬 버퍼로 데이터를 읽어오는 일을 담당한다.</li>
<li>인터럽트를 발생시켜 CPU에 보고하여 데이터를 모두 가지고 왔는지 아닌지를 체크한다.</li>
</ul>
</li>
<li><code>로컬 버퍼(local buffer)</code>: 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리. 로컬 버퍼에 임시 저장되어 있던 데이터는 이후 메모리에 전달된다.</li>
</ul>
</li>
<li><p><em>사용자 프로그램은 어떻게 I/O를 할까?</em></p>
<ul>
<li>System call: 사용자 프로그램은 운영체제에게 I/O 요청</li>
<li>trap을 이용하여 이너럽트 벡터의 특정위치로 이동</li>
<li>제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동</li>
<li>올바른 I/O 요청인지 확인 후 수행</li>
<li>I/O 완료 시 제어권을 시스템 콜 다음 명령으로 옮긴다.</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>인터럽트: 인터럽트 당한 시점의 레지스터와 Program Counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.</p>
</blockquote>
<h2 id="인터럽트의-일반적인-기능"><a href="#인터럽트의-일반적인-기능" class="headerlink" title="인터럽트의 일반적인 기능"></a>인터럽트의 일반적인 기능</h2><p><em>일반적으로 인터럽트는 하드웨어가 발생시킨 인터럽트</em>를 뜻하지만 넓은 의미의 인터럽트는 하드웨어와 소프트웨어 인터럽트 모두를 말한다. 두 가지의 차이점은 일을 수행하는 방식에 있어서 하드웨어 인터럽트는 컨트롤러 등 <strong>하드웨어 장치가 CPU의 인터럽트 라인을 세팅하는 방식</strong>이고, 소프트웨어 인터럽트는 소프트웨어가 그 일을 수행한다.</p>
<ul>
<li>하드웨어 인터럽트: 하드웨어가 발생시킨 인터럽트</li>
<li>소프트웨어 인터럽트(Trap)<ul>
<li>exception: 프로그램이 오류를 범한 경우</li>
<li>system call: 프로그램이 커널 함수를 호출한 경우. 운영체제에 정의된 함수를 호출하는 것.</li>
</ul>
</li>
</ul>
<h2 id="인터럽트-핸들링"><a href="#인터럽트-핸들링" class="headerlink" title="인터럽트 핸들링"></a>인터럽트 핸들링</h2><blockquote>
<p>인터럽트가 발생한 경우 처리해야 할 일의 절차</p>
</blockquote>
<h2 id="하드웨어-인터럽트"><a href="#하드웨어-인터럽트" class="headerlink" title="하드웨어 인터럽트"></a>하드웨어 인터럽트</h2><h3 id="인터럽트-관련-용어"><a href="#인터럽트-관련-용어" class="headerlink" title="인터럽트 관련 용어"></a>인터럽트 관련 용어</h3><ul>
<li><code>인터럽트 처리 루틴(interrupt service routine)</code>: 인터럽트 핸들러. 커널 내에 존재하는 해당 인터럽트를 처리하는 커널 함수. 다양한 인터럽트들이 각각 처리해야 할 업무들을 정의하고 있다.</li>
<li><code>인터럽트 벡터</code>: 여러 가지 인터럽트에 대해 해당 인터럽트 발생시 처리해야 할 루틴의 주소를 보관하고 있는 테이블. 인터럽트 종류마다 번호가 있고, 그 번호에 따라 처리해야 할 코드의 위치를 포인터로 가리키고 있는 자료 구조. 해당 인터럽트의 처리 루틴 주소를 가지고 있다.</li>
<li><p><code>Mode bit</code>: 하드웨어의 보안을 위한 장치. 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호장치. Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원</p>
<blockquote>
<p><code>1</code> 사용자 모드 : 사용자 프로그램 수행<br><code>0</code> 모니터 모드 : OS 코드 수행 (=커널 코드, 시스템 모드)</p>
</blockquote>
<ul>
<li>보안을 해 칠 수 있는 중요한 명령어는 모니터 모드에서만 수행가능한 <code>특권명령</code>으로 규정된다.</li>
<li>인터럽트나 exception 발생 시 하드웨어가 Mode bit을 <code>0</code>으로 바꾼다.</li>
<li>사용자 프로그램에게 CPU를 넘기기 전에 Mode bit을 <code>1</code>로 세팅한다.</li>
</ul>
</li>
<li><p><code>I/O Device Controller</code> : 해당 I/O 장치 유형을 관리하는 일종의 작은 CPU.</p>
<ul>
<li>제어 정보를 위해 control register, status register를 가진다.</li>
<li>I/O는 실제 device와 local buffer 사이에서 일어난다.</li>
<li><strong>Device controller는 I/O가 끝났을 경우 인터럽트로 CPU에 그 사실을 알린다.</strong></li>
</ul>
</li>
<li><code>Device driver (장치구동기)</code>: OS 코드 중 각 장치별 처리 루틴 -&gt; <code>software</code></li>
<li><code>Device Controller</code>: 각 장치를 통제하는 일종의 작은 CPU -&gt; <code>hardware</code></li>
<li><code>Timer</code>: 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킨다.<ul>
<li>타이머는 매 클릭 틱 때마다 1씩 감소한다.</li>
<li>타이머 값이 0이 되면 타이머 인터럽트가 발생한다.</li>
<li><strong>CPU를 특정 프로그램이 독점하는 것으로부터 보호한다.</strong></li>
<li>Time sharing을 구현하기 위해 널리 이용된다.</li>
<li>현재 시간을 계산하기 위해서도 사용된다.</li>
</ul>
</li>
<li><code>Register</code>: 메모리보다 더 빠르면서 정보를 저장할 수 있는 공간. 두 개의 레지스터를 사용하여 프로그램이 접근하려는 메모리 부분이 합법적인지 체크하여 메모리 보호가 이루어진다.<ul>
<li>기준 레지스터(base register): 어떤 프로그램이 수행되는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리 상의 가장 작은 주소를 보관.</li>
<li>한계 레지스터(limit register): 그 프로그램이 기준 레지스터 값부터 접근할 수 있는 메모리의 범위를 보관.</li>
<li>사용자 프로그램은 기준 레지스터 + 한계 레지스터 사이의 주소 영역만 접근 가능하고, 접근하려는 주소가 이 범위 안에 없으면 예외 상황이라는 소프트웨어 인터럽트를 발생시켜 CPU의 제어권을 빼앗는다.</li>
</ul>
</li>
<li>시스템 콜: 입출력 명령은 운영 체제 코드에 구현되어 있어서 사용자 프로그램은 직접 입출력을 수행하는 대신 <strong>운영 체제에게 시스템 콜이라는 서비스 대행 요청을 하여 입출력을 수행한다.</strong></li>
</ul>
<h3 id="인터럽트-수행-순서"><a href="#인터럽트-수행-순서" class="headerlink" title="인터럽트 수행 순서"></a>인터럽트 수행 순서</h3><ol>
<li>이벤트가 발생하여 컨트롤러가 인터럽트를 발생시킨다. 예를 들어 <em>Disk에서 읽어오라.</em>와 같은 명령을 만나면 CPU가 Disk에 직접 접근하지 않고, OS가 Disk의 Controller에 일을 시키고, 수행한 일은 local buffer에 집어 넣는다. 일이 끝나면 local buffer에 있는 내용을 해당 일을 시킨 프로그램에 copy해준다.</li>
<li>CPU는 하던 일을 멈추고, 인터럽트 벡터를 확인하고, 해당 인터럽트가 있는 위치를 찾아간다.</li>
<li>인터럽트 서비스 루틴을 통해 해당하는 인터럽트 처리를 완료한다.</li>
<li>인터럽트의 처리가 완료되었으므로 CPU를 점령당하기 이전의 인터럽트로 돌아가서 하던 작업을 다시 처리한다.</li>
</ol>
<h2 id="소프트웨어-인터럽트"><a href="#소프트웨어-인터럽트" class="headerlink" title="소프트웨어 인터럽트"></a>소프트웨어 인터럽트</h2><p>프로세스가 0으로 나누는 연산 등을 시도하거나 프로그램이 수행되다가 접근해서는 안 되는 메모리 영역에 접근하려 할 때 발생한다. 트랩(Trap)라고도 불린다. 하드웨어 인터럽트처럼 컨트롤러가 발생시키는 것이 아니고, <strong>프로그램 수행 도중 직접 CPU에 인터럽트 라인을 세팅하여 발생시킨다.</strong></p>
<hr>
<h2 id="입출력-구조"><a href="#입출력-구조" class="headerlink" title="입출력 구조"></a>입출력 구조</h2><blockquote>
<p>입출력(I/O): 컴퓨터 시스템이 컴퓨터 외부의 주변 장치들과 데이터를 주고 받는 것</p>
</blockquote>
<p>입출력 명령어는 다음의 두 가지 방식으로 수행된다.</p>
<ul>
<li>I/O를 수행하는 special instruction에 의해</li>
<li>Memory Mapped I/O에 의해</li>
</ul>
<p>입출력 구조는 동기식 입출력, 비동기식 입출력의 두 가지 방식이 있다. 이 두 가지는 CPU의 제어권 부여 방식에 차이가 있는데, <strong>두 경우 모두 입출력이 완료되었을 때 인터럽트를 통해 알린다.</strong></p>
<h3 id="동기식-입출력"><a href="#동기식-입출력" class="headerlink" title="동기식 입출력"></a>동기식 입출력</h3><ul>
<li><strong>입출력 요청 후 작업이 완료된 후에야 CPU의 제어권이 사용자 프로그램에게 다시 넘어간다.</strong></li>
<li>입출력 연산이 끝날 때까지 CPU는 아무 일도 수행할 수 없다. 이 상태를 <code>봉쇄 상태</code>라고 한다.</li>
<li>입출력 요청의 동기화를 위해 <code>큐(Queue)</code>를 두어 요청 순서대로 처리될 수 있도록 한다. 그 이유는 다수의 입출력이 동시에 요청되거나 처리되는 경우 요청 순서가 뒤바껴 의도치 않은 결과를 일으킬 수 있기 때문이다. 장치마다 큐 헤더가 존재하고 각 장치별로 입출력 수행 순서를 지켜 주기 위한 큐를 관리한다. 컨트롤러는 이 순서에 따라서 매 시점 하니씩 자신에게 주어진 입출력 작업을 처리한다.</li>
</ul>
<h3 id="비동기식-입출력"><a href="#비동기식-입출력" class="headerlink" title="비동기식 입출력"></a>비동기식 입출력</h3><ul>
<li>입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라 <strong>CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 부여한다.</strong></li>
<li>입출력 연산이 완료되는 것과 무관하게 처리가 가능한 작업을 먼저 처리한다.</li>
</ul>
<hr>
<h2 id="DMA-Direct-Memory-Access"><a href="#DMA-Direct-Memory-Access" class="headerlink" title="DMA (Direct Memory Access)"></a>DMA (Direct Memory Access)</h2><blockquote>
<p>CPU가 주변 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주는 역할</p>
</blockquote>
<ul>
<li>원칙적으로 메모리는 CPU에 의해서만 접근 가능한데 이렇게 될 경우 주변 장치가 메모리 접근을 원할 때마다 인터럽트를 통해 CPU의 업무가 방해받는 비효율이 발생한다.</li>
<li><strong>이러한 CPU 사용의 비효율을 극복하기 위해 CPU 외에 메모리 접근이 가능한 장치인 DMA를 두는 것이다.</strong></li>
<li>DMA가 로컬 버퍼에서 메모리로 읽어오는 작업을 대행하기 때문에 CPU에 발생하는 인터럽트 빈도가 줄어든다.</li>
<li>DMA는 바이트 단위가 아닌 <code>block 단위</code>로 인터럽트를 발생시킨다.</li>
</ul>
<hr>
<h2 id="저장-장치의-구조"><a href="#저장-장치의-구조" class="headerlink" title="저장 장치의 구조"></a>저장 장치의 구조</h2><blockquote>
<p>컴퓨터의 저장 창치는 주 기억 장치와 보조 기억 장치가 있다.</p>
</blockquote>
<ul>
<li>주 기억 장치(메모리): <strong>전원이 꺼지면 저장되어 있던 내용이 모두 날아가는 <code>휘발성</code>이다.</strong><ul>
<li>RAM을 매체로 사용하는 경우가 대부분이다.</li>
</ul>
</li>
<li>보조 기억 장치: <strong>전원이 꺼져도 저장된 내용을 기억할 수 있는 <code>비휘발성</code>이다.</strong><ul>
<li>마그네틱 디스크, 플래시 메모리, CD, 마그네틱 테이프 등이 사용된다.</li>
<li>보조 기억 장치의 용도<ul>
<li>시스템용: 전원이 나가도 유지해야 할 정보는 <strong>파일 형태로 저장한다.</strong></li>
<li>스왑 영역용: 메모리의 연장 공간으로 운영 체제가 프로그램 수행에 당장 필요한 부분만 메모리에 올려 두고, <em>그렇지 않은 부분은 디스크의 스왑 영역에 내려놓게 된다. 그리고 이를 스왑 아웃이라 한다.</em> 하드 디스크가 가장 널리 사용된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="저장-장치의-계층-구조"><a href="#저장-장치의-계층-구조" class="headerlink" title="저장 장치의 계층 구조"></a>저장 장치의 계층 구조</h2><p>빠른 저장 장치일수록 상위, 느린 저장 장치는 하위에 구성되는 계층 구조로 구성된다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>빠른 저장 장치</th>
<th>느린 저장 장치</th>
</tr>
</thead>
<tbody>
<tr>
<td>가격이 높아서 적은 용량을 사용.</td>
<td>가격이 저렴하여 대용량 사용.</td>
</tr>
<tr>
<td>속도가 빠르다.</td>
<td>속도가 느리다.</td>
</tr>
<tr>
<td>휘발성</td>
<td>비휘발성</td>
</tr>
<tr>
<td>register, cache memory, main memory…</td>
<td>magnetic disk, optical disk, magnetic tape…</td>
</tr>
<tr>
<td>CPU가 직접 접근하여 처리 가능</td>
<td>CPU의 직접 접근 불가</td>
</tr>
</tbody>
</table>
</div>
<p><code>캐슁 기법</code>: <strong>캐쉬 메모리뿐 아니라 상대적으로 용량이 적은 빠른 저장 장치의 성능 향상을 위한 총체적 기법.</strong> 상대적으로 느린 저장 장치에 있는 내용 중 당장 사용되거나 빈번하게 사용될 정보를 빠른 저장 장치에 선별적으로 저장해두었다가 두 저장 장치의 속도를 완충시킨다.</p>
<hr>
<h2 id="프로그램의-구조"><a href="#프로그램의-구조" class="headerlink" title="프로그램의 구조"></a>프로그램의 구조</h2><p>컴퓨터 프로그램은 어떠한 프로그래밍 언어로 작성되었든 <strong>그 내부적인 구조는 함수들로 구성된다.</strong> 그리고 프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가 있어야 한다. 이 프로그램의 주소 영역은 다음과 같다.</p>
<ul>
<li>코드: 개발자가 작성한 프로그램 함수들의 코드가 기계어 명령으로 변환되어 저장된다.</li>
<li>데이터: 전역 변수 등 프로그램이 사용하는 데이터를 저장한다.</li>
<li>스택: 함수가 호출될 때, 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장한다.</li>
</ul>
<h2 id="프로그램의-실행"><a href="#프로그램의-실행" class="headerlink" title="프로그램의 실행"></a>프로그램의 실행</h2><ul>
<li>디스크에 존재하던 실행 파일이 메모리에 적재된다는 것을 의미한다.</li>
<li>프로그램이 CPU를 할당받고 기계 명령을 수행하고 있는 상태를 말한다.</li>
</ul>
<h3 id="사용자-프로그램이-사용하는-함수"><a href="#사용자-프로그램이-사용하는-함수" class="headerlink" title="사용자 프로그램이 사용하는 함수"></a>사용자 프로그램이 사용하는 함수</h3><ul>
<li>사용자 정의 함수: 프로그래머가 직접 작성한 함수</li>
<li>라이브러리 함수: 프로그래머가 직접 작성하진 않았지만 이미 누군가 작성해 놓은 함수를 호출만 하여 사용하는 경우</li>
<li>커널 함수: 운영 체제 커널의 코드에 정의된 함수. 시스템 콜 함수와 인터럽트 처리 함수가 있다.</li>
</ul>
<hr>
<p><em>References</em><br><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323" target="_blank" rel="noopener">운영체제</a><br>[운영 체제와 정보 기술의 원리] 반효경 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/05/15/220516_os1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/15/220516_os1/" class="post-title-link" itemprop="url">Operating Systems - Introduction to Operating Systems</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-16 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-16T00:00:00+09:00">2022-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-22 16:29:50" itemprop="dateModified" datetime="2022-06-22T16:29:50+09:00">2022-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Introduction-to-Operating-Systems"><a href="#Introduction-to-Operating-Systems" class="headerlink" title="Introduction to Operating Systems"></a>Introduction to Operating Systems</h1><p>컴퓨터 분야의 학문은 아래의 두 가지 분야로 나뉘지만 복잡도(complexity)가 매우 높은 문제를 다루고 있어서 방법론적인 차원에서는 크게 다르지 않다.</p>
<ul>
<li>컴퓨터 자체를 효율적으로 운영하기 위한 학문</li>
<li>복잡한 문제를 컴퓨터를 활용하여 효율적으로 풀 수 있는 방법을 제공하기 위한 방법</li>
</ul>
<p>컴퓨터가 일을 처리하는 방식은 정확한 처리 방식을 알고리즘이라는 형식을 통해 기술해 주어야 하고, 작업 내용의 복잡도가 매우 높아서 사람이 하는 것처럼 눈썰미나 직감으로 처리할 수 없다. 특히 데이터의 수가 많아질수록 효율적으로 작업을 수행할 수 있도록 하는 체계적인 방법이 필요하다. 그 체계적인 방법 중 하나가 <strong>컴퓨터 하드웨어와 스프트웨어를 총체적으로 관리하는 핵심 소프트웨어인 운영체제이다.</strong></p>
<h2 id="컴퓨터-및-정보-기술의-역사"><a href="#컴퓨터-및-정보-기술의-역사" class="headerlink" title="컴퓨터 및 정보 기술의 역사"></a>컴퓨터 및 정보 기술의 역사</h2><h3 id="1-이론적-기원"><a href="#1-이론적-기원" class="headerlink" title="1. 이론적 기원"></a>1. 이론적 기원</h3><p>수학과 논리학에서 컴퓨터의 이론적 기원을 찾아볼 수 있다. 어떠한 문제를 수학적인 모델로 표현하는 방법을 개발하고, 그 문제를 풀기 위한 알고리즘을 기술할 수 있는 컴퓨터에 대한 추상적인 모델을 설계했다. (e.g. 튜링 머신)</p>
<h3 id="2-기계식-컴퓨터"><a href="#2-기계식-컴퓨터" class="headerlink" title="2. 기계식 컴퓨터"></a>2. 기계식 컴퓨터</h3><p><strong>컴퓨터는 계산을 빠르게 하기 위해 개발되었다. 19세기 해석기관(analytic engine)는 프로그램이 가능한 최초의 기계식 컴퓨터이다.</strong> 베비지가 설계한 이 컴퓨터는 현대의 컴퓨터에서 발견되는 네 가지 기본 구성 요소인 입력 장치, 출력 장치, 처리 장치, 저장 장치를 포함하고 있다.</p>
<h3 id="3-전자식-컴퓨터"><a href="#3-전자식-컴퓨터" class="headerlink" title="3. 전자식 컴퓨터"></a>3. 전자식 컴퓨터</h3><p>20세기 초에 전자식 계산기가 등장하고, 이는 전자 장치에 의해 동작하는 본격적인 의미의 컴퓨터이다. ABC, Mark1, ENIAC 등이 만들어졌다. <strong>특히 ENIAC은 최초의 현대적 컴퓨터로 인식된다.</strong> 이를 기점으로 컴퓨터 역사의 경계를 나누기도 한다.</p>
<h3 id="4-근대적-컴퓨터"><a href="#4-근대적-컴퓨터" class="headerlink" title="4. 근대적 컴퓨터"></a>4. 근대적 컴퓨터</h3><p>근대로 넘어오면 변화가 매우 빨라져서 시대적 분류가 쉽지 않지만 1940년대 중빈부터 하드웨어 기술 발전을 토대로 대체로 1~4세대로 분류한다.</p>
<ul>
<li>1세대 컴퓨터: 1940년대 후반 시작된 <em>진공관 기반 컴퓨터</em></li>
<li>2세대 컴퓨터: 1950년대 후반 시작된 <em>트랜지스터 기반 컴퓨터</em></li>
<li>3세대 컴퓨터: 1960년대 후반 시작된 <em>직접회로 기반 컴퓨터</em></li>
<li>4세대 컴퓨터: 1970년대 중반 시작된 <em>LSI(Large Scale Integration), VLSI(Very Large Scale Integration) 기반 마이크로 컴퓨터</em></li>
</ul>
<p>2세대부터 소프트웨어의 발전이 크게 이루어지고, 컴퓨터의 사용이 확산되면서 프로그래밍의 필요성도 크게 증가한다. 그에 따라 기계어로 프로그래밍을 하는 불편함 때문에 사람이 프로그래밍 하기 수월한 언어의 필요성이 대두되었고, 어셈블리 언어가 등장한다. 그외 고급 언어인 포트란, 리습(Lisp) 언어, 코볼(Cobol) 등이 개발된다. 1960년대 이후에는 설계의 방법론이라 할 수 있는 소프트웨어 공학이 부각되면서 구조적 프로그래밍 기법이 부각된다. 또한 알골 60(Algol 60)이라는 언어가 등장했고, 운영 체제가 개발되기 시작한다. <em>그 이유는 초기에는 컴퓨터 외부에서 미리 예약해서 한꺼번에 처리하는 일괄 처리 방식(batch processing)을 사용했는데, 그것이 비효율적이기 때문에 컴퓨터 자체가 이런한 것을 자동적으로 처리해 주도록 하는 방식을 생각하여 운영 체제가 생겨났다.</em> 컴퓨터의 응용 분야로는 경영 자동화가 부각되면서 데이터베이스 관리 시스템(DBMS: DataBase Management System)도 등장한다. 1960년대 중반부터는 특히 반도체 기술의 빠른 발전으로 인해 컴퓨터 하드웨어에 큰 변화가 있었고, 1970년대에 들어서면서 하드웨어와 소프트웨어의 설계 방법론 측면이 크게 부각된다. 그 이유는 하드웨어가 반도체 기술의 발전과 그로 인한 직접 회로(IC)의 발전으로 상당한 성능 향상이 있었지만 소프트웨어쪽은 그다지 만족한 말한 발전을 이루지 못했기 때문이다. 하지만 이런 하드웨어의 고도화로 개인용 컴퓨터가 등장하고, 컴퓨터 네트워크에 대한 발전의 기초를 마련하게 된다. 이 시기에는 C언어가 개발되었다. 또한 마이크로프로세서가 직접회로를 더욱 고도화한 초고밀도 직접회로(VLSI)기술로 제작되면서 4세대 컴퓨터 시대를 열게 된다. 이 마이크로프로세서의 보급이 개인용 컴퓨터 혁명을 야기하여 1960년대 후반부터는 애플, 코모도, 탠디 등의 회사가 개인용 컴퓨터의 생산을 시작한다. 1980년대에 소프트웨어 방법론이 많이 등장하게 되고, 객체 지향 언어가 성공한다. 1990년대 초반부터는 컴퓨터가 사회 전반으로 뿌리내리게 되면서 인텔 펜티엄 프로세서, 윈도우 95, 월드 와이드 웹, 자바 등이 등장한다.</p>
<p>오늘날 현대의 컴퓨터는 규모에 따라 여러 가지로 나뉠 수 있는데, 보통 임의의 목적으로 사용될 수 있는 것을 <code>범용 컴퓨터</code>라고 부르고, 특수 목적을 위해 각종 장치의 제어용으로 내장되는 컴퓨터를 <code>임베디드 컴퓨터</code>라고 부른다.</p>
<h4 id="슈퍼-컴퓨터-메인-프레임-컴퓨터"><a href="#슈퍼-컴퓨터-메인-프레임-컴퓨터" class="headerlink" title="슈퍼 컴퓨터, 메인 프레임 컴퓨터"></a>슈퍼 컴퓨터, 메인 프레임 컴퓨터</h4><p>마이크로프로세서 등장 이전의 컴퓨터는 대부분 커다란 크기의 메인 프레임 컴퓨터였다.</p>
<ul>
<li>메인 프레임 컴퓨터: 일반적으로 터미널을 통해 접속한다. 시분항 방식(컴퓨터 처리 능력을 짧은 시간 단위로 구분하여 여러 사용자에게 조금씩 분할해서 서비스)을 사용한다.</li>
<li>슈퍼 컴퓨터: 메인 프레임 컴퓨터로 처리 능력이 부족한 응용 분야에 쓰인다. (e.g. 기상 예측, 통신망 설계, 석유 탐사 등) 복잡한 문제를 다루기 때문에 처리 능력이 메인 프레임 컴퓨터보다 뛰어나야 하기 때문에 슈퍼 컴퓨터 또는 고성능 컴퓨터라고도 부른다.</li>
</ul>
<h4 id="개인용-컴퓨터"><a href="#개인용-컴퓨터" class="headerlink" title="개인용 컴퓨터"></a>개인용 컴퓨터</h4><p>메인 프레임 컴퓨터를 사용하기에는 규모가 작은 연구실이나 사무실에서 쓰는 워크스테이션의 개념이 등장한다. 이는 10인 이내의 구성원이 공동으로 사용하기에 적절한 컴퓨터를 의미한다. 최근에는 개인용 컴퓨터의 성능이 좋아져서 워크스테이션과 개인용 컴퓨터의 격차가 많이 사라졌다.</p>
<h4 id="휴대용-컴퓨터"><a href="#휴대용-컴퓨터" class="headerlink" title="휴대용 컴퓨터"></a>휴대용 컴퓨터</h4><p>데스크탑 컴퓨터와 달리 휴대가 가능한 컴퓨터를 휴대용 컴퓨터라 하는데, 랩탑 컴퓨터가 있다. 랩탑보다 더 작은 사이즈의 스마트 폰도 있다.</p>
<h4 id="임베디드-컴퓨터"><a href="#임베디드-컴퓨터" class="headerlink" title="임베디드 컴퓨터"></a>임베디드 컴퓨터</h4><p>특수한 목적을 가지고 제작되는 컴퓨터로 각종 기기에 포함되어 그 기능을 향상시키거나 연산, 처리, 전달 등의 업무를 담당한다. 칩이 내부에 구워져 있어서 범용 컴퓨터와 같은 일반적인 방법으로 프로그램을 올릴 수 없다. 용도의 특수성으로 인해서 한번 기록된 프로그램이 수정될 일이 거의 없기 때문이다.</p>
<hr>
<h2 id="운영-체제-개요"><a href="#운영-체제-개요" class="headerlink" title="운영 체제 개요"></a>운영 체제 개요</h2><blockquote>
<p>운영체제: 컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어. 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층</p>
</blockquote>
<p>운영 체제가 없으면 컴퓨터는 고철 덩어리에 불가하다. 하드웨어가 운영 체제와 한 몸이 되어야만 사용자에게 쓰일 수 있는 진정한 컴퓨터 시스템이 된다. 사용자가 하드웨어 자체를 다루는 것이 쉽지 않으므로 하드웨어 위에 운영체제를 탑재하여 전원을 켰을 때 사용자가 손쉽게 사용할 수 있는 상태가 되도록 하는 것이다. 컴퓨터의 전원을 켜면 운영 체제도 켜지는 셈이다.</p>
<h3 id="운영-체제의-기능"><a href="#운영-체제의-기능" class="headerlink" title="운영 체제의 기능"></a>운영 체제의 기능</h3><ul>
<li><code>핵심 기능: 컴퓨터 시스템 내의 자원을 효율적으로 관리하여 가장 좋은 성능을 내도록 한다.</code><ul>
<li>자원의 효율적 관리가 매우 중요하기 때문에 자원 관리자(resource manager)라 부르기도 한다.</li>
<li>자원: CPU, 메모리, 하드 디스크, 프로세스, 파일, 메시지 등 하드웨어와 소프트웨어 자원을 통칭한다.</li>
<li>단, 효율성 추구로 인해 일부가 지나치게 희생되지 않도록 하는 <code>형평성</code>의 문제도 고려해야 한다.</li>
<li><em>(사용자 -&gt; 프로그램 -&gt; 추상화된 컴퓨터(Abstract Machine) -&gt; <code>운영체제(에 의한 자원공유)</code> -&gt; 물리적인 컴퓨터 -&gt; 결과(Result))</em></li>
</ul>
</li>
<li>컴퓨터 시스템을 편리하게 사용할 수 있는 환경 제공<ul>
<li>운영 체제가 동시 사용자 및 프로그램들에게 각각 독자적으로 컴퓨터를 사용하는 것과 같은 환상을 제공한다.</li>
<li>하드웨어를 직접 다루는 복잡한 부분을 운영 체제가 대행하고, 사용자 및 프로그램은 이에 대해 자세한 내용은 알지 못해도 프로그램을 계속 수행할 수 있다. <em>(사용자 -&gt; 프로그램 -&gt; 추상화된 컴퓨터(Abstract Machine) -&gt; 물리적인 컴퓨터 -&gt; 결과(Result))</em></li>
</ul>
</li>
<li>사용자와 운영체제 자신을 보호</li>
</ul>
<h3 id="운영-체제의-분류"><a href="#운영-체제의-분류" class="headerlink" title="운영 체제의 분류"></a>운영 체제의 분류</h3><h4 id="1-동시-작업을-진행하는-지-여부에-따라-분류한다"><a href="#1-동시-작업을-진행하는-지-여부에-따라-분류한다" class="headerlink" title="1. 동시 작업을 진행하는 지 여부에 따라 분류한다."></a>1. <code>동시 작업을 진행하는 지</code> 여부에 따라 분류한다.</h4><ul>
<li>단일 작업용 운영 체제: 한 번에 하나의 프로그램만 수행시킨다.</li>
<li>다중 작업: 동시에 두 개 이상의 프로그램을 처리할 수 있다.</li>
</ul>
<p>다중 작업용 운영 체제의 개념은 잘 구분해서 정리해야 한다. 운영 체제가 다중 작업을 처리할 때 여러 프로그램이 CPU와 메모리를 공유하는 데, 일반적으로 <em>컴퓨터에는 CPU가 하나 밖에 없다. 따라서 다중 작업용 운영 체제라도 CPU에서는 <code>매 순간 하나</code>의 프로그램만 수행된다.</em></p>
<ul>
<li>시분할 시스템(time sharing system): CPU에서 수 밀리 세컨드(ms)이내에 여러 프로그램들이 번갈아가면서 수행된다. 따라서 사용자는 여러 프로그램이 동시에 수행되는 것처럼 느끼게 된다.</li>
<li>다중 프로그래밍 시스템(multi-programming system): 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리한다. 대화형 시스템(interactive system)이라고도 부른다.</li>
</ul>
<p>다중 작업, 시분할, 다중 프로그래밍은 모두 <code>여러 프로그램이 하나의 컴퓨터에서 동시에 수행된다.</code> 요즘의 운영체제는 대게 이러한 방식이다.</p>
<ul>
<li>다중처리기 시스템(multi-processor system): 하나의 컴퓨터 안에 CPU가 여러 개 설치된 경우를 말한다.</li>
</ul>
<h4 id="2-다중-사용자의-동시-지원-여부-사용자의-수에-따른-분류"><a href="#2-다중-사용자의-동시-지원-여부-사용자의-수에-따른-분류" class="headerlink" title="2. 다중 사용자의 동시 지원 여부 (사용자의 수에 따른 분류)"></a>2. <code>다중 사용자</code>의 동시 지원 여부 (사용자의 수에 따른 분류)</h4><ul>
<li>단일 사용자용 운영 체제: <code>한 번에 한 명의 사용자</code>만이 사용하도록 허용한다. e.g. MS_DOS, MS windows</li>
<li>다중 사용자용 운영 체제: 여러 사용자가 동시에 접속해 사용할 수 있게 한다. e.g. UNIX, NT server</li>
</ul>
<h4 id="3-작업-처리-방식에-따른-분류"><a href="#3-작업-처리-방식에-따른-분류" class="headerlink" title="3. 작업 처리 방식에 따른 분류"></a>3. <code>작업 처리 방식</code>에 따른 분류</h4><ul>
<li>일괄 처리 방식(batch processing): 작업 요청의 일정량을 <code>모아서 한꺼번에 처리</code>한다. e.g. 펀치카드</li>
<li>시분할 방식(time sharing): 여러 작업을 수행할 때 컴퓨터의 처리 능력을 일정한 시간 단위로 분할하여 사용한다. e.g. UNIX</li>
<li>실시간 운영 체제(real time): 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 한다. e.g. 원자로, 공장 제어 시스템, 미사일 제어 시스템 등</li>
</ul>
<hr>
<h2 id="운영-체제의-자원-관리-기능"><a href="#운영-체제의-자원-관리-기능" class="headerlink" title="운영 체제의 자원 관리 기능"></a>운영 체제의 자원 관리 기능</h2><blockquote>
<p>운영 체제의 가장 핵심적인 기능은 자원을 효율적으로 관리. 자원은 CPU, 메모리 등을 비롯한 주변 장치 및 입출력 장치 등의 <code>하드웨어 자원</code>과 <code>소프트웨어 자원</code>으로 나뉜다.</p>
</blockquote>
<h3 id="하드웨어-자원-관리"><a href="#하드웨어-자원-관리" class="headerlink" title="하드웨어 자원 관리"></a>하드웨어 자원 관리</h3><ul>
<li><code>CPU 스케줄링</code>: <em>어떤 프로그램에게 CPU를 줄 것인가?</em> CPU는 하나이기 때문에 매 시점 어떤 프로세스가 CPU를 할당해 작업을 처리할지 결정해야 한다.<ul>
<li><code>선입 선출 기법</code>: 먼저 CPU를 사용하기 위해 도착한 프로세스를 먼저 처리해준다. e.g. 줄서기</li>
<li><code>라운드 로빈 기법</code>: CPU를 한 번 할당받아 사용할 수 있는 시간을 일정한 고정된 시간으로 제한한다. 긴 작업을 요하는 프로세스가 CPU를 할당 받더라도 정해진 시간이 지나면 CPU를 내어놓아야 한다. 선입 선출 기법이 장시간 처리가 필요한 프로세스가 처리 될 동안 다른 프로세스들은 장시간 처리가 끝날때까지 기다려야 해서 전체 시스템상의 비효율이 발생하기 때문에 이를 보완하기 위한 방법으로 고안되었다.</li>
<li><code>우선 순위 스케줄링</code>: 수행 대기중인 프로세스들에게 우선순위를 부여하여 우선순위가 높은 프로세스에게 CPU를 먼저 할당한다.</li>
</ul>
</li>
<li><code>파일 관리</code>: <em>디스크에 파일을 어떻게 보관할 것인가?</em> CPU, 메모리는 전원이 꺼지면 처리중이던 정보가 모두 꺼지므로 전원이 꺼져도 기억이 필요한 부분은 보조 기억 장치에 파일 형태로 저장한다. 이 파일들이 저장되는 방식 및 접근 권한 등을 OS가 관리해주어야 한다.</li>
<li><code>입출력 관리</code>: <em>각기 다른 입출력 장치와 컴퓨터 간에 어떻게 정보를 주고 받을 것인가?</em> 키보드, 모니터, 하드 디스크 등<ul>
<li><code>인터럽트</code>: 주변 장치들이 CPU의 서비스가 필요한 경우 신호를 발생시켜 서비스를 요청하는데 이 신호를 인터럽트라고 한다. 그러면 CPU는 하던 작업을 멈추고 인터럽트가 요청한 서비스를 수행한다.</li>
<li><code>컨트롤러</code>: 주변 장치들이 각 장치마다 해당 장치에서 일어나는 업무에 대한 관리를 위한 일종의 작은 CPU를 가지고 있는데, 이를 컨트롤러라고 한다. 해당 장치에 대한 업무를 처리하고, 메인 CPU에 인터럽트를 발생시켜 보고하는 역할을 한다.</li>
</ul>
</li>
<li><code>메모리 관리</code>: <em>한정된 메모리를 어떻게 나누어 사용할 것인가?</em> 메모리의 어느 부분이 어떤 프로그램에 의해 사용되고 있는지를 주소(address)를 통해 관리하고, 메모리가 필요할 때 할당하고, 그렇지 않을 때 회수한다.<ul>
<li><code>고정 분할 방식</code>: 물리적 메모리를 <code>몇 개의 영구적인 분할</code>로 나눈다. 동시에 메모리에 적재되는 최대 프로그램의 수가 분할 개수로 한정되어 융통성이 없다는 단점이 있고, 분할의 크기보다 큰 프로그램은 적재가 불가하다.<ul>
<li><code>내부 조각</code>: 분할의 크기보다 작은 프로그램이 적재되었을 때 남는 영역을 말한다. 사용되지 않는 비효율적인 공간이다.</li>
</ul>
</li>
<li><code>가변 분할 방식</code>: 매 시점 <code>프로그램의 크기에 맞게 메모리를 분할</code>한다.(분할의 크기, 개수에 따른 동적인 분할) 물리적 메모리 크기보다 더 큰 프로그램은 적재가 불가하다.<ul>
<li><code>외부 조각</code>: 프로그램에게 할당되지 않은 메모리 영역인데, 크기가 작아서 프로그램을 올리지 못하는 메모리 영억. 사용되지 않는 비효율적인 공간이다.</li>
</ul>
</li>
<li><code>가상 메모리 방식</code>: 최근의 거의 모든 컴퓨터 시스템에서 사용한다. <em>물리적 프로그램보다 더 큰 프로그램의 실행을 지원한다.</em> 모든 프로그램은 물리적 메모리와 독립적인 주소가 0부터 시작하는 자신만의 가상 메모리를 갖는다. OS는 가상 메모리의 주소를 물리적 메모리 주소로 매핑하는 기술을 이용해서 주소를 변환시켜서 프로그램을 물리적 메모리에 올린다. 따라서 실행될 수 있는 프로그램의 크기는 가상 메모리 크기에 의해 결정된다.<ul>
<li><code>스왑 영역(swap area)</code>: 현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드 디스크와 같은 보조 장치에 저장했다가 필요할 때 적재하는 방식으로 이때 사용되는 보조 기억 장치의 영역이 스왑 영역이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><em>References</em><br><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323" target="_blank" rel="noopener">운영체제</a><br>[운영 체제와 정보 기술의 원리] 반효경 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/05/09/220510_promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/09/220510_promise/" class="post-title-link" itemprop="url">자바스크립트의 프로미스</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-10 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-10T00:00:00+09:00">2022-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-22 16:29:50" itemprop="dateModified" datetime="2022-06-22T16:29:50+09:00">2022-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>자바스크립트의 비동기성을 표현하는 기본 단위로써 콜백이 있는데, 콜백은 순차성과 믿음성이 결여되는 문제점이 있었다. 특히 콜백이 가진 제어의 역전은 실행 흐름을 서드 파티에 의존해야 하기 때문에 요청을 보내면 그 요청이 잘되기를 바라는 방법이 최선이었다. 이런 문제점을 보완하고 좀 더 나은 방법으로 비동기 처리를 할 수 있는 방법으로 <code>프로미스</code>가 등장하게 되는데, <code>제어의 되역전</code>을 아이디어로 삼는다. <strong>즉 실행 흐름을 서드 파티와 같은 다른 파트에 넘겨주지 않고도 개발자가 작업의 실행 결과와 다음 task에 대해 제어할 수 있는 것이다.</strong></p>
<h2 id="프로미스의-미랫값-지금값-나중값"><a href="#프로미스의-미랫값-지금값-나중값" class="headerlink" title="프로미스의 미랫값, 지금값, 나중값"></a>프로미스의 미랫값, 지금값, 나중값</h2><p><strong><code>미랫값</code>은 <code>시간 독립적인 값(Time Independent)</code>이다.</strong> 시간의 흐름과 상관없이 미래에 성공 또는 실패로 귀결되는 값이다. 이 미랫값은 원래 내가 가지고 있던 값 자체와 교환된다. 미랫값이 성공이면 나는 언제가 되었든 반드시 원래 가지고 있던 값을 받게 되고, 실패이면 값을 받지 못한다. 그리고 이러한 미랫값을 다루는 방법이 콜백이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">getX, getY, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x, y;</span><br><span class="line"></span><br><span class="line">  getX(<span class="function"><span class="keyword">function</span> (<span class="params">xVal</span>) </span>&#123;</span><br><span class="line">    x = xVal;</span><br><span class="line">    <span class="comment">//둘 다 준비됐나?</span></span><br><span class="line">    <span class="keyword">if</span> (y != <span class="literal">undefined</span>) &#123;</span><br><span class="line">      cb(x + y); <span class="comment">//더해서 보내</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  getY(<span class="function"><span class="keyword">function</span> (<span class="params">yVal</span>) </span>&#123;</span><br><span class="line">    y = yVal;</span><br><span class="line">    <span class="comment">//둘 다 준비됐나?</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">undefined</span>) &#123;</span><br><span class="line">      cb(x + y); <span class="comment">//더해서 보내</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fetchX()와 fetchY()는 동기/비동기 함수</span></span><br><span class="line">add(fetchX, fetchY, <span class="function"><span class="keyword">function</span> (<span class="params">sum</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sum); <span class="comment">//너무 쉽지?</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>위의 코드가 비동기 패턴이 아니라 일반 함수라고 가정해보자면, x,y의 값은 <code>지금</code>존재하는 구체적인 값이라는 가정 하에 연산이 진행될 것이다. 아래 예시를 통해 지금값에 대해 보충해 보겠다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">var</span> x,</span><br><span class="line">  y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x + y); <span class="comment">//NaN &lt;- x는 아직 세팅 전이다.</span></span><br></pre></td></tr></table></figure>
<p>이 2️⃣번 예시는 비동기 패턴이 아닌 일반적인 계산 로직을 담고 있는 코드이다. 이 로직에서 x + y 가 연산되는 시점에서 코드는 x, y가 <code>지금</code> 존재하고 있는, 귀결(Resolved)된 값이라고 생각하고 연산이 이루어진다. 그렇기 때문에 x는 아직 할당 전이어서 실질적인 값은 undefined인데 지금 값이 존재한다고 가정되어 undefined + 2로 계산이 되어 NaN이라는 결과를 얻은 것이다.</p>
<p>만약 이 함수에서 x, y의 값을 연산할 때 <code>지금</code> 둘 중 하나라도 준비가 덜 됐으면 될 때까지 기다렸다가 <code>나중</code>에 값을 얻었을 때 연산을 진행한다고 가정해보자. 즉 코드에서 x, y를 <code>지금</code> 존재하는 귀결된 값이라고 가정하는 것이 아니라 <strong>미래에 실패 또는 성공할 값이라고 가정하고 연산을 진행하는 것이다.</strong> 그렇다면 결과값은 두 가지 값 모두 순조롭게 할당이 완료되어 성공적으로 정상적인 값을 출력하거나, <code>나중</code>까지 기다렸는데도 정상적인 값이 할당되지 않아 undefined + 2로 계산된 것처럼 정상적인 결과를 출력하는데 실패하게 될 것이다. 그래서 x, y의 구체적인 연산 결과는 당장 예측할 수 없지만 그 값이 미래에 반드시 성공 또는 실패될 것이라는 사실을 예측할 수 있게 된다.</p>
<p>다시 돌아와서 1️⃣번 예제의 비동기 패턴을 살펴보자. <em>비동기 프로그래밍의 핵심은 <code>지금</code>에 해당하는 부분과 <code>나중</code>에 해당하는 부분 사이의 관계라고 하였다.</em> 1️⃣번 예제에서 <code>지금</code>부터 <code>나중</code>까지 기다리는 최적의 방법으로 <code>콜백 함수</code>를 사용한다. 위에 설명했던 것처럼 지금 값이 귀결되어 있는지와 상관없이 일단 add() 함수를 호출하여 작성된 로직을 수행한다. add() 함수 내부의 x, y는 add()입장에서 실행되는 지금 시점에서 값이 준비되어 있는지 아닌지는 관심 밖이다. 여기서 <strong>x,y는 미랫값으로 취급된다.</strong> 따라서 그 값이 어떤 것인지와 상관없이 add()의 결과는 성공 또는 실패 일 것이라고 예측할 수 있게 된다.즉 x,y의 값이 <code>지금</code> 존재하는 값일 수도 있고, 나중에 값을 얻게 될 수도 있는데, 여기서는 <code>지금</code>과 <code>나중</code>의 어떤 때라도 결과론적으로 똑같이 일관적으로 동작할 수 있게 하기 위해서 이 두 가지 모두를 <code>나중</code>으로 만들어서 모든 작업을 나중에 얻게 될 성공 또는 실패의 값으로 비동기화시킨 것이다.</p>
<p><em>정리하자면 어떤 로직을 수행할 때, 값이 지금 존재하는지를 알기 여려운 경우, 해당 값을 지금 값이 존재하는지, 미래에 어느 시점에 존재하는 값으로 바뀌는지는 알 수 없지만 값 자체를 <code>나중</code>에 언젠가는 존재할 값이라는 가정 하에 로직을 수행하고, <code>나중</code>에 그 값을 얻게 되면, 그 값은 구체적으로 로직의 연산 결과를 반환하는 값은 아니지만 반드시 성공 또는 실패한 값이다.</em></p>
<p>이 개념을 기억하며 프로미스 함수를 좀 더 자세히 살펴보자. 위 예제의 x + y를 프로미스 함수로 나타낸 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">xPromise, yPromise</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([xPromise, yPromise]).then(<span class="function"><span class="keyword">function</span> (<span class="params">values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> values[<span class="number">0</span>] + values[<span class="number">1</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(fetchX(), fetchY()).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">sum</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>Promise.all([])은 프로미스 배열을 인자로 받아서 프로미스가 모두 귀결될 때까지 기다렸다가 새 프로미스를 만들어 반환한다. 그리고 프로미스가 귀결되면 X와 Y 값을 받아 더하고, then에서 파라미터로 전달받은 values는 앞에서 귀결된 프로미스가 전달해 준 메시지 배열이다. 그리고 fetchX()와 fetchY()는 제각기 값을 가진 프로미스를 반환하는데, 지금 또는 나중에 준비된다. add()의 결과로 두 숫자의 합이 담긴 프로미스를 받으면 이제 반환된 프로미스가 귀결될 때까지 대기하기 위해 then()을 연쇄 호출한다.</p>
<p>위 예제에는 두 개의 프로미스 계층이 있다. 먼저 두 프로미스 fetchX()와 fetchY()를 호출하여 반환된 값은 add()에 전달된다. 프로미스 속의 원래 값은 지금 또는 나중에 준비되는데 그 시점과는 상관없이 각 프로미스가 같은 결과를 내게끔 정규화하고, <strong>미랫값 X,Y는 시간 독립적으로 추론이 가능하다.</strong> 그리고 그 다음 프로미스 계층은 add()가 Promise.all을 거쳐 반환한 프로미스인데, then()을 호출하고 대기한다. add()가 끝나면 덧셈을 마친 미랫값이 콘솔에 출력된다.</p>
<p><strong>이렇게 프로미스는 <code>Fulfillment</code> 또는 <code>Rejection</code>으로 귀결될 수 있다.</strong> 여기서 Fulfillment는 항상 프로그램이 귀결값을 결정짓고, Rejection은 프로그램 로직에 따라 직접 세팅되거나 런타임 예외에 의해 암시적으로 생겨난다.</p>
<p>그리고 프로미스 then() 함수는 Fulfillment 함수를 첫 번째 인자로, Rejection 함수를 두 번째 인자로 넘겨받는다. 그렇기 때문에 X나 Y의 조회 시 문제가 있거나 연산에 실패하면 add()가 반환하는 프로미스는 버려지고, then()의 두 번째 에러 처리 콜백이 이 프로미스에서 Rejection을 받는다.</p>
<p>요약해보자면 프로미스는 시간 의존적인 상태를 외부로부터 캡슐화하기 때문에 타이밍 또는 내부 결과값에 상관없이 예측 가능한 방향으로 조합할 수 있다. 또 프로미스는 일단 귀결되면 그 상태가 그대로 유지되는 불변값이다.</p>
<h2 id="프로미스"><a href="#프로미스" class="headerlink" title="프로미스"></a>프로미스</h2><blockquote>
<p>프로미스 객체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값이다.</p>
</blockquote>
<p>위에서 보았던 여러 예제를 통해 프로미스의 성격에 대해 알아보았다. 프로미스에서는 미랫값이라는 개념이 중요했다. 미랫값은 지금 당장은 값은 알 수 없고, 어느 시점에 그 값이 확정되는지 알 수 없지만 성공 또는 실패일 것으로 추론할 수 있는 값이었다. 프로미스는 이처럼 지금 당장 실행하는 시점에서 아직 알려지지 않을 수도 있는 값을 위한 대리자이고, 미랫값 개념을 콜백으로 다루는데, 비동기 연산이 종료된 이후에 결과 값과 실패 사유를 처리하기 위한 처리기를 연결할 수 있다. 그래서 프로미스를 사용하면 비동기 메서드에서 마치 동기 메서드처럼 값을 반환할 수 있다. 다만 최종 결과를 반환하는 것이 아니고, <code>미래의 어떤 시점에 결과를 제공하겠다는 &#39;약속&#39;(프로미스)을 반환한다.</code></p>
<p>그래서 프로미스는 다음 중 하나의 상태를 가진다.</p>
<ul>
<li>대기(pending): 이행하지도, 거부하지도 않은 초기 상태.</li>
<li>이행(Fulfillment): 연산이 성공적으로 완료됨.</li>
<li>거부(Rejection): 연산이 실패함.</li>
</ul>
<p>Promise가 생성된 시점에 대기 중인 프로미스 값은 성공적으로 이행(Fulfillment)이 되어서 위 예제에서 처럼 X + Y의 값을 얻을 수도 있고, 오류와 같은 이유로 인해 이행이 불가하여 거부(Rejection)될 수도 있다. 그리고 프로미스가 이행이나 거부로 귀결되면 then 메서드에 의해서 처리기들이 호출된다. 이 프로미스는 시간 의존적인 상태를 외부로부터 캡슐화하기 때문에 <strong>프로미스 자체는 시간 독립적이고,</strong> 따라서 언젠가 이행(Fulfillment)되거나 거부(Rejection)될 것을 예측하여 로직을 구성할 수 있다.</p>
<h2 id="프로미스의-완료-이벤트"><a href="#프로미스의-완료-이벤트" class="headerlink" title="프로미스의 완료 이벤트"></a>프로미스의 완료 이벤트</h2><blockquote>
<p>프로미스는 각각 미래값으로서 작동하지만 <em>프로미스의 귀결은 비동기 작업의 여러 단계를 흐름 제어하기 위한 체계이다.</em></p>
</blockquote>
<p>어떤 일을 하는 foo()라는 함수를 호출한다고 했을 때,</p>
<ul>
<li>전통적인 자바스크립트 사고 방식 :알림 자체를 하나의 이벤트로 보고 리스닝하고, foo()의 완료 이벤트를 리스닝함으로써 알림 요건을 재구성한다.</li>
<li>콜백에 : foo()에서 넘겨준 콜백을 호출하면 성립된다.</li>
<li>프로미스에서 : foo()에서 이벤트를 리스닝하고 있다가 알림을 받게 되면 다음으로 진행한다.</li>
</ul>
<p>아래는 프로미스의 예제이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo(x) &#123;</span><br><span class="line">  <span class="comment">//뭔가 시간이 제법 걸리는 일을 한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">on(foo <span class="string">"완료"</span>) &#123;</span><br><span class="line">  <span class="comment">// 이제 다음 단계로 갈 수 있다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">on(foo <span class="string">"에러"</span>) &#123;</span><br><span class="line">  <span class="comment">//어랏, foo()에서 뭔가 잘못됐다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foo()를 호출한 뒤에 완료, 에러 이벤트를 각각 리스닝하는 이벤트 리스너를 설정했다. foo()를 호출하면 foo()에서 이벤트를 받아 어떻게 처리하는지를 신경쓰지 않아도 되고, foo()의 결과는 완료 아니면 에러인 <code>관심사의 분리</code>가 된다.</p>
<p>이러한 코드는 사실상 일반적으로 콜백이 지향하는 코드와 정반대이다. 아래 예제를 보면 foo()에 콜백 함수를 넘겨주는 대신 <em>foo()가 이벤트 구독기를 반환하고 여기에 콜백 함수를 넣는다.</em> 이처럼 콜백 패턴을 뒤집는다는 것은 사실상 <code>제어의 되역전</code>으로 서드파티와 같은 다른 파트에 주었던 실행 흐름의 제어권을 호출부에 되돌려 둔 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//뭔가 시간이 제법 걸리는 일을 시작한다.</span></span><br><span class="line">  <span class="comment">//이벤트 구독기를 생성하여 반환한다.</span></span><br><span class="line">  <span class="keyword">return</span> listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> evt = foo(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">evt.on(<span class="string">'completion'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//이제 다음 단계로 갈 수 있다.</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">evt.on(<span class="string">'failure'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//어랏, foo()에서 뭔가 잘못됐다.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>이 <code>제어의 되역전</code>으로 인해 이제 관심사를 분리할 수 있게 된다. 아래와 같은 코드가 있으면 bar()나 baz()는 foo()가 호출되어 처리되는 것에 신경 쓸 필요 없고, foo()도 마찬가지로 누군가 자신을 기다리고 있다는 사실을 몰라도 된다. 이렇게 분리된 관심사 간에 중재자 역할을 evt가 하는 것이고, 이것이 프로미스와 매우 유사하다. 프로미스식으로 아래 코드를 다시 작성한다면 foo()는 프로미스 인스턴스를 생성해서 반환하고, 이 프로미스를 bar()와 baz()에 전달할 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = foo(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//bar()는 foo()의 완료 이벤트를 리스닝한다.</span></span><br><span class="line">bar(evt);</span><br><span class="line"><span class="comment">//baz()는 foo()의 완료 이벤트를 리스닝한다.</span></span><br><span class="line">baz(evt;)</span><br></pre></td></tr></table></figure>
<hr>
<p><em>References</em><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a><br>[YOU DON’T KNOW JS] 카일 심슨 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/05/08/220509_asynchronous/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/08/220509_asynchronous/" class="post-title-link" itemprop="url">자바스크립트의 비동기성</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-09 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-09T00:00:00+09:00">2022-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-22 16:29:50" itemprop="dateModified" datetime="2022-06-22T16:29:50+09:00">2022-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>자바스립트는 동기적이다. <strong>동기적이라는 말은 자바스크립트가 싱글 스레드이기 때문에 한 번에 한 가지 task만 수행할 수 있다는 의미이다.</strong> 즉, 어떤 task1이 실행되면 이 task의 처리가 끝나기 전까지 다음 task인 task2는 실행되지 못하고, task1이 끝날 때까지 기다려야 한다. 그런데 브라우저 환경에서 task가 동기적으로 차리되면 예를 들어 서버에 요청한 후 어떤 결과값을 받아서 화면에 렌더링하는 task가 있다고 했을 때, 서버에서 요청이 언제 돌아올지 모르는 상태로 마냥 기다려야 하는데, 이 사이에 사용자가 보는 웹 브라우저 화면은 빈 화면인 상태 또는 task가 수행되기 이전의 상태에 머물러 있게 된다. 이런 문제 때문에 <strong>브라우저 환경에서 자바스크립트는 비동기적으로 실행된다.</strong> 정확히 말하자면 자바스크립트가 비동기적인 것이 아니라 브라우저가 비동기 처리를 이용하여 task를 마치 동시에 처리되는 것처럼 처리하고, <strong>이러한 비동기 처리를 돕는 것은 이벤트 루프이다.</strong></p>
<p><em>그렇다면 자바스크립트에서 말하는 비동기 프로그래밍의 개념에 대해 조금 더 상세히 살펴보겠다.</em></p>
<blockquote>
<p>비동기 프로그래밍의 핵심은 <code>지금</code>에 해당하는 부분, <code>나중</code>에 해당하는 부분 사이의 관계 또는 간극이다.</p>
</blockquote>
<h2 id="비동기성을-이해하기-위한-배경-지식"><a href="#비동기성을-이해하기-위한-배경-지식" class="headerlink" title="비동기성을 이해하기 위한 배경 지식"></a>비동기성을 이해하기 위한 배경 지식</h2><p>자바스크립트에서 프로그램은 여러 개의 chunk로 구성된다.</p>
<ol>
<li><code>지금</code> 실행 중인 프로그램 chunk</li>
<li><code>나중에</code> 실행 할 프로그램 chunk</li>
</ol>
<p>여기서 <code>나중</code>은 <code>지금</code>의 직후가 아니며, <code>지금</code> 끝낼 수 없는 작업은 비동기적으로 처리되기 때문에 프로그램을 중단하지 않는다. AJAX를 예로 들자면 이 함수는 비동기적으로 어떠한 task를 <code>지금</code> 요청하고 <code>나중</code>에 결과를 받고, <code>지금</code>부터 <code>나중</code>까지 기다리는 최적의 방법은 <code>콜백 함수</code>를 이용하는 것이다.</p>
<h3 id="이벤트-루프"><a href="#이벤트-루프" class="headerlink" title="이벤트 루프"></a>이벤트 루프</h3><p><strong>앞서 말했지만 자바스크립트는 동기적이라서 주어진 요청(task)가 주어지면 주어진대로 순서대로 처리할 뿐이다.</strong> 자바스크립트 엔진은 웹 브라우저와 같은 호스팅 환경에서 실행되는데, 이벤트 루프가 여러 프로그램 chunk를 시간에 따라 매 순간 한 번씩 엔진을 실행시키도록 한다. 즉 자바스크립트 엔진이 동기적으로 코드를 실행할 때 AJAX, 콜백함수와 같이 비동기 처리 함수가 있다면 브라우저 환경이 이벤트 루프를 통해 실행을 스케줄링 하는 것이다. 이 스케줄링이 비동기적으로 처리되기 때문에 자바스크립트 자체는 동기적이지만 브라우저 환경에서의 실행 스케줄링은 비동기적이라고 할 수 있다. 구현방식을 단순화해서 구현하면 다음과 같다.</p>
<p><strong>while문의 무한 루프에서 매 순회를 틱이라 하는데, 한 번 틱이 발생할 때, 큐에 있는 이벤트(콜백 함수)를 선입 선출하여 실행한다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eventLoop는 큐(선입, 선출) 역할을 하는 배열</span></span><br><span class="line"><span class="keyword">var</span> eventLoop = [];</span><br><span class="line"><span class="keyword">var</span> event;</span><br><span class="line"></span><br><span class="line"><span class="comment">//'무한'실행</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">//'틱' 발생 (틱: 이벤트 루프를 한 차례 순회하는 것)</span></span><br><span class="line">  <span class="keyword">if</span> (eventLoop.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//큐에 있는 다음 이벤트 조회</span></span><br><span class="line">    event = eventLoop.shift();</span><br><span class="line">    <span class="comment">//이제 다음 이벤트 실행</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      event();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reportError(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="싱글-스레드-vs-병렬-스레드"><a href="#싱글-스레드-vs-병렬-스레드" class="headerlink" title="싱글 스레드 vs 병렬 스레드"></a>싱글 스레드 vs 병렬 스레드</h3><p>자바스크립트의 비동기 처리에 대해서 설명할 때 종종 병렬과 혼용하여 사용하는데, 둘은 완전히 다른 개념이다.</p>
<ul>
<li>비동기 : <code>지금</code>과 <code>나중</code> 사이의 간극에 관함</li>
<li>병렬: <code>동시</code>에 일어나는 일에 관함</li>
</ul>
<p>자바스크립트는 하나의 프로그램에서 여러 스레드를 처리하는 병렬 시스템이 아니라 <strong>절대로 스레드 간에 데이터를 공유하지 않는 단일 스레드 환경이다.</strong> 그리고 단일 스레드이기 때문에 완전-실행(Run-to-Completion)된다. 즉 함수가 2개 있다면 첫 번째 함수의 전체 코드가 다 실행된 후, 다음 함수가 실행된다. 그리고 두 함수가 있다면 이 함수는 순서에 따른 비결정성을 가진다. 이를 경합 조건(Race Condition)이라 한다.</p>
<h3 id="동시성"><a href="#동시성" class="headerlink" title="동시성"></a>동시성</h3><p>복수의 프로세스가 같은 시간 동안 동시에 실행된다. 앞서 말했듯이 자바스크립트는 병렬 스레드가 아니므로 여기서 말하는 동시성은 <strong>각 프로세스 작업(개별 프로세스의 스레드)이 병렬로 처리되는지와 관계된 것이 아닌, 프로세스 수준(작업 수준)의 병행성을 말한다.</strong> 단 프로세스 1과 프로세스 2가 있다면 이들은 동시에 실행되지만 이들을 구성하는 이벤트들은 이벤트 루프 큐에서 차례대로 실행된다.</p>
<h3 id="상호작용-vs-비상호-작용"><a href="#상호작용-vs-비상호-작용" class="headerlink" title="상호작용 vs 비상호 작용"></a>상호작용 vs 비상호 작용</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">  res.foo = results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">  res.bar = results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ajax()는 라이브러리에 있는 임의의 AJAX 함수</span></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, foo);</span><br><span class="line">ajax(<span class="string">'http://some.url.2'</span>, bar);</span><br></pre></td></tr></table></figure>
<p>위 코드에서 복수의 프로세스 foo(), bar()가 동시에 실행될 때, 누가 먼저 실행될 지는 알 수 없지만 이들 프로세스 사이에 연관된 작업이 없기 때문에 프로세스간 상호작용이 일어나지 않는다. 이런 경우에 실행 순서가 문제되지 않는다. <em>즉 경합 조건이 문제시 되지 않는다.</em> 하지만 상호 작용하는 상황이라면 이야기는 달라진다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  res.push(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ajax()는 라이브러리에 있는 임의의 AJAX 함수</span></span><br><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, response);</span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.2'</span>, response);</span><br></pre></td></tr></table></figure>
<p>위의 코드는 상호 작용이 발생하는 프로세스이다. 1️⃣과 2️⃣의 프로세스는 모두 AJAX 응답에 대한 처리를 하는 response() 함수를 호출하기 때문에 선발 순으로 처리된다. 이 코드가 프로그램 개발자가 ‘<a href="http://some.url.1&#39;의" target="_blank" rel="noopener">http://some.url.1&#39;의</a> 결과를 res[0]에, ‘<a href="http://some.url.2&#39;,의" target="_blank" rel="noopener">http://some.url.2&#39;,의</a> 결과를 res[1]에 넣고자 의도한 코드라고 했을 때, 의도한 대로 동작할 수 있지만 어느쪽 URL의 응답이 먼저 도착할지 보장되지 않기 때문에 만약 예측한 대로 응답이 도착하지 않을 경우 결과가 뒤집힐 수 있다. 이런 경합 조건을 해결하려면 상호 작용의 순서를 잘 조정해야 한다. <em>특히 동시 프로세스들이 스코프나 DOM을 통해 간접적으로 상호작용하기 때문에 순서 조정이 아주 중요하다. DOM을 조작하는 코드의 경우 순서 조정이 제대로 이루어지지 않으면 처리가 덜 된 DOM 요소를 화면에 보여주게 될 수도 있다.</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data.url == <span class="string">'http://some.url.1'</span>) &#123;</span><br><span class="line">    res[<span class="number">0</span>] = data;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.url == <span class="string">'http://some.url.2'</span>) &#123;</span><br><span class="line">    res[<span class="number">1</span>] = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ajax()는 라이브러리에 있는 임의의 AJAX 함수</span></span><br><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, response);</span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.2'</span>, response);</span><br></pre></td></tr></table></figure>
<p>위와 같이 작성하게 되면 어느 쪽에 응답이 먼저 오더라도 data.url을 보고 해당하는 결과를 res[0] 또는 res[1]에 담을 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  a = x * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">    baz();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  b = y * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">    baz();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ajax()는 라이브러리에 있는 임의의 AJAX 함수</span></span><br><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, foo);</span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.2'</span>, bar);</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 <code>if (a &amp;&amp; b) { baz() }</code>의 조건은 관문(Gate)라 부른다. <em>a와 b 둘 중 누가 먼저 도착할지 알 수 없지만 반드시 둘 다 도착한 다음에 baz()함수가 호출이 되는, 즉 관문이 열리기 때문이다.</em> 이 코드가 존재하지 않다면 baz() 함수가 초기에는 a,b가 undefined인 상태에서도 호출이 되어 제대로 작동하지 않는다. 이와 다르게 둘 다 도착했을 때가 아닌, 둘 중 하나만 도착했을 때 상호 작용하도록 하는 코드도 있다. 이는 관문(Gate)보다 <em>걸쇠(Latch)로 불리고, 선착순 한 명만 이기는 형태이다.</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">    a = x * <span class="number">2</span>;</span><br><span class="line">    baz();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">for</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">    a = x / <span class="number">2</span>;</span><br><span class="line">    baz();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ajax()는 라이브러리에 있는 임의의 AJAX 함수</span></span><br><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, foo);</span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.2'</span>, bar);</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 <code>if (!a) {}</code>와 같은 코드를 걸쇠(Latch)라 부른다. foo()나 bar() 둘 중 첫 번째 실행된 함수만이 이 조건을 통과하고 늦게 실행된 함수 호출은 무시되기 때문이다.</p>
<hr>
<h2 id="콜백"><a href="#콜백" class="headerlink" title="콜백"></a>콜백</h2><p>콜백은 백그라운드에서 코드 실행을 시작할 함수를 호출할 때 인수로 지정된 함수이다. 백그라운드 코드 실행이 끝나면 콜백 함수를 호출해서 작업이 완료되었음을 아리거나 다음 작업을 실행하게 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  alert(<span class="string">'You clicked me!'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pElem = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">  pElem.textContent = <span class="string">'This is a newly-added paragraph.'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(pElem);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>위의 함수에서 콜백은 addEventListener()의 click 옆의 두 번째 매개변수이다. 이벤트가 실행 될 때 이 콜백 함수가 호출된다. callback 함수를 다른 함수의 인수로 전달할 때, 함수의 참조를 인수로 전달할 뿐이지 즉시 실행되지 않고, 함수의 body에서 “called back”된다. 즉 정의된 함수는 때가 되면 callback 함수를 실행하는 역할을 한다. 또한 콜백은 <strong>자바스크립트에서 비동기성을 표현하고 관리하는 가장 일반적인 기법이자 가장 기본적인 <code>비동기 패턴</code>이다.</strong></p>
<h3 id="콜백의-실체"><a href="#콜백의-실체" class="headerlink" title="콜백의 실체"></a>콜백의 실체</h3><h4 id="연속성"><a href="#연속성" class="headerlink" title="연속성"></a>연속성</h4><p>비동기 코드 작성의 어려움은 콜백 함수의 연속성과 인간 두뇌의 연속성의 개념이 다르기 때문이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line">ajax(<span class="string">"..."</span>, <span class="function"><span class="keyword">function</span>(<span class="params">..</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//c</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure>
<p>위와 같은 코드가 있다고 했을 때, <code>지금</code>에 해당하는 전반부 코드(A,B)가 실행되면 비결정적(indeterminate) 시간 동안 중지되고 언젠가 AJAX 호출이 끝날 때 중지되기 이전 위치로 다시 돌아와서 나머지 후반부(C)프로그램이 이어진다. 즉 콜백 함수는 프로그램의 연속성을 감싼(캡슐화)한 장치이다. 그런데 이러한 코드는 순차적으로 task를 처리하는 두뇌의 처리방식과 다른 순서를 같기 때문에 추론이 어렵다. 즉 위와 같은 코드를 보면 두뇌는 A -&gt; C -&gt; B의 순서대로 작성된 코드를 읽어내려가며 추론하려 할 것이다. 하지만 실질적인 코드는 A -&gt; B -&gt; C의 순서대로 실행하기 때문에 이러한 괴리감 때문에 비동기 처리를 이해하기 어렵게 만든다.</p>
<h4 id="콜백지옥"><a href="#콜백지옥" class="headerlink" title="콜백지옥"></a>콜백지옥</h4><p>비동기 처리를 위해 콜백을 중첩 또는 연속해서 사용되면 아래와 같은 콜백 지옥이 발생한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">listen(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ajax(<span class="string">'http://some.url.1'</span>, <span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (text == <span class="string">'hello'</span>) &#123;</span><br><span class="line">        handler();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">'world'</span>) &#123;</span><br><span class="line">        request();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>이러한 콜백 지옥으로 거론되는 첫 번째 문제는 콜백을 연속해서 쓰다보니 점점 들여쓰기가 되면서 가독성이 떨어져서 유지 보수를 어렵게 하는 것이다. 하지만 들여쓰기로 인한 가독성 저하보다 코드를 너무 복잡하게 만든다는 점이 더 큰 문제이다. 중접된 콜백으로 인한 가독성 저하를 막기 위해 콜백 작성시 조건을 작성해서 좀 더 가독성을 높일 수 있는데, <em>이러한 하드 코딩은 사실 코드를 더 복잡하게 만들고, 코드가 복잡해지는 것이야말로 유지보수를 어렵게 만든다.</em> 즉 콜백의 단계별 맞닥뜨릴 수 있는 경우의 수를 분기처리해 줄 수 있는데, 분기처리를 해야하는 가능한 경우의 수를 나열하다보면 코드가 방대해지고, 작성된 구문이 모든 경우의 수를 커버하라는 보장도 없다.</p>
<h4 id="믿음성-문제"><a href="#믿음성-문제" class="headerlink" title="믿음성 문제"></a>믿음성 문제</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line">ajax(<span class="string">"..."</span>, <span class="function"><span class="keyword">function</span>(<span class="params">..</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//c</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure>
<p>위와 같은 함수는 <code>제어권을 주고받는 행위</code>가 발생한다. A,B가 자바스크립트 메인 프로그램의 제어를 받으며 <code>지금</code> 실행된다면 C는 다른 프로그램(ajax() 함수)의 제어하에 <code>나중에</code> 실행된다. <em>이 제어권 교환이야말로 콜백 중심적 설계의 가장 큰 문제점이다.</em> 위 코드에서 쓰인 ajax()처럼 콜백을 넘겨주는 코드는 개발자가 직접 제어할 수 있는 함수가 아니라 서드 파티가 제공한 유틸리티인 경우가 대부분이다. 이렇게 내가 작성하는 프로그램인데도 실행 흐름은 서드 파티에 의존해야 하는 상황을 <code>제어의 역전</code>이라 한다. 그래서 비동기 콜백 함수를 작성한 경우, 콜백 자체에 대해 개발자가 직접 제어할 수 없기 때문에, 콜백 호출 시 오류가 날 수 있는 상황에 대한 여러가지 보완 로직을 구현하기 마련이다. 예를 들어 콜백을 너무 일찍 부르거나 너무 늦게 부른다거나, 너무 많이 부른다거나 하는 등의 잘못 될 가능성이 있는 상황에 대한 보완 로직을 작성해 두는 것이다. 하지만 보완 로직을 작성했다고 해도 서드 파티의 처리에서 무언가 문제가 생기면 완전히 잘못 틀어질 수도 있다. 그래서 이런 믿음성의 문제를 해결하기 위해 몇 가지 콜백 체계가 존재한다.</p>
<ul>
<li>분할 콜백</li>
<li>에러 우선 스타일</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//분할 콜백 - 한쪽은 성공, 한쪽은 실패</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">failure</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, succes, failure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//에러 우선 - 성공 시 빈/falsy 객체, 실패 시 truthy/에러 객체로 세팅됨.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//에러인가?</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//아니면 성공한 것</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, response);</span><br></pre></td></tr></table></figure>
<p>언뜻 보면 믿음성에 대한 문제가 해결된 것 같지만 원하지 않는 반복적인 호출을 방지하거나 걸러내는 콜백 기능은 전혀 없다. 오히려 성공/에러를 동시에 받거나 전혀 받지 못하는 상황에 대해서도 고려해야 하고, 이렇게 표준적인 형태로 작성되었어도 재사용이 불가하거나 장황한 관용 코드라서 콜백을 쓸 때마다 매번 새로 타이핑을 해주어야 할 수 있다.</p>
<p><em>정리하자면 콜백이 자바스크립트의 비동기성을 표현하는 기본 단위로써 충분히 그 역할을 다 해왔지만, 점점 진화하는 비동기 프로그래밍 환경에 대응하기에는 충분하지 않다.</em><br>첫 번째 이유는 연속성의 문제로 사람의 두뇌는 순차적이고, 단일-스레드 방식으로 계획하는데 익숙하지만 콜백은 비동기 흐름을 비선형적, 비순차적으로 나타내기 때문에 그 괴리감으로 인해 구현된 코드를 사람이 이해하기가 쉽지 않다. 이렇게 추론하기 어려운 코드는 악성 버그를 품을 가능성을 내재한 코드가 된다. 두 번째, 콜백이 프로그램을 진행하기 위해 제어권을 다른 파트(e.g. 서드파티 유틸리티)로 넘겨줘야 하는데, 이렇게 제어권이 넘어가면 믿음성의 문제에 봉착해서 콜백이 잘못될 가능성에 대해 구구절절한 보완 로직을 작성하게 된다. 이렇게 작성하면 믿음성의 문제는 해결할 수 있을지라도 거칠과 유지보수가 어려운 방대하고 복잡한 코드가 되고, 실제로 100% 믿음성의 문제를 해결했다고 보기도 어렵다. 모든 케이스에 대해 보완 로직을 작성했다고 해도, 제어권이 넘어간 상태에서 발생한 일까지 대응할 수는 없기 때문이다.</p>
<p>결국 이렇게 제기된 문제들을 해결하려면 콜백을 능가하는 조금 더 나은 해결법이 필요하고, 그런 배경 아래 등장한 것이 <code>프로미스</code>이다.</p>
<hr>
<p><em>References</em><br><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Introducing#async_callbacks" target="_blank" rel="noopener">callback</a><br>[YOU DON’T KNOW JS] 카일 심슨 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/21/220322_blockchain_22to23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/21/220322_blockchain_22to23/" class="post-title-link" itemprop="url">블록체인 무엇인가? 4장 블록체인은 한계는 무엇이고 어떻게 극복할 것인가? 22 ~ 23단계</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-22 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-22T00:00:00+09:00">2022-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-22 16:29:50" itemprop="dateModified" datetime="2022-06-22T16:29:50+09:00">2022-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="22-냉정하게-한계점-바라보기"><a href="#22-냉정하게-한계점-바라보기" class="headerlink" title="22. 냉정하게 한계점 바라보기"></a>22. 냉정하게 한계점 바라보기</h2><h3 id="블록체인-시스템이-가진-기술적-제약사항"><a href="#블록체인-시스템이-가진-기술적-제약사항" class="headerlink" title="블록체인 시스템이 가진 기술적 제약사항"></a>블록체인 시스템이 가진 기술적 제약사항</h3><blockquote>
<ol>
<li>개인정보 보호의 부재</li>
<li>보안 모델</li>
<li>제한적 확장성</li>
<li>고비용</li>
<li>숨겨진 중앙 통제</li>
<li>유연성의 부재</li>
<li>임계 크기</li>
</ol>
</blockquote>
<h4 id="1-개인정보-보호의-부재"><a href="#1-개인정보-보호의-부재" class="headerlink" title="1. 개인정보 보호의 부재"></a>1. 개인정보 보호의 부재</h4><p>블록체인에서 발생하는 모든 트랜잭션에 대한 정보는 상세히 기록되고 누구나 읽을 수 있다. 이렇게 정보는 보호되지 않지만 개인정보는 철저히 보호된다. 하지만 개인정보가 누구의 것인지 상세하게 알 수 없기 때문에 개인정보 보호의 부재라기보다 개인정보의 부재라고 볼 수 있고, 이런 것을 중요시하는 응용 분야에서는 이로부터 비롯되는 제약사항이 있을 수 있다.</p>
<h4 id="2-보안-모델"><a href="#2-보안-모델" class="headerlink" title="2. 보안 모델"></a>2. 보안 모델</h4><p>블록체인에서 트랜잭션 승인을 위해 <code>비대칭 암호화 기법</code>을 사용하는데 이는 가장 강력한 기법이기 때문에 강력한 보안이 가능하다. 하지만 블록체인 사용자가 개인 키를 분실하거나 개인 키가 타인의 손으로 넘어간 경우 계정 주인을 보호할 수 있는 추가 안전 장치가 없다. 비트코인은 개인 키의 해킹 등에 대비하는 몇 가지 안전장치를 제시하고 있다. 하지만 기본적으로 개인 키를 분실한 순간 보안은 무너졌다고 볼 수 있다.</p>
<h4 id="3-제한적-확장성"><a href="#3-제한적-확장성" class="headerlink" title="3. 제한적 확장성"></a>3. 제한적 확장성</h4><p>블록체인은 누구나 새로운 트랜잭션 데이터를 추가할 수 있도록 개방되어 있는 한편, 트랜잭션 데이터가 조작되거나 위조되지 않도록 보장해야 한다. 이를 위해 새로운 블록이 추가될 때마다 해시 퍼즐을 풀어야 하는데, 이 퍼즐을 풀 때 상당히 많은 계산량이 소모되도록 설계되어 있다. 이는 트랜잭션의 조작을 막는 것에 좋은 방법이지만 <em>빠른 처리속도와 높은 확장성, 대용량 처리가 필요한 응용분야에서는 오히려 걸림돌이될 수 있다.</em></p>
<h4 id="4-고비용"><a href="#4-고비용" class="headerlink" title="4. 고비용"></a>4. 고비용</h4><p>제한된 확장성과 관련 있는데, 해시 퍼즐을 풀 때 많은 계산량을 소모한다는 것은 그만큼 많은 비용(필요 계산 사이클, 물리적 시간, 소모 전력량 등)을 유발한다는 것이고, 전체 비용은 해시 퍼즐의 난이도에 달려있다.</p>
<h4 id="5-숨겨진-중앙-통제"><a href="#5-숨겨진-중앙-통제" class="headerlink" title="5. 숨겨진 중앙 통제"></a>5. 숨겨진 중앙 통제</h4><p>해시 퍼즐을 해결하기 위해 특화된 하드웨어에 투자하여 더 많은 보상을 받아서 이윤을 창출하는 사람들이 있는데, 이와 반대로 특화된 하드웨어가 없는 사람은 전자에 비해 밀릴 수 밖에 없어 시스템을 떠나게 된다. 따라서 특화된 하드웨어로 강력한 계산 능력을 갖춘 소수만 남아 시스템을 장악하는 상황을 초래할 수 있고, 이 소수가 시스템의 무결성을 유지하는 책임을 나눠가지게 된다. 이렇게 되면 사실상 보이지 않는 중앙 통제 집단을 형성하여 피어 그룹이 집단적으로 무결성을 유지하도록 하는 분산 시스템의 근본을 위협한다. <em>즉 기술적으로는 분산 시스템이지만 시스템의 무결성은 소수의 개체에 의해서만 유지되는 것이다.</em></p>
<h4 id="6-유연성의-부재"><a href="#6-유연성의-부재" class="headerlink" title="6. 유연성의 부재"></a>6. 유연성의 부재</h4><p>블록체인을 일단 가동하고 나면 변경, 업그레이드와 관련된 체계적 절차가 따로 없다. 이런 불변성은 블록체인 개발자가 체인 프로토콜의 버그를 고치거나 수정하기 어렵게 하고, 전체 블록체인-기술-모음을 유연성이 떨어지게 만든다.</p>
<h4 id="7-임계-크기"><a href="#7-임계-크기" class="headerlink" title="7. 임계 크기"></a>7. 임계 크기</h4><p><em>트랜잭션 데이터를 조작으로부터 보호하여 신뢰성을 확보하는 장치는 대다수의 시스템 계산 자원이 <code>정직한 노드에 의해 통제</code>된다는 가정에 기반한다.</em> 그래서 모든 블록체인이 엄청난 계산력을 갖춘 공격자로부터 시스템을 보호하기 위해 <code>최소한의 정직한 노드</code>가 필요하다.</p>
<h3 id="비기술적-문제-2가지"><a href="#비기술적-문제-2가지" class="headerlink" title="비기술적 문제 2가지"></a>비기술적 문제 2가지</h3><blockquote>
<ol>
<li>법적 수용성 부재</li>
<li>사용자 수용성 부재</li>
</ol>
</blockquote>
<h4 id="1-법적-수용성-부재"><a href="#1-법적-수용성-부재" class="headerlink" title="1. 법적 수용성 부재"></a>1. 법적 수용성 부재</h4><p>블록체인으로 분산 합의를 통해 소유권 이전 및 관리를 하는 것은 법적 효력에 대한 해석 문제를 야기하고, 이는 법적 제도 장치의 결여를 의미한다.</p>
<h4 id="2-사용자-수용성-부재"><a href="#2-사용자-수용성-부재" class="headerlink" title="2. 사용자 수용성 부재"></a>2. 사용자 수용성 부재</h4><p>법적 수용성 부재와 같은 요소가 사용자들의 블록체인에 대한 불확실성을 가지게 하고, 사용 결정에 대한 관심을 감소시킨다. 또 지식과 교육의 부재로 기본 작동 원리에 대해 모르기 때문에 블록체인에 대해 신뢰하기도 어렵다.</p>
<h3 id="어떻게-극복할-것인가"><a href="#어떻게-극복할-것인가" class="headerlink" title="어떻게 극복할 것인가?"></a>어떻게 극복할 것인가?</h3><h4 id="기술적-문제"><a href="#기술적-문제" class="headerlink" title="기술적 문제"></a>기술적 문제</h4><p>➡️ 모든 구성요소와 기술 수준을 조정한다. 블록체인의 기술적 제약사항을 극복하는 데 있어 주요 걸림돌은 기술을 개선하는 것과 기본 기술을 변경하는 것에 대한 구분이다.</p>
<h4 id="비기술적-문제"><a href="#비기술적-문제" class="headerlink" title="비기술적 문제"></a>비기술적 문제</h4><p>➡️ 교육과 법제도의 개선이 적절한 수단이 될 수 있다.</p>
<hr>
<h2 id="23-다시-태어난-블록체인"><a href="#23-다시-태어난-블록체인" class="headerlink" title="23. 다시 태어난 블록체인"></a>23. 다시 태어난 블록체인</h2><h3 id="블록체인의-서로-상충되는-목표"><a href="#블록체인의-서로-상충되는-목표" class="headerlink" title="블록체인의 서로 상충되는 목표"></a>블록체인의 서로 상충되는 목표</h3><blockquote>
<ol>
<li>투명성 vs 개인정보 보호</li>
<li>보안 vs 속도</li>
</ol>
</blockquote>
<h4 id="1-투명성-vs-개인정보-보호"><a href="#1-투명성-vs-개인정보-보호" class="headerlink" title="1. 투명성 vs 개인정보 보호"></a>1. 투명성 vs 개인정보 보호</h4><p>블록체인이 소유권을 검증하는 핵심 개념이 개방성과 투명성이다. 개인정보 보호는 트랜잭션에 연계된 계좌번호나 이체금액 등의 세부 사항이 공개되지 않도록 하는 것인데, 소유권 명확화를 위해 모든 트랜잭션이 투명하게 관리되는 것과 서로 충돌한다.</p>
<h4 id="2-보안-vs-속도"><a href="#2-보안-vs-속도" class="headerlink" title="2. 보안 vs 속도"></a>2. 보안 vs 속도</h4><p>블록체인은 트랜잭션 데이터를 보호하기 위해 해시 퍼즐을 풀 때 많은 계산량을 요구로 하는데, 이런 성질 때문에 속도와 확장성에 정면으로 반한다.</p>
<h3 id="갈등의-근본-원인은-읽기와-쓰기-권한에-있다"><a href="#갈등의-근본-원인은-읽기와-쓰기-권한에-있다" class="headerlink" title="갈등의 근본 원인은 읽기와 쓰기 권한에 있다"></a>갈등의 근본 원인은 읽기와 쓰기 권한에 있다</h3><div class="table-container">
<table>
<thead>
<tr>
<th>기술적 제약사항</th>
<th>갈등 요소</th>
<th>기본 기능</th>
</tr>
</thead>
<tbody>
<tr>
<td>개인정보 보호 부재</td>
<td>투명성 vs 개인정보 보호</td>
<td>트랜잭션 데이터 이력 읽기</td>
</tr>
<tr>
<td>확장성 부재</td>
<td>보안 vs 속도</td>
<td>트랜잭션 데이터 쓰기</td>
</tr>
</tbody>
</table>
</div>
<h3 id="갈등-해결-4가지-버전의-블록체인을-등장시키다"><a href="#갈등-해결-4가지-버전의-블록체인을-등장시키다" class="headerlink" title="갈등 해결, 4가지 버전의 블록체인을 등장시키다"></a>갈등 해결, 4가지 버전의 블록체인을 등장시키다</h3><p>갈등은 절충점을 찾거나 한쪽의 희생을 감수하고 다른 한쪽을 선택하면 해결된다.</p>
<h4 id="투명성과-개인정보-중-선택"><a href="#투명성과-개인정보-중-선택" class="headerlink" title="투명성과 개인정보 중 선택"></a>투명성과 개인정보 중 선택</h4><p>데이터를 읽을 권한을 누구에게 줄 것인가를 정하는 문제이다.</p>
<ul>
<li>공개 블록체인: 모든 사용자와 노드에게 트랜잭션 데이터를 읽을 수 있는 권한을 부여한다. (모두에게 읽기 권한 부여)</li>
<li>비밀 블록체인: 사전에 선택된 사용자와 노드에게만 트랜잭션 데이터를 읽을 수 있는 권한을 부여한다. (제한된 사용자와 노드 그룹에게만 읽기 권한 부여)</li>
</ul>
<h4 id="보안과-속도-중-선택"><a href="#보안과-속도-중-선택" class="headerlink" title="보안과 속도 중 선택"></a>보안과 속도 중 선택</h4><ul>
<li>무승인형 블록체인: 모두에게 쓰기 권한을 부여한다. 즉 누구나 트랜잭션을 검증하고 새 블록을 추가할 수 있다.</li>
<li>승인형 블록체인: 온-보딩 프로세스를 거쳐 신뢰성이 확인된 소수의 노드와 사용자 그룹에게만 쓰기 권한을 허용한다. 쓰기 권한을 받은 소수마 트랜잭션의 검증과 분산 동의에 참가할 수 있다.</li>
</ul>
<h3 id="블록체인의-네-가지-버전-어떤-점이-다를까"><a href="#블록체인의-네-가지-버전-어떤-점이-다를까" class="headerlink" title="블록체인의 네 가지 버전, 어떤 점이 다를까?"></a>블록체인의 네 가지 버전, 어떤 점이 다를까?</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th style="text-align:center">읽기와 트랜잭션 생성 권한</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td style="text-align:center">모두 허용</td>
<td>허가된 사용자만 허용</td>
</tr>
<tr>
<td>쓰기권한</td>
<td>모두 허용</td>
<td style="text-align:center">공개&amp;무승인</td>
<td>비밀&amp;무승인</td>
</tr>
<tr>
<td></td>
<td>허가된 사용자만 허용</td>
<td style="text-align:center">공개&amp;승인</td>
<td>비밀&amp;승인</td>
</tr>
</tbody>
</table>
</div>
<p>위의 조합괸 버전들은 블록체인의 다음 세 가지 측면에 영향을 미친다.</p>
<blockquote>
<ol>
<li>P2P 아키텍처</li>
<li>분산 속성</li>
<li>목적</li>
</ol>
</blockquote>
<h4 id="1-P2P-아키텍처"><a href="#1-P2P-아키텍처" class="headerlink" title="1. P2P 아키텍처"></a>1. P2P 아키텍처</h4><p>시스템에 참여한 모든 컴퓨터에게 동등한 권리와 역할을 부여해야 하는데, 위에서 설명된 버전 중 일부는 <em>시스템을 구성하는 노드별로 읽기와 쓰기 권한에 차별을 둔다.</em> 따라서 동등한 권리와 역할을 부여한다는 P2P 시스템의 중요한 특성에 위배된다.</p>
<h4 id="2-분산-속성"><a href="#2-분산-속성" class="headerlink" title="2. 분산 속성"></a>2. 분산 속성</h4><p>분산 시스템에서 중앙 통제나 조정장치가 없어야 한다. 그러나 위에서 설명된 버전 중 일부는 읽기와 쓰기 권한을 사전에 승인한 노드나 사용자 그룹으로 제한하고 있다. 그리고 이런 승인과 권한에 관한 규칙이 순수 분산 시스템에 의해 유지되고 관리되지 않는다면 중앙 통제 요소가 있다는 것이어서 분산 속성에 위배된다. 또 숨은 중앙 통제 요소가 있거나 내부적으로 분산 시스템을 활용하지만 모든 노드에게 접근제한이 있는 중앙 통제 시스템을 볼 수 있는데 이 경우 모두 분산과 중앙 통제 요소로 구성된 혼합시스템에 가깝다.</p>
<h4 id="3-목적"><a href="#3-목적" class="headerlink" title="3. 목적"></a>3. 목적</h4><p>읽기와 쓰기 권한에 제한을 두는 것은 분산 P2P 시스템의 기본 성질을 변형시킬 뿐 아니라 노드의 신뢰성도 변화시킨다. 하지만 안정성과 신뢰성을 알 수 있는 특정된 개수의 노드로 구성된 환경에서도 블록체인의 역할이 존재한다.</p>
<ul>
<li>기술적 결함이나 컴퓨터 고장으로 작동하는 노드의 개수가 변경될 수 있다.</li>
<li>모든 분산 시스템은 네트워크 장애로 인해 개별 메시지단위의 통신이 안정적이지 못하다.</li>
<li>노드의 신뢰성을 100% 수준으로 보장할 수 없다.</li>
</ul>
<h3 id="블록채인의-목적-다시-정의하기"><a href="#블록채인의-목적-다시-정의하기" class="headerlink" title="블록채인의 목적 다시 정의하기"></a>블록채인의 목적 다시 정의하기</h3><p>노드별로 읽기와 쓰기 권한에 제약을 두면 블록체인의 주요 측면과 상충하는데 제약이 가장 많은 비밀-승인형 블록체인에서도 여전히 무결성 유지에 아주 중요하다.</p>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/20/220321_blockchain19_21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/20/220321_blockchain19_21/" class="post-title-link" itemprop="url">블록체인 무엇인가? 3장 블록체인은 어떻게 작동하는가? 19 ~ 21단계</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-21 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-21T00:00:00+09:00">2022-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-22 16:29:50" itemprop="dateModified" datetime="2022-06-22T16:29:50+09:00">2022-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="19-컴퓨터들도-라인을-잘-타야-살아남는다"><a href="#19-컴퓨터들도-라인을-잘-타야-살아남는다" class="headerlink" title="19. 컴퓨터들도 라인을 잘 타야 살아남는다"></a>19. 컴퓨터들도 라인을 잘 타야 살아남는다</h2><p>시스템의 개별 노드가 유지하고 있는 트랜잭션 이력이 서로 달라 충돌이 생길때 문제를 어떻게 해결할지 알아본다.</p>
<h3 id="목표"><a href="#목표" class="headerlink" title="목표"></a>목표</h3><p><em>네트워크 내 모든 노드가 명확한 단일 트랜잭션 이력만 유지하도록 하여</em> 어느 노드가 소유권 확인 요청을 처리하든 항상 동일한 결과가 산출되도록 한다.</p>
<h3 id="해결해야-할-과제"><a href="#해결해야-할-과제" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><p>블록체인-알고리즘에는 중앙 통제 장치가 없기 때문에 개별 노드의 수신함에 도착한 새 블록이 그 노드가 무슨 일을 해야 할지 알려준다. 각 노드는 어떤 메시지가 도착했냐에 따라 작업을 전환하는데 같은 시간에 모든 노드의 작업 전환이 동시에 발생하는 것이 아니므로 개별 노드의 작업 상태에 중첩이 생길 수 있다. 이처럼 메시지 전달 과정에서 문제가 발생했을 때 <strong>명확한 단일 트랜잭션 이력을 식별하는 방법을 찾아야 한다.</strong></p>
<h3 id="아이디어"><a href="#아이디어" class="headerlink" title="아이디어"></a>아이디어</h3><blockquote>
<p>모든 노드가 단일 버전의 트랜잭션 이력을 선택한다.</p>
</blockquote>
<p>집단적 의사결정 문제에서 동의나 합의에 이르는 과정을 <code>분산 합의</code>라 부르는데 집단적 의사결정 상황은 다음의 네 가지를 충족한다.</p>
<ul>
<li>모든 노드는 네트워크, 블록체인-데이터-구조의 개별 복사본을 유지하는 노드들, 노드들의 행동을 통제하는 블록체인-알고리즘으로 구성된 <strong>동일한 환경에서 작동한다.</strong></li>
<li><strong>집단적 의사결정 문제는 단일 트랜잭션 이력을 선택하는 것이다.</strong></li>
<li>모든 노드는 수입을 최대화하기 위해 블록체인-데이터-구조에 <strong>유효한 새 블록을 추가하고 보상을 받으려 노력한다.</strong></li>
<li>모든 노드는 목표 달성을 위해 자신이 생성한 새 블록을 피어들에게 보내 검사받고 인정받으려 한다. 그 결과 각 노드는 집단적으로 유지되는 블록체인-데이터-구조 환경에 개별적인 흔적을 남기게 된다.</li>
<li>환경 변화에 기반한 동일한 기준을 사용해 의사결정 문제를 평가한다. <em>여기서 기준은 각 트랜잭션 이력을 생성하기 위해 사용한 계산 노력의 누적 총합이고, 둘 이상의 상충된 트랜잭션에서 조작된 데이터를 분별하기 위한 기준으로 활용된다.</em></li>
</ul>
<h3 id="작동원리"><a href="#작동원리" class="headerlink" title="작동원리"></a>작동원리</h3><h4 id="계산-노력을-판단하는-기준"><a href="#계산-노력을-판단하는-기준" class="headerlink" title="계산 노력을 판단하는 기준"></a>계산 노력을 판단하는 기준</h4><h3 id="가장-긴-체인-기준"><a href="#가장-긴-체인-기준" class="headerlink" title="가장-긴-체인 기준"></a>가장-긴-체인 기준</h3><p>새 블록을 만들어 기존 체인을 확장하려고 할 때, 어떤 노드는 해시 퍼즐을 해결하여 새 블록을 피어들에게 전송하여 블록-체인-데이터 구조를 형성할 것이다. 그리고 이렇게 가장 최근 추가된 새 블록을 이전 노드로 만드는 또다른 새 블록을 만들기 위해 노력하게 될텐데 이는 곧 <em>세 개의 블록으로 구성된 오직 한 가지 버전의 블록체인-데이터-구조만 존재한다는 것이다.</em> 단 네트워크 상의 문제로 인해 새 노드를 전달받지 못하는 상황에서 전달받지 못한 노드 중 하나가 해시 퍼즐을 해결하여 다른 피어들에게 해시값을 전송하게 되면 <strong>대다수의 피어들이 2개의 블록을 수신하게 된다.</strong> 이런 경우 상단에 두 개의 가지가 뻗어있는 블록체인-데이터-구조를 유지하게 되는데, 체인의 길이가 같다면 각 노드는 어느 쪽 가지를 확장할 지 임의로 정한다. 그런데 이때도 앞서 말한 두 개의 블록을 수신하게 되는 상황이 발생할 수 있다. 결국 가장-긴-체인 기준을 적용하면 대다수의 노드 그리고 궁극적으로 시스템의 모든 노드가 소유권의 명확화와 관련된 요청에 대해 이 체인을 사용하게 되고, <strong>블록체인-데이터-구조는 일직선으로 이어진 체인이 아니라 트리나 원주형 선인장처럼 생긴 구조를 가지게 된다.</strong></p>
<h3 id="가장-무거운-체인-기준"><a href="#가장-무거운-체인-기준" class="headerlink" title="가장-무거운-체인 기준"></a>가장-무거운-체인 기준</h3><p>가장 많은 블록을 가지고 있는 경로가 가장 많은 계산 노력을 소모한 것이라는 가정 하에 가장-긴-체인 기준에 대해 살펴보았다. <em>그런데 난이도가 블록마다 다를 때 가장 긴 경로가 반드시 가장 많은 계산 노력을 소모했다는 보장이 없다.</em> 각 경로별로 실제로 사용된 계산 노력을 측정하려면 각 블록 헤더의 난이도를 모두 더하면 된다. 이렇게 계산해보면 가장-긴-체인이 반드시 가장 많은 계산 노력을 소모한 것은 아니라는 사실을 알 수 있고, 이 때문에 동적으로 난이도를 결정하는 블록체인은 가장-무거운-체인 기준으로 가장 무거운 체인을 가진 트랜잭션 데이터 이력을 선택하다.</p>
<h3 id="선택받지-못한-체인은-어떻게-될까"><a href="#선택받지-못한-체인은-어떻게-될까" class="headerlink" title="선택받지 못한 체인은 어떻게 될까?"></a>선택받지 못한 체인은 어떻게 될까?</h3><p>특정 체인을 선택하면 다음의 결과가 나온다.</p>
<blockquote>
<p>고아 블록<br>보상 회수<br>소유권 명확화<br>트랜잭션 재처리<br>공통 몸통의 성장<br>궁극적 일관성<br>조작에 대한 견고성</p>
</blockquote>
<h4 id="1-고아-블록"><a href="#1-고아-블록" class="headerlink" title="1. 고아 블록"></a>1. 고아 블록</h4><p>권위 체인이 선정되면, 트리-모양 데이터 구조 내 권위 체인 경로에 속하지 않은 블록은 모두 버려진다.</p>
<h4 id="2-보상-회수"><a href="#2-보상-회수" class="headerlink" title="2. 보상 회수"></a>2. 보상 회수</h4><p>고아 블록은 권위 체인에 기여하지 않으므로 소유권 명확화에 아무 쓸모가 없고, 고아 블록을 생성하고 제출해서 보상을 받았던 노드들로부터 보상을 회수한다.</p>
<h4 id="3-소유권-명확화"><a href="#3-소유권-명확화" class="headerlink" title="3. 소유권 명확화"></a>3. 소유권 명확화</h4><p>권위 체인에 속한 트랜잭션들만 실제로 발생한 것으로 인정받아 소유권 명확화에 사용된다.</p>
<h4 id="4-트랜잭션-제자리"><a href="#4-트랜잭션-제자리" class="headerlink" title="4. 트랜잭션 제자리"></a>4. 트랜잭션 제자리</h4><p>고아 블록에 소속돼 버려진 트랜잭션 데이터는 노드의 수신함에 넣어져 재처리된 후 블록체인-데이터-구조에 다시 추가되어 선택된 트랜잭션 이력의 일부가 될 기회를 한 번 더 부여받는다.</p>
<h4 id="5-공통-몸통의-성장"><a href="#5-공통-몸통의-성장" class="headerlink" title="5. 공통 몸통의 성장"></a>5. 공통 몸통의 성장</h4><p>트랜잭션 이력의 상충되는 버전은 덜 모호한 공통 몸통으로부터 뻗어나온 것이므로 깊이 들여다볼수록 해당 블록이 가장 긴 체인의 일부인지 아닌지가 명확해진다.</p>
<h4 id="6-궁극적-일관성"><a href="#6-궁극적-일관성" class="headerlink" title="6. 궁극적 일관성"></a>6. 궁극적 일관성</h4><p>가장-긴-체인-기준이 모호할 때 추가된 다음 블록에 의해 어느 것이 가장 긴 체인의 일부가 될지 결정하는데, <em>이 다음 블록이 블록체인-데이터-구조의 어디에 붙어서 가지를 확장할지는 노드가 알아서 결정한다.</em> 트리-모양 블록체인-데이터-구조는 해시 퍼즐의 속도 경쟁과 네트워크를 통한 메시지 전달의 임의 변동성에 영향을 받으려 무작위로 성장하는데 선택된 가지들은 몸통에 그대로 붙어있다. 따라서 권위 체인의 정상이나 그 근처 블록들은 새 블록이 랜덤으로 도착하는 성질에 영향을 많이 받는다. <em>시간이 지나 더 많은 블록이 추가될수록 권위 체인에 포함될 가능성이 더 높아지는 현상을 궁긍적 일관성이라 부른다.</em></p>
<h4 id="7-조작에-대한-견고성"><a href="#7-조작에-대한-견고성" class="headerlink" title="7. 조작에 대한 견고성"></a>7. 조작에 대한 견고성</h4><p>트리-모양의 블록체인-데이터-구조 중 가장 계산 노력이 가장 많이 들어간 경로가 트랜잭션 이력의 권위 있는 버전이다. 블록체인-데이터-구조 내부의 특정 블록에서 시작하는 새로운 권위 경로를 만들려면 대다수가 유지하고 있는 경로를 따라잡고 앞질러야 하고, 이 점이 블록체인이 가진 견고성의 기초가 된다. 즉 공격자가 내부 블록을 조작하려한다면 작업 증명을 다시 하고, 모든 후속 블록의 해시 퍼즐을 다시 풀어서 정직한 노드들이 유지하고 있는 경로를 따라잡아야 하는데 사실상 불가하고, 결론적으로 시스템이 유지하는 트랜잭션 이력은 조작으로부터 견고하다.</p>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/19/220320_blockchain03_16to18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/19/220320_blockchain03_16to18/" class="post-title-link" itemprop="url">블록체인 무엇인가? 3장 블록체인은 어떻게 작동하는가? 16 ~ 18단계</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-20T00:00:00+09:00">2022-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-22 16:29:50" itemprop="dateModified" datetime="2022-06-22T16:29:50+09:00">2022-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="16-블록체인이-데이터를-보호하는-방법"><a href="#16-블록체인이-데이터를-보호하는-방법" class="headerlink" title="16. 블록체인이 데이터를 보호하는 방법"></a>16. 블록체인이 데이터를 보호하는 방법</h2><h3 id="목표"><a href="#목표" class="headerlink" title="목표"></a>목표</h3><p>블록체인이 유지하는 <strong>전체 트랜잭션 이력을 불변성 데이터로 만들어 위조나 조작이 없게 한다.</strong></p>
<h3 id="해결해야-할-과제"><a href="#해결해야-할-과제" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><p>누구에게나 개방된 순수 분산 P2P 시스템을 개방한 채 조작이나 위조의 위협으로부터 트랜잭션 데이터를 보호한다.</p>
<h3 id="아이디어"><a href="#아이디어" class="headerlink" title="아이디어"></a>아이디어</h3><p>처음부터 아무도 이력을 조작하지 못하게 막아놓는다.</p>
<h3 id="불변성은-읽기-전용의-다른-이름"><a href="#불변성은-읽기-전용의-다른-이름" class="headerlink" title="불변성은 읽기 전용의 다른 이름"></a>불변성은 읽기 전용의 다른 이름</h3><p>불변성 데이터는 한번 생성되면 절대로 변경될 수 없고, 이러한 데이터는 읽기 전용 데이터라고도 한다. 데이터를 변경과 조작으로부터 보호하는 효과적인 방법이다.</p>
<h2 id="작동원리"><a href="#작동원리" class="headerlink" title="작동원리"></a>작동원리</h2><blockquote>
<p>트랜잭션 이력을 변경하는 일이 감당 불가라서 누구라도 단념하게 만드는 방법으로 트랜잭션 이력을 불변성 데이터로 만든다.</p>
</blockquote>
<h3 id="트랜잭션-이력을-불변성-데이터로-만드는-데-필요한-세-가지"><a href="#트랜잭션-이력을-불변성-데이터로-만드는-데-필요한-세-가지" class="headerlink" title="트랜잭션 이력을 불변성 데이터로 만드는 데 필요한 세 가지"></a>트랜잭션 이력을 불변성 데이터로 만드는 데 필요한 세 가지</h3><ul>
<li>트랜잭션 이력을 저장할 때 아무리 사소한 조작이라도 바로 드러날 수 있게 한다.<ul>
<li>아무리 사소한 변경이라도 데이터를 가리키는 해시 참조를 무효화 시켜서 몰래 조작이 불가하다.</li>
</ul>
</li>
<li>변경된 데이터를 끼워넣으려면 엄청난 양을 다시 작성하도록 강제한다.<ul>
<li>변경하려면 변경된 부분부터 헤드까지 전체 체인을 완전히 변경하거나 내버려둬야 한다.</li>
</ul>
</li>
<li>트랜잭션 이력에 데이터를 추가, 변경, 재작성하는 작업에 엄청난 계산량이 필요하도록 한다.<ul>
<li>블록체인-기술-모음은 블록체인-데이터-구조의 모든 블록에 대해 작성, 재작성, 추가 작업에 엄청난 계산 비용이 필요하게끔 만든다.</li>
</ul>
</li>
</ul>
<h3 id="작동원리-세부-사항-살펴보기"><a href="#작동원리-세부-사항-살펴보기" class="headerlink" title="작동원리: 세부 사항 살펴보기"></a>작동원리: 세부 사항 살펴보기</h3><p>블록체인-데이터-구조의 새 블록 추가에는 많은 계산량이 들지 않지만 이것을 불변성으로 만들려면 새 목록을 추가하는 것이 많은 계산량을 필요로 하게끔 해야한다. 이를 위해서 아래와 같은 사항을 고려한다.</p>
<ul>
<li>필수 데이터</li>
<li>새 블록 헤더를 생성하는 프로세스</li>
<li>블록 헤더를 검증하는 규칙</li>
</ul>
<h4 id="필수-데이터"><a href="#필수-데이터" class="headerlink" title="필수 데이터"></a>필수 데이터</h4><p>블록체인-데이터-구조의 모든 블록 헤더는 최소한 다음의 데이터를 가진다.</p>
<ul>
<li>트랜잭션 데이터를 담고 있는 머클 트리의 루트</li>
<li>이전 블록 헤더를 가리키는 해시 참조</li>
<li>해시 퍼즐의 난이도</li>
<li>해시 퍼즐 풀이를 시작한 시각</li>
<li>해시 퍼즐을 해결할 수 있는 난스</li>
</ul>
<h4 id="새-블록을-생성하는-프로세스"><a href="#새-블록을-생성하는-프로세스" class="headerlink" title="새 블록을 생성하는 프로세스"></a>새 블록을 생성하는 프로세스</h4><ol>
<li>새로 추가되는 트랜잭션을 담고 있는 머클 트리의 루트 얻기</li>
<li>새 블록 헤더의 입장에서 이전 블록 헤더를 가리키는 해시 참조 생성하기</li>
<li>필요 난이도 획득하기</li>
<li>현재 시각 읽기</li>
<li>1~4번에 언급된 데이터를 포함하는 예비 블록 헤더 생성하기</li>
<li>예비 블록 헤더에 해당하는 해시 퍼즐 해결하기</li>
<li>해시 퍼즐을 해결할 난스를 예비 헤더에 포함시켜 새 블록 완결하기</li>
</ol>
<h4 id="검증-규칙"><a href="#검증-규칙" class="headerlink" title="검증 규칙"></a>검증 규칙</h4><p>다음의 규칙을 준수한다.</p>
<ol>
<li>직전 블록을 가리키는 유효한 해시 참조가 있다.</li>
<li>트랜잭션 데이터를 갖고 있는 머클 트리의 루트를 포함한다.</li>
<li>정확한 난이도를 가지고 있어야 한다.</li>
<li>타임 스탬프는 직전 블록 헤더의 타임 스탬프 이후여야 한다. (블록과 트랙잭션 데이터들이 추가 된 순서에 따라 정렬되어 있음을 보장)</li>
<li>난스를 포함해야 한다.</li>
<li>위 5개의 데이터 조각을 함친 해시값으로 난이도를 충족해야 한다.</li>
</ol>
<p>검증 규칙은 해시 퍼즐을 해결하고, 필요한 계산 비용을 지불한 블록만 추가되도록 보장한다. 이처럼 해시 퍼즐을 해결하여 블록체인-데이터-구조에 새 블록을 추가하는 행위를 마이닝 혹은 블록 마이닝이라 부른다.</p>
<h3 id="작동하는-이유"><a href="#작동하는-이유" class="headerlink" title="작동하는 이유"></a>작동하는 이유</h3><p><strong>해시 참조가 가리키는 데이터에 변경이 있으면 그 즉시 해시 참조 자체를 손상시키는 성질</strong>에서 비롯되어, 데이터 조작이 있을 경우 영향받은 모든 블록을 다시 작성하게 한다. <em>결국 블록체인-데이터-구조의 불변성은 해시 퍼즐의 난이도에 달려 있다.</em> 난이도가 너무 낮으면 계산비용도 낮아져 조작의 가능성이 높아지고, 난이도가 너무 높으면 새 데이터를 추가하는 계산 비용도 높아져 새 데이터 추가에 대한 의욕이 상실될 수 있다. 따라서 블록체인 디자인 시 해시 퍼즐의 적절한 난이도를 결정하는 것이 매우 중요하다. 실제로는 새 블록이 추가되는 속도에 기초한 동적 난이도를 활용하는데, 새 블록의 추가 속도가 빨라지면 난이도를 높이고, 그 반대면 난이도를 낮추는 방식으로 적정 수준의 난이도를 유지한다.</p>
<hr>
<h2 id="17-컴퓨터들이-정보를-배분하는-방법"><a href="#17-컴퓨터들이-정보를-배분하는-방법" class="headerlink" title="17. 컴퓨터들이 정보를 배분하는 방법"></a>17. 컴퓨터들이 정보를 배분하는 방법</h2><h3 id="목표-1"><a href="#목표-1" class="headerlink" title="목표"></a>목표</h3><p>P2P 시스템을 구성하는 개별 컴퓨터들이 트랜잭션이 발생할 때마다 적절히 통보받아 자신의 트랜잭션 데이터 이력을 관리할 수 있도록 보장한다.</p>
<h3 id="해결해야-할-과제-1"><a href="#해결해야-할-과제-1" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><p>순수 분산 P2P 시스템에는 중앙 통제와 조정 장치가 없기 때문에 시스템의 모든 노드가 이러한 장치에 의지하지 않고 모든 트랜잭션 정보를 수신하도록 해주는 것이다.</p>
<h3 id="아이디어-1"><a href="#아이디어-1" class="headerlink" title="아이디어"></a>아이디어</h3><p>P2P 시스템을 구성하는 컴퓨터들이 정보를 공유하고 교환하도록 하는 것인데, 노드 하나가 피어 노드에게 정보를 전달받으면 다른 피어에게 그 정보를 전달하고, 그 피어가 또 다른 피어에게 전달하는 방식으로 시스템 내 모든 노드가 정보를 전달받도록 한다.</p>
<h2 id="작동원리-1"><a href="#작동원리-1" class="headerlink" title="작동원리"></a>작동원리</h2><p>분산 P2P 시스템의 컴퓨터는 디지털 네트워크를 통해 통신하기 때문에 노드들이 인터넷을 통해 서로 통신하도록 하는 방식으로 P2P 시스템을 구성할 수 있다. <em>단 노드가 네트워크를 통해 통신하고 언제든 단절과 재접속을 할 수 있다는 점이 메시지 전달에 영향을 미친다.</em> 네트워크에서 이루어지는 메시지 전달에는 아래와 같은 특성이 있다.</p>
<ul>
<li>손실될 가능성이 있다.</li>
<li>한 번 이상 도달할 수 있다.</li>
<li>전송한 순서와 다른 순서로 도착할 수 있다.</li>
</ul>
<p>이 특성때문에 통신에 장애가 발생할 수 있지만 아래의 방법으로 해결할 수 있다.</p>
<ul>
<li>새로운 정보를 받은 모든 노드는 자신이 통신하는 피어에게 전달하기 때문에 몇몇 메시지가 손실될 수 있어도 궁극적으로 모든 노드가 메시지를 수신하는 것을 보장한다.</li>
<li>메시지는 디지털 지문 또는 암호화 해시값으로 식별 가능하므로 노드가 중복된 메시지를 식별해서 무시할 수 있다.</li>
<li>트랜잭션 데이터와 블록 헤더에 타임 스탬프가 포함되어 있어서 노드들이 객관적인 시각 기준에 따라 메시지를 정렬할 수 있다.</li>
</ul>
<p><strong>P2P 시스템을 구성하는 노드 간 통신은 다음 세 가지 목적을 가진다.</strong></p>
<blockquote>
<ul>
<li>기존 연결 유지</li>
<li>새로운 연결</li>
<li>새로운 정보 배포</li>
</ul>
</blockquote>
<p>기존 연결 유지, 새로운 연결은 P2P 시스템 자체에 초점을 맞추고 있어서 피어 간 네트워크를 유지하고 약간의 디지털 관리 업무를 수행한다. 새로운 정보 배포는 블록체인-데이터-구조에 새로운 트랜잭션 데이터나 블록을 추가하는 것에 초점을 맞춘다.</p>
<ul>
<li>기존 연결 유지</li>
</ul>
<p>네트워크의 각 컴퓨터는 통신하는 피어 리스트를 독립적으로 유지하고, 피어 리스트는 시스템을 구성하는 전체 노드의 부분집합이다. 주기적으로 각 컴퓨터는 피어가 연결상태인지 확인하기 위해 핑(ping)하고 메시지를 보내고, 퐁(pong)으로 대답하도록 요청한다. 만약 이 메시지에 반복적으로 대답하지 않는 피어가 있다면 리스트에서 제거한다.</p>
<ul>
<li>새로운 연결</li>
</ul>
<p>P2P 시스템 내에 참여하고 싶은 컴퓨터는 시스템 내의 아무 노드에게나 시스템에 참여하고 싶다고 요청한다. 이렇게 요청을 받은 노드는 요청자인 피어의 주소를 피어 리스트에 추가하고 확인 응답을 보내고, 확인 응답을 받은 노드는 응답을 보낸 주소를 자신의 피어 리스트에 추가한다. 이렇게 되면 새로운 연결이 형성되어 시스템에 노드 하나가 더 증가한 것이다. 그리고 P2P 시스템에 참여할 때는 시스템의 일부인 다수의 노드와 연결을 형성한다. 특정 노드 하나의 연결이 끊어지더라도 시스템에 연결된 상태를 유지하기 위함이다.</p>
<ul>
<li>새로운 정보 배포</li>
</ul>
<p>새로 추가될 트랜잭션 데이터와 새 블록 정보를 통신을 통해 전달하는데, <em>소유권 관련 정보를 공유하는 일은 다음 3가지 경우에 발생한다.</em></p>
<ul>
<li>지속적인 방식<ul>
<li>새로운 정보는 발생과 동시에 배포되고, 시스템에 연결된 모든 노드가 정보를 받는다.</li>
</ul>
</li>
<li>갱신 방식<ul>
<li>연결이 끊겼다가 다시 시스템에 연결되었을 때, 그 사이 놓친 트랜잭션 데이터와 블록에 대한 정보를 모두 받는다.</li>
</ul>
</li>
<li>온보딩 절차의 일부로 갱신<ul>
<li>시스템에 새로 참여한 노드는 트랜잭션 이력을 구축할 기회가 없었기 때문에 시스템 참여 직전까지 발생한 모든 트랜잭션 이력을 얻어와야 한다. 따라서 새로운 참여자가 참여하자 마자 모든 정보를 갖추어 노드가 될 수 있도록 보장한다.</li>
</ul>
</li>
</ul>
<h2 id="작동하는-이유-1"><a href="#작동하는-이유-1" class="headerlink" title="작동하는 이유"></a>작동하는 이유</h2><p>앞서 살펴본 3가지 통신 방식이 새로운 컴퓨터가 시스템에 참여할 수 있도록 보장해주기 때문에 시스템이 확장되게 하면서 기존 연결 유지의 업무도 수행하게 한다. <strong>가장 중요한 점은 블록체인-데이터-구조 내 새로 추가되는 트랜잭션 데이터와 블록에 대한 모든 정보를 P2P 시스템의 전체 구성원이 궁극적으로 받아볼 수 있도록 보장한다는 것이다.</strong></p>
<hr>
<h2 id="18-블록체인-속-무한경쟁-사회"><a href="#18-블록체인-속-무한경쟁-사회" class="headerlink" title="18. 블록체인 속 무한경쟁 사회"></a>18. 블록체인 속 무한경쟁 사회</h2><h3 id="목표-2"><a href="#목표-2" class="headerlink" title="목표"></a>목표</h3><p>시스템의 무결성을 유지하면서 누구든지 트랜잭션 데이터 이력에 새로운 트랜잭션을 추가할 수 있도록 허용한다.</p>
<h3 id="해결해야-할-과제-2"><a href="#해결해야-할-과제-2" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><p>완전히 개방된 시스템에서 누구든 시스템에 참여하여 데이터를 전송할 수 있는데, 이 데이터들이 정확하다는 보장은 없다. <strong>따라서 시스템을 모두에게 개방하면서도 오직 유효한 트랜잭션만 추가될 수 있도록 보장하는 것이 필요하다.</strong></p>
<h3 id="아이디어-2"><a href="#아이디어-2" class="headerlink" title="아이디어"></a>아이디어</h3><p>시스템의 모든 노드가 다른 피어 노드를 감시하도록 하면서 동시에 유효하고 승인된 트랜잭션을 추가하거나 타인의 작업에 오류를 발생했을 때 적절한 보상을 해주어 동기를 부여한다.</p>
<h3 id="작동원리-구성요소들"><a href="#작동원리-구성요소들" class="headerlink" title="작동원리: 구성요소들"></a>작동원리: 구성요소들</h3><p>블록체인-알고리즘은 노드가 새 트랜잭션 데이터와 블록을 어떻게 처리할지 통제하는 일련의 명령어이다. 개별적 규칙과 절차는 다음과 같다.</p>
<blockquote>
<ol>
<li>검증 규칙</li>
<li>보상</li>
<li>처벌</li>
<li>경쟁</li>
<li>피어 통제</li>
</ol>
</blockquote>
<h4 id="1-검증-규칙"><a href="#1-검증-규칙" class="headerlink" title="1. 검증 규칙"></a>1. 검증 규칙</h4><p>블록체인-데이터-구조가 유효한 트랜잭션 데이터와 블록 헤더만으로 구성된 블록만을 가지도록 한다. 데이터 유효성의 검증에는 다음의 두 가지가 필요하다.</p>
<blockquote>
<ul>
<li>트랜잭션 데이터 검증 규칙</li>
<li>블록 헤더 검증 규칙</li>
</ul>
</blockquote>
<ul>
<li>트랜잭션 데이터 검증 규칙</li>
</ul>
<p>형식의 정확성, 의미상 정확성, 승인의 3요소이다. 이 규칙은 블록체인의 응용분야(블록체인이 어떤 산업분야에서 사용되는가)에 따라 서로 다른 검증 규칙을 가지게 된다.</p>
<ul>
<li>블록 헤더 검증 규칙</li>
</ul>
<p><em>형식과 의미의 정확성에 초점이 있고,</em> 트랜잭션 데이터의 내용과 무관한 블록체인-데이터-구조에 정보가 추가되는 방식과 관련 있다. 개별적 해시 퍼즐을 해결한 헤더를 가진 블록만 그 다음 단계로 넘어가고, 그렇지 못한 블록은 즉시 폐기된다.</p>
<h4 id="2-보상"><a href="#2-보상" class="headerlink" title="2. 보상"></a>2. 보상</h4><p>유효한 블록 생성을 위해 블록의 고유 해시 퍼즐을 풀어야만 한다. 이때 피어가 해시 퍼즐을 푸는 부담(에너지, 시간, 돈 등)을 짊어지도록 하는 방법은 비용에 상응하는 보상을 제공하는 것이다. 블록체인-알고리즘이 유효한 블록을 제출한 노드가 보상을 받는 방식을 정의한다.</p>
<h4 id="3-처벌"><a href="#3-처벌" class="headerlink" title="3. 처벌"></a>3. 처벌</h4><ul>
<li>생성 당시엔 인정되었지만 나중에 유효하지 않거나 무용한 것으로 판명된 블록에 대해 <em>이미 지급된 보상을 회수한다.</em></li>
<li>노드가 작업 증명을 했지만 블록이 중복되거나 너무 오래된 경우, 쓸모없는 경우에 <em>보상을 하지 않는다.</em></li>
</ul>
<h4 id="4-경쟁"><a href="#4-경쟁" class="headerlink" title="4. 경쟁"></a>4. 경쟁</h4><p>시스템을 유지하는데 드는 비용을 줄이면서 높은 작업 품질을 성취하는 최선의 방법으로 서로 경쟁하도록 만든다. 블록체인-알고리즘은 아래 두 가지 기준의 조합으로 지속적인 경쟁을 유발하며 적절히 보상한다.</p>
<ul>
<li>속도 경쟁</li>
</ul>
<p><strong>해시 퍼즐에 기초한다.</strong> 유효한 블록 생성의 핵심은 작업 증명을 생성하는 것이므로, 작업 증명은 곧 새 블록의 고유 해시 퍼즐을 해결했다는 의미이다. 모든 노드는 해시 퍼즐을 푸는 경쟁에 참여하게 되는데, 이 경쟁은 어떤 노드가 새 블록을 제출함과 동시에 끝난다. 새 블록을 제출한 노드는 품질 경쟁의 유일한 후보자가 된다.</p>
<ul>
<li>품질 경쟁</li>
</ul>
<p><strong>제출된 블록의 정확성에 초점을 맞춘다.</strong> 새 블록은 수신한 모든 모드는 트랜잭션 데이터와 블록 헤더의 검증 규칙에 기초하여 새 블록을 검증한다. <code>피어 통제</code>를 통해 매우 높은 정확성을 유지하도록 한다. 새 블록을 수령한 노드는 자신이 속도 경쟁에서 패했다는 사실을 깨달았으므로 꼼꼼한 심판관이 되고, 제출된 블록이 무효라면 또다시 속도 경쟁을 거쳐야 하므로 자신이 새 블록을 제출하여 승자가 될 수 있음을 알고 있다.</p>
<h4 id="5-피어-통제"><a href="#5-피어-통제" class="headerlink" title="5. 피어 통제"></a>5. 피어 통제</h4><p>시스템의 모든 노드는 다른 노드의 감시자인데, 새 블록을 생성하고 트랜잭션을 검사하면서도 다른 노드가 생성한 블록을 수신해서 검토하고 검증하는 역할을 한다. 즉 새 블록의 생성과 유효하지 않은 트랜잭션 데이터와 블록의 감지, 거절, 제거에 기여한다.</p>
<h3 id="작동원리-골격"><a href="#작동원리-골격" class="headerlink" title="작동원리: 골격"></a>작동원리: 골격</h3><p>시스템의 모든 노드는 다음 두 상태 중 하나에 속해 있다.</p>
<ol>
<li>피어에 의해 생성되고 제출된 새 블록을 평가 중</li>
<li>스스로 새 블록을 만들어 다른 피어에게 평가받으려 열심히 노력 중</li>
</ol>
<p>블록체인-알고리즘의 중요 역할은 모든 노드가 동일한 작업 상태를 가지도록 보장하는 것이고, 동일한 작업 상태는 모든 블록이 동일한 트랜잭션 데이터 이력을 유지하게 하는 핵심 개념이다. 상태를 결정하는 것은 개별 노드에게 도착하는 메시지인데, 각 노드가 새 블록을 담고 있는 메시지를 받자마자 평가 상태로 스위치되고, 평가 상태가 완료되자마자 새 트랜잭션을 검증하고 자체적으로 새 블록을 생성하기 위한 상태로 스위치된다.</p>
<h2 id="부정직한-노드는-어떻게-처리할까"><a href="#부정직한-노드는-어떻게-처리할까" class="headerlink" title="부정직한 노드는 어떻게 처리할까?"></a>부정직한 노드는 어떻게 처리할까?</h2><p>P2P 시스템에서 가장 두드러진 부정직한 행위는 다음과 같다.</p>
<ul>
<li>다른 사람으로 위장해 트랜잭션 제출</li>
<li>유효하지 않은 트랜잭션 데이터나 블록을 인정</li>
<li>노드를 다운시키기 위해 수많은 트랜잭션 데이터를 전송</li>
<li>특정 트랜잭션 데이터 처리를 거부</li>
<li>정보 전달을 거부</li>
</ul>
<p>이러한 부정직한 경우는 아래와 같이 처라힌다.</p>
<ul>
<li>해당 개인 키 소유자에게만 계정의 접근을 허용하는 트랜잭션의 보안 개념(비대칭 암호화 기법, 디지털 서명을 통한 식별, 인증, 승인)</li>
<li>모든 노드가 결국 모든 정보를 수신하는 것을 보장.</li>
<li>특정 노드가 잘못되거나 데이터 처리를 멈추어도 전체 시스템이 계속 작동하도록 보장하는 시스템 아키텍처</li>
<li>블록체인-알고리즘</li>
</ul>
<p><strong>블록체인이 부정직한 노드를 처리하는 가장 큰 무기는 정직한 다수의 힘과 보상 및 처벌의 효과이다.</strong></p>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/07/220308_blockchain03_12to15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/220308_blockchain03_12to15/" class="post-title-link" itemprop="url">블록체인 무엇인가? 3장 블록체인은 어떻게 작동하는가? 12 ~ 15단계</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-08 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-08T00:00:00+09:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-22 16:29:50" itemprop="dateModified" datetime="2022-06-22T16:29:50+09:00">2022-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="12-암호화-기법을-소개합니다"><a href="#12-암호화-기법을-소개합니다" class="headerlink" title="12. 암호화 기법을 소개합니다"></a>12. 암호화 기법을 소개합니다</h2><blockquote>
<p>블록체인에서 비대칭 암호화 기법은 사용자를 식별하고 자산을 보호하는 근간을 이룬다.</p>
</blockquote>
<h3 id="목표"><a href="#목표" class="headerlink" title="목표"></a>목표</h3><p>고유한 소유자와 자산을 식별하고, <em>법적으로 허가된 사람만 그 자산에 접근할 수 있도록 보장한다.</em></p>
<h3 id="해결해야-할-과제"><a href="#해결해야-할-과제" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><p>블록체인은 완전 개방된 P2P 시스템이고, 누구나 접속해서 계산 자원에 기여하고 새로운 트랜잭션을 시스템에 제출할 수 있다. <strong>단, 소유권을 다른 계정으로 이전할 권리는 오직 그 계정의 소유자에게 국한된다.</strong> 분산 시스템의 개방형 아키텍처를 해치지 않으면서 계정에 할당된 자산을 보호하는 것이 중요한 과제이다.</p>
<h3 id="아이디어"><a href="#아이디어" class="headerlink" title="아이디어"></a>아이디어</h3><p>누구나 자산을 보낼 수 있지만 모인 자산에는 계정의 소유자만 접근할 수 있다. 이를 <code>공개-개인-키 암호화</code>라고 하는데 <strong>소유권을 이전할 수 있는 계정을 식별할 때는 누구나 공개 키를 사용하고, 접근은 해당 개인 키를 가진 사람에게만 허용된다.</strong> 어디에나 있고 개방되어 있지만 열쇠가 있는 사람만이 열 수 있는 우편함의 성질과 같다.</p>
<h3 id="암호화-기법의-주요-아이디어"><a href="#암호화-기법의-주요-아이디어" class="headerlink" title="암호화 기법의 주요 아이디어"></a>암호화 기법의 주요 아이디어</h3><blockquote>
<p>허가받지 않은 사용자의 접근으로부터 데이터를 보호하고, 이를 위해 사용하는 것을 <code>키(key)</code>라 한다.</p>
</blockquote>
<ul>
<li><code>암호화</code>: 문을 잠그는 것의 디지털 구현</li>
<li><code>복호화</code>: 문을 여는 것의 디지털 구현</li>
<li><code>데이터 보호화 데이터 보호 해제</code>: 암호화와 복호화</li>
<li><code>암호문</code>: 암호화된 데이터</li>
<li><code>과정</code>: <code>암호화 키를 사용해 암호문 생성</code> -&gt; <code>암호문의 보관 또는 전송</code> -&gt; <code>암호화 키를 사용해 복호화</code> -&gt; <code>원시 데이터 복원</code></li>
</ul>
<h3 id="대칭-암호화-기법"><a href="#대칭-암호화-기법" class="headerlink" title="대칭 암호화 기법"></a>대칭 암호화 기법</h3><blockquote>
<p>데이터를 암호화하고 복호화할 때 <code>동일한 키</code>를 사용.</p>
</blockquote>
<p>동일한 키를 사용했기 때문에 암호화한 키가 있으면 동시에 복호화할 수 있는 키도 가지는 셈이다. 따라서 바람직하지 못하고 그래서 비대칭 암호화 기법이 발명되었다.</p>
<h3 id="비대칭-암호화-기법"><a href="#비대칭-암호화-기법" class="headerlink" title="비대칭 암호화 기법"></a>비대칭 암호화 기법</h3><blockquote>
<p><code>두 개의 상호보완적 키</code>를 사용.</p>
</blockquote>
<ul>
<li>두 키중 하나를 사용해 생성된 암호문은 오직 다른 하나의 키로만 복호화되고, 그 반대도 마찬가지이다.</li>
<li>암호문을 생성할 때 사용한 키로는 절대 암호를 복호화할 수 없다.</li>
<li>암호화 복호화를 할 때 <strong>항상 두 개의 키를 모두</strong> 가지고 있어야 한다. 둘 중 하나만 있으면 하는 일이 제한적이다.</li>
<li><em>암호문의 생성은 하나의 키만 있어도 언제든 가능하지만 상호보완적 쌍을 이루는 다른 키가 없다면 생성된 암호문을 복호화할 방법은 없다.</em></li>
<li>두 개의 키가 암호문을 생성할 수 있는 사람, 복호화할 수 있는 사람의 두 그룹으로 분리할 수 있게 해준다.</li>
<li>암호화 복호화의 역할은 서로 바뀔 수 있지만 <strong>개인 키와 공개 키의 역할은 절대 바뀔 수 없다. 공개 키는 비가역적 함수를 통해 개인 키로부터 생성된 것이다.</strong></li>
</ul>
<h3 id="실생활에서-비대칭-암호화-기법을-사용하는-방법"><a href="#실생활에서-비대칭-암호화-기법을-사용하는-방법" class="headerlink" title="실생활에서 비대칭 암호화 기법을 사용하는 방법"></a>실생활에서 비대칭 암호화 기법을 사용하는 방법</h3><h4 id="1-키의-생성과-배분"><a href="#1-키의-생성과-배분" class="headerlink" title="1. 키의 생성과 배분"></a>1. 키의 생성과 배분</h4><p>보통 두 개의 키 각각의 역할을 나타내는 특별한 이름을 붙인다. 그래서 비대칭 암호화 기법을 <code>공개-개인-키(공개-비밀-키)</code>라고 부른다. 공개 키는 신뢰 여부와 상관없이 누구에게나 주어지기 때문에 누구나 공개 키의 복사본을 가질 수 있고, <em>개인 키는 안전하게 사적으로 보관해야 한다.</em> 아래는 비대칭 암호화 기법 응용프로그램의 수행 단계이다.</p>
<ul>
<li>암호화 소프트웨어를 사용해서 개인 키를 생성한다.</li>
<li>상호보완적인 공개 키를 생성한다.</li>
<li>개인 키는 간직한다.</li>
<li>공개 키는 모두에게 배부한다.</li>
</ul>
<h4 id="2-키의-사용"><a href="#2-키의-사용" class="headerlink" title="2. 키의 사용"></a>2. 키의 사용</h4><h5 id="1-공개-gt-개인"><a href="#1-공개-gt-개인" class="headerlink" title="1. 공개 -&gt; 개인"></a>1. 공개 -&gt; 개인</h5><ul>
<li><code>공개 키</code>: 정보를 <code>암호화</code></li>
<li><code>개인 키</code>: 정보를 <code>복호화</code></li>
</ul>
<p>누구나 암호문을 생성할 수 있지만 개인 키를 가진 소유자만이 암호문을 복호화하고 메시지를 읽을 수 있다.</p>
<h5 id="2-개인-gt-공개"><a href="#2-개인-gt-공개" class="headerlink" title="2. 개인 -&gt; 공개"></a>2. 개인 -&gt; 공개</h5><ul>
<li><code>공개 키</code>: 정보를 <code>복호화</code></li>
<li><code>개인 키</code>: 정보를 <code>암호화</code></li>
</ul>
<p>공개 키의 복사본을 가진 사람은 누구나 메시지를 읽을 수 있지만 모두에게 공개할 메시지는 오직 개인 키를 가진 소유자만이 생성가능하다. 저작권 증명에 주로 사용하면 좋다.</p>
<h4 id="블록체인에서-비대칭-암호화-기법은-언제-쓸까"><a href="#블록체인에서-비대칭-암호화-기법은-언제-쓸까" class="headerlink" title="블록체인에서 비대칭 암호화 기법은 언제 쓸까?"></a>블록체인에서 비대칭 암호화 기법은 언제 쓸까?</h4><blockquote>
<ol>
<li>계정 식별</li>
<li>트랜잭션 승인</li>
</ol>
</blockquote>
<h5 id="1-계정-식별"><a href="#1-계정-식별" class="headerlink" title="1. 계정 식별"></a>1. 계정 식별</h5><ul>
<li>소유자와 자산의 매핑 유지를 위해 사용자와 사용자 계정을 모두 식별해야 한다.</li>
<li><code>공개 -&gt; 개인 접근 방식</code>을 사용해서 사용자 계정을 식별하고, 사용자가 소유권을 이전한다.</li>
<li>블록체인의 계정 번호는 공개 암호 키라서 공개된 주소를 통해 누구나 메시지를 전송할 수 있다.</li>
</ul>
<h5 id="2-트랜잭션-승인"><a href="#2-트랜잭션-승인" class="headerlink" title="2. 트랜잭션 승인"></a>2. 트랜잭션 승인</h5><ul>
<li>소유권 양도에 관한 내용에 그 소유권자가 동의했는지를 증명하는 데이터를 항상 포함한다.</li>
<li><code>개인 -&gt; 공개 접근 방식</code>과 유사하여, 소유자는 개인 키를 사용해 암호문을 생성하고, 다른 모든 사람은 공개 암호 키를 사용해 거래를 증명할 수 있다.</li>
<li>공개 암호 키는 소유권을 이전하려는 계정 번호와 같다.</li>
</ul>
<hr>
<h2 id="13-노드-여러분-트랜잭션을-승인합니까"><a href="#13-노드-여러분-트랜잭션을-승인합니까" class="headerlink" title="13. 노드 여러분, 트랜잭션을 승인합니까?"></a>13. 노드 여러분, 트랜잭션을 승인합니까?</h2><blockquote>
<p>디지털 서명 만들어 검증에 사용하기. 자필 서명과 유사하게 전자 원장에 트랜잭션에 동의한다고 표시한다. <code>개별 트랜잭션의 보안</code>을 위해 절대적으로 중요하다.</p>
</blockquote>
<h3 id="목표-1"><a href="#목표-1" class="headerlink" title="목표"></a>목표</h3><p><em>계정의 소유자 또는 합법적 소유자만</em> 계정 내 자산을 다른 계정으로 이전할 수 있도록 보장한다.</p>
<h3 id="해결해야-할-과제-1"><a href="#해결해야-할-과제-1" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><blockquote>
<p>합법적 소유자로만 이전 권한 제한 + 개방성 유지</p>
</blockquote>
<p>P2P 시스템은 누구에게나 개방되어 있어 모든 사람이 트랜잭션을 생성하고 시스템에 제출할 수 있지만 이전은 계정의 합법적 소유자만이 가능하다.</p>
<h3 id="아이디어-1"><a href="#아이디어-1" class="headerlink" title="아이디어"></a>아이디어</h3><p>자필 서명의 기능을 디지털 버전으로 만들어 계정을 식별, 인증, 허가를 가능하게 한다.</p>
<h3 id="디지털-서명의-주요-기능-알아보기"><a href="#디지털-서명의-주요-기능-알아보기" class="headerlink" title="디지털 서명의 주요 기능 알아보기"></a>디지털 서명의 주요 기능 알아보기</h3><p>개인 -&gt; 공개 방식의 정보 흐름을 활용한다.</p>
<h4 id="디지털-서명의-3대-주요-요소"><a href="#디지털-서명의-3대-주요-요소" class="headerlink" title="디지털 서명의 3대 주요 요소"></a>디지털 서명의 3대 주요 요소</h4><ol>
<li>서명의 생성</li>
</ol>
<ul>
<li>특정 데이터에 대한 프로세스가 시작되면 입력된 데이터에 해당하는 해시값을 생성하고, 개인 키를 사용해서 암호화한다. <strong>해시값의 암호문이 바로 디지털 서명이다.</strong></li>
<li>고유한 개인 키를 사용해 생성되었기 때문에 누가 생성했는지 특정할 수 있다.</li>
<li>특정 데이터의 디지털 지문(해시값)에 의해 생성되었기 때문에 고유한 데이터이다.</li>
</ul>
<ol>
<li>서명을 이용한 데이터 검증</li>
</ol>
<ul>
<li>모든 사람이 나의 공개 키를 활용하여 암호문으로부터 복호화된 값을 얻을 수 있다.</li>
<li>메시지 수신자는 받은 데이터의 해시값을 스스로 계산해본다.</li>
<li>수신자가 계산한 해시값과 복호화된 값이 일치하면 수신자는 아래의 두 가지 사실을 알 수 있다.</li>
<li>나의 공개 키를 사용해 서명을 복호화할 수 있었기 때문에 내가 서명한 것이다.</li>
<li>복호화된 암호문이 최초에 보내려고 했던 데이터의 해시값과 일치한다.</li>
</ul>
<ol>
<li>서명을 이용한 사기 판별</li>
</ol>
<ul>
<li>메시지 수신자가 받은 데이터의 해시값을 스스로 생성한다.</li>
<li>공개 키를 이용해 디지털 서명을 복호화하여 복호화된 원래 데이터 해시값을 얻는다.</li>
<li><em>수신자가 계산한 해시값과 복호화하여 얻은 해시값이 다르면 이는 문제가 있다.</em></li>
</ul>
<h3 id="작동원리"><a href="#작동원리" class="headerlink" title="작동원리"></a>작동원리</h3><ul>
<li>트랜잭션 데이터는 계정의 소유자가 소유권을 이전하는 데 동의했다는 사실을 알려준다</li>
<li>트랜잭션의 전체 내용은 고유하므로 서명한 사람의 동의 없이 다른 트랜잭션의 서명으로 사용할 수 없다. <em>트랜잭션 내용이 바뀌면 소유자가 새로 서명을 생성해야 한다.</em></li>
<li><strong>소유권을 이전하려는 계정의 소유자만이 서명을 생성할 수 있다.</strong></li>
<li>누구나 쉽게 검증할 수 있다.</li>
</ul>
<h4 id="블록체인에서-디지털-서명의-용도"><a href="#블록체인에서-디지털-서명의-용도" class="headerlink" title="블록체인에서 디지털 서명의 용도"></a>블록체인에서 디지털 서명의 용도</h4><ul>
<li><p>트랜잭션 서명</p>
<ul>
<li>트랜잭션에 필요한 모든 정보를 기술</li>
<li>트랜잭션 데이터의 암호화 해시값 생성</li>
<li>소유권을 이전하려는 계정의 <code>개인 키</code>를 사용해 트랜잭션의 해시값 암호화</li>
<li>암호문을 트랜잭션에 디지털 서명으로 첨부</li>
</ul>
</li>
<li><p>트랜잭션 검증</p>
<ul>
<li>서명을 제외하고 검증한 트랜잭션 데이터의 해시값 생성</li>
<li>검증하려는 트랜잭션의 디지털 서명 복호화</li>
<li><code>검증된 트랜잭션 데이터의 해시값</code>과 <code>검증하려는 트랜잭션의 디지털 서명을 복호화한 두 값</code>을 비교한다. 값이 동일하면 소유권을 이전하려는 계정에 해당하는 개인 키 소유자가 승인한 트랜잭션이고, 다르면 그렇지 않다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="14-블록체인-데이터-구조를-만들어봅시다"><a href="#14-블록체인-데이터-구조를-만들어봅시다" class="headerlink" title="14. 블록체인-데이터-구조를 만들어봅시다"></a>14. 블록체인-데이터-구조를 만들어봅시다</h2><blockquote>
<p>전체 트랜잭션 데이터 구축 및 유지하기</p>
</blockquote>
<h3 id="목표-2"><a href="#목표-2" class="headerlink" title="목표"></a>목표</h3><p>전체 트랜잭션 이력을 정렬 상태로 유지한다.</p>
<h3 id="해결해야-할-과제-2"><a href="#해결해야-할-과제-2" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><p>모든 트랜잭션 데이터를 <em>발생 순서를 유지하면서</em> 어떠한 변경이 있을 경우 재빨리 감지할 수 있도록 저장한다.</p>
<h3 id="아이디어-2"><a href="#아이디어-2" class="headerlink" title="아이디어"></a>아이디어</h3><ul>
<li>트랜잭션이 추가된 순서대로 정렬괸다.</li>
<li>데이터는 해시 참조를 사용해 변경-감지 방식으로 저장된다.</li>
</ul>
<h3 id="책을-블록체인-데이터-구조로-변환하기"><a href="#책을-블록체인-데이터-구조로-변환하기" class="headerlink" title="책을 블록체인-데이터-구조로 변환하기"></a>책을 블록체인-데이터-구조로 변환하기</h3><ol>
<li>페이지 의존성을 분명히 드러내기<br>책에서 페이지는 번호가 연속되는지 검증하여 어떤 페이지가 없는지 바로 알 수 있다. 특히 각 페이지에 현재 번호와 직적 페이지 번호를 같이 표시하게 되면 현재 페이지와 직전 페이지 사이의 종속관계를 형성하여 어떤 방식으로 페이지 번호를 매기던 사라지 페이지를 탐색할 수 있다.</li>
<li>내용과 페이지 번호 분리하기<br>책의 한 페이지는 내용과 페이지의 번호로 구성된다. 여기서 페이지에 있는 내용을 덜어낸 후 그 내용이 어디있는지에 대한 참조값만을 남긴다.</li>
<li>페이지 번호를 참조값으로 대체하기<br>내용 뿐 아니라 페이지 번호도 참조값으로 대체한다.</li>
<li>참조값 생성하기<br>암호화 해시값을 사용해서 고유한 참조값을 생성한다. 책의 페이지 참조값은 페이지의 내용(내용 참조값과 앞 페이지 참조값)에 기반해 계산한다.</li>
<li>책등 없애기<br>책등을 없애서 페이지 정렬이 엉망이 되었다고 해도 각 페이지가 앞 페이지의 참조값을 가지고 있기 때문에 이를 이용해서 <em>페이지에서 페이지로 역으로 추적해 순서를 알아낼 수 있다.</em></li>
</ol>
<h3 id="목표-달성-결과-평가"><a href="#목표-달성-결과-평가" class="headerlink" title="목표 달성: 결과 평가"></a>목표 달성: 결과 평가</h3><ul>
<li>정보 저장으로부터 순서를 분리하고, 페이지의 물리적 위치로부터 논리적 위치(순서)를 분리해 냈다.</li>
<li>참조값으로 해시값을 사용했기 때문에 누구나 간단한 계산을 통해 정확성을 검증할 수 있다.</li>
<li>페이지들은 더 이상 책등에 붙어있지 않으므로 <strong>오직 직전 페이지 참조값을 이용해 페이지에서 페이지로 거꾸로 탐색할 수 밖에 없다.</strong></li>
</ul>
<h3 id="변환된-책으로-블록체인-데이터-구조-이해하기"><a href="#변환된-책으로-블록체인-데이터-구조-이해하기" class="headerlink" title="변환된 책으로 블록체인-데이터-구조 이해하기"></a>변환된 책으로 블록체인-데이터-구조 이해하기</h3><div class="table-container">
<table>
<thead>
<tr>
<th>변환된 책</th>
<th>블록체인-데이터-구조</th>
</tr>
</thead>
<tbody>
<tr>
<td>순서일람표의 페이지</td>
<td>블록 헤더</td>
</tr>
<tr>
<td>전체 순서일람표</td>
<td>블록 헤더의 체인</td>
</tr>
<tr>
<td>순서일람표의 페이지 참조값</td>
<td>블록 헤더의 암호화 해시값</td>
</tr>
<tr>
<td>내용</td>
<td>트랜잭션 데이터</td>
</tr>
<tr>
<td>내용 페이지</td>
<td>트랜잭션 데이터를 가진 머클 트리</td>
</tr>
<tr>
<td>내용 페이지를 가리키는 참조값</td>
<td>트랜잭션 데이터를 가진 머클 트리의 루트</td>
</tr>
<tr>
<td>순서일람표 페이지와 해당 내용 페이지로 구성된 가상의 단위</td>
<td>블록체인-데이터-구조의 한 블록</td>
</tr>
<tr>
<td>전체 순서일람표와 전체 내용 페이지</td>
<td>블록체인-데이터-구조</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>순서일람표 페이지와 해당 내용 페이지로 구성된 가상 단위<br>전자는 해시 참조를 통해 후자를 참조함으로써 가상의 한 단위를 형성한다. <strong>이것을 블록이라 하고, 블록들이 모두 모여 블록체인-데이터-구조를 형성한다.</strong></li>
<li>순서일람표라 불리는 페이지 더미<br>블록체인-데이터-구조 내 단일 블록 헤더와 동일하다. 참조를 통해 선형으로 연결되어 블록 헤더의 체인을 형성한다. <strong>트랜잭션 데이터를 직접 저장하지 않고 해당 트랜잭션 데이터에 대한 해시 참조만 저장한다.</strong></li>
<li>내용을 담고 있는 페이지 더미<br>변환된 책의 내용은 <strong>블록체인에 의해 유지되는 트랜잭션 데이터</strong>와 같다. 다만 이는 이해를 돕기 위한 개념이며, 실제 블록체인 응용은 내용 데이터(트랜잭션 데이터)를 머클 트리라 불리는 데이터베이스에 직접 저장하고, 머클 트리의 루트는 블록 헤더에 저장된다.</li>
<li>순서일람표 페이지를 식별하고 연결할 페이지 참조값<br>페이지 참조값은 <strong>블록체인-데이터-구조 내 개별 블록 헤더의 암호화 해시값과 같다.</strong> 블록 해시 또는 이전 블록의 해시라 불리고, 각 블록 헤더를 고유하게 식별하고 이전 블록 헤더를 참조하기 위해 사용된다.</li>
<li>내용 페이지를 식별하고 연결할 내용 참조값<br>연계된 트랜잭션 데이터를 가리키는 블록 헤더의 해시 참조와 같다. 블록 헤더에 저장된 내용 참조값은 데이터베이스에 저장된 트랜잭션 데이터의 머클 트리 루트이다.</li>
</ol>
<h3 id="블록체인-데이터-구조에서-트랜잭션-저장하는-방법"><a href="#블록체인-데이터-구조에서-트랜잭션-저장하는-방법" class="headerlink" title="블록체인-데이터-구조에서 트랜잭션 저장하는 방법"></a>블록체인-데이터-구조에서 트랜잭션 저장하는 방법</h3><p>각 블록은 블록 헤러를 가지고 있고, 이전 블록이 있으면 이전 블록 헤더를 가리키는 해시 참조를 가지고 있다. 다시 말하면 각기 다른 두 개의 머클 트리를 가리키는 해시 참조를 가지고 있다. 그리고 머클 트리 루트의 이름을 보며 이들이 가진 트랜잭션 데이터가 무엇인지 짐작할 수 있다. P2P 시스템을 생각해보면, <em>이 시스템에 참여했을 때 전체 트랜잭션 데이터, 모든 해시 참조값, 모든 블록헤더를 수신하게 된다.</em> <strong>즉 로컬 컴퓨터는 데이터를 모두 저장하고 저장된 데이터들을 가리키는 해시 참조를 가진 블록체인-데이터-구조를 생성한다.</strong> 여기서 주의할 점은 블록체인-데이터-구조에 각자의 헤더를 가진 수많은 블록이 존재하지만 전체 블록체인-데이터-구조는 오직 하나의 헤드만 가진다는 점이다.</p>
<hr>
<h2 id="15-잘-뜨개질된-블록체인-어떻게-변경할까"><a href="#15-잘-뜨개질된-블록체인-어떻게-변경할까" class="headerlink" title="15. 잘 뜨개질된 블록체인, 어떻게 변경할까?"></a>15. 잘 뜨개질된 블록체인, 어떻게 변경할까?</h2><h3 id="새로운-트랜잭션-추가하기"><a href="#새로운-트랜잭션-추가하기" class="headerlink" title="새로운 트랜잭션 추가하기"></a>새로운 트랜잭션 추가하기</h3><p>최초의 블록체인-데이터-구조는 단 두 개의 트랜잭션만 가지고 있는데, 새 트랜잭션 데이터를 추가하려면 다음의 세 단계를 수행한다.</p>
<ol>
<li>새로 추가하려는 모든 트랜잭션 데이터를 담고 있는 <code>새 머클 트리 생성</code></li>
<li>이전 블록 헤더를 가리키는 해시 참조와 새로운 트랜잭션 데이터를 담고 있는 머클 트리의 루트를 포함하는 <code>새 블록 헤더 생성</code></li>
<li><code>새 블록을 카리키는 해시 참조를 만들고 블록체인-데이터-구조의 헤드 갱신</code></li>
</ol>
<h3 id="변경-감지하기"><a href="#변경-감지하기" class="headerlink" title="변경 감지하기"></a>변경 감지하기</h3><p>블록체인-데이터-구조 내 변경이 발생하면 연쇄 반응을 일으켜 즉시 감지 가능하고, 변경 발생 유형은 아래와 같다.</p>
<ol>
<li>트랜잭션 데이터의 세부 사항 변경</li>
<li>머클 트리의 트랜잭션을 변경하고, 해시 참조를 변경</li>
<li>머클 트리의 트랜잭션과 그 해시 참조를 통째로 대체</li>
<li>머클 트리 루트를 변경</li>
<li>블록 헤더 참조를 변경</li>
</ol>
<p>위의 유형들처럼 트랜잭션이 하나 변경되면 부모 노드를 따라 연쇄반응을 일으켜 블록 헤더값이 변경된다. 이는 자신을 참조하는 블록의 헤더값에 영향을 끼치므로 모든 값에 영향을 미친다. 따라서 제대로 된 방법으로 데이터를 변경하려면 전체 해시 참조 연결고리를 모두 갱신해야하는데, <em>이는 변경된 데이터를 직접 가리키는 해시 참조로부터 시작하여 가장 최근 블록 헤더를 가리키는 해시 참조까지 모든 해시 참조를 갱신하여 변경 내용을 반영한다는 것이다.</em></p>
<h3 id="의도한-변경-vs-의도하지-않은-변경"><a href="#의도한-변경-vs-의도하지-않은-변경" class="headerlink" title="의도한 변경 vs 의도하지 않은 변경"></a>의도한 변경 vs 의도하지 않은 변경</h3><p>해시 참조의 성질에 의해 블록체인-데이터-구조의 해시 참조는 의도된 변경, 의도하지 않은 변경을 구분하지 않고 동일하게 인식한다. 그리고 의도와 상관없이 어느 해시 참조 중 하나라도 유효하지 않으면 전체 데이터 구조가 무효화된다.</p>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Heejin Lee</p>
  <div class="site-description" itemprop="description">Today I Learned</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">127</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heejin Lee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
