<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heejinlee07.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="프로세스의 개념 프로세스: 수행중인 프로그램 프로세스 문맥(context): 프로세스가 현재 어떤 상태에서 수행되고 있는지를 정확히 규명하기 위해 필요한 정보 프로세스 문맥이 중요한 이유 : 타임 쉐어링, 멀티태스킹 등 프로세스들이 번갈아가며 실행되기 때문에 프로세스의 문맥을 파악하고 있어야 이미 실행되던 프로세스를 처음부터 다시 실행한다던가 하는 문제가">
<meta property="og:type" content="article">
<meta property="og:title" content="Operating Systems - 프로세스 관리">
<meta property="og:url" content="https://heejinlee07.github.io/2022/05/19/220520_os3/index.html">
<meta property="og:site_name" content="Heejin">
<meta property="og:description" content="프로세스의 개념 프로세스: 수행중인 프로그램 프로세스 문맥(context): 프로세스가 현재 어떤 상태에서 수행되고 있는지를 정확히 규명하기 위해 필요한 정보 프로세스 문맥이 중요한 이유 : 타임 쉐어링, 멀티태스킹 등 프로세스들이 번갈아가며 실행되기 때문에 프로세스의 문맥을 파악하고 있어야 이미 실행되던 프로세스를 처음부터 다시 실행한다던가 하는 문제가">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-05-19T15:00:00.000Z">
<meta property="article:modified_time" content="2022-05-20T04:27:10.760Z">
<meta property="article:author" content="Heejin Lee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://heejinlee07.github.io/2022/05/19/220520_os3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Operating Systems - 프로세스 관리 | Heejin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heejin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Front-end Developer</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/05/19/220520_os3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Operating Systems - 프로세스 관리
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-20 00:00:00 / Modified: 13:27:10" itemprop="dateCreated datePublished" datetime="2022-05-20T00:00:00+09:00">2022-05-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="프로세스의-개념"><a href="#프로세스의-개념" class="headerlink" title="프로세스의 개념"></a>프로세스의 개념</h2><ul>
<li><code>프로세스</code>: 수행중인 프로그램</li>
<li><code>프로세스 문맥(context)</code>: 프로세스가 현재 어떤 상태에서 수행되고 있는지를 정확히 규명하기 위해 필요한 정보</li>
<li><code>프로세스 문맥이 중요한 이유</code> : 타임 쉐어링, 멀티태스킹 등 프로세스들이 번갈아가며 실행되기 때문에 프로세스의 문맥을 파악하고 있어야 이미 실행되던 프로세스를 처음부터 다시 실행한다던가 하는 문제가 생기지 않는다.</li>
</ul>
<p>프로세스 문맥을 파악하려면 다음의 3가지 요소를 알아야 한다.</p>
<ul>
<li>프로그램 카운터가 어디를 가리키고 있는가? (code의 어느 부분까지 실행했는가?)</li>
<li>메모리에 어떤 내용을 담고 있는가?</li>
<li>레지스터에 어떤 값을 넣어두고, 어떤 instruction(프로그램의 기계어를 읽어서 CPU 안으로 불러들임)까지 실행했는가?</li>
</ul>
<h3 id="프로세스-문맥의-분류"><a href="#프로세스-문맥의-분류" class="headerlink" title="프로세스 문맥의 분류"></a>프로세스 문맥의 분류</h3><ul>
<li>하드웨어 문맥: <strong>CPU의 수행상태.</strong> 카운터 값, 각종 레지스터에 저장하고 있는 값들</li>
<li>프로세스의 주소 공간: <strong>프로세스는 코드, 데이터, 스택으로 구성되는 자기만의 독자적인 주소 공간을 가지고 있고,</strong> 이것이 프로세스의 문맥을 결정짓는 중요한 요소이다.</li>
<li>커널 상의 문맥: 프로그램이 수행되어 프로세스가 되면 <strong>프로세스를 관리하기 위한 자료 구조를 유지하게 된다.</strong> PCB, 커널 스택이 이에 해당한다.</li>
</ul>
<h2 id="프로세스의-상태"><a href="#프로세스의-상태" class="headerlink" title="프로세스의 상태"></a>프로세스의 상태</h2><blockquote>
<p>프로세스는 상태가 변경되며 수행되고, 항상 아래 상태 중 어느 한 상태에 머물러 있게 된다.</p>
</blockquote>
<ul>
<li><code>실행 상태(running)</code>: 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태. CPU는 하나 뿐이기 때문에 여러 프로세스가 동시에 실행된다고 해도 <strong>실제 실행 상태에 있는 프로세스는 매 시점 하나 뿐이다.</strong></li>
<li><code>준비 상태(ready)</code>: 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태.</li>
<li><code>봉쇄 상태(blocked, wait, sleep)</code>: 프로세스에게 CPU를 주어도 당장 명령을 실행할 수 없는 상태.</li>
<li><code>시작 상태(new)</code>: 프로세스가 시작되어 각종 자료 구조가 생성되었지만 아직 메모리 획득을 승인받지 못한 상태</li>
<li><code>완료 상태(terminated)</code>: 프로세스가 종료되었으나 운영 체제가 프로세스와 관련된 자료 구조를 완전히 정리하지 못한 상태</li>
<li><p><code>중지(stopped, suspended)</code>: 중기 스케줄러의 등장으로 추가된 상태. 외부적인 이유로 프로세스의 수행이 정지된 상태이다.</p>
<ul>
<li><code>중지 준비(suspended ready)</code>: <strong>준비 상태에 있던</strong> 프로세스가 중기 스케줄러에 의해 디스크로 스왑 아웃되면 중지 준비 상태가 된다. 외부에서 재개시키지 않는 이상 다시 활성화되지 않는다.</li>
<li><p><code>중지 봉쇄(suspended block)</code>: <strong>봉쇄 상태에 있던</strong> 프로세스가 중기 스케줄러에 의해 스왑 아웃된다. 이 상태에서 프로세스가 봉쇄되었던 조건을 만족하면 중지 준비 상태로 바뀐다.</p>
</li>
<li><p><strong>봉쇄 상태와 중지 상태의 차이</strong></p>
<ul>
<li>봉쇄 상태: 자신이 요청한 이벤트가 만족되어야 Ready</li>
<li>중지 상태: 외부에서 resume를 해주어야 Active</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>프로세스의 상태는 시간의 흐름에 따라 변화한다. <em>준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정을 <code>CPU 디스패치</code>라고 한다.</em><br><code>new</code> -&gt; <code>메모리 적재</code> -&gt; <code>ready(in memory)</code> -&gt; <code>CPU 획득(디스패치)</code> -&gt; <code>running</code> -&gt; <code>terminated</code></li>
<li><p>타이머 인터럽트가 발생한 경우 원래 진행하던 프로세스의 문맥을 저장하고, ready 상태에 있는 프로세스 중 하나에 새롭게 CPU 제어권을 부여하고 실행한다. <em>실행시킬 프로세스를 변경하기 위해 원래 수행중이던 프로세스의 문맥을 저장하고, 새로운 프로세스의 문맥을 세팅하는 과정을 <code>문맥 교환(context switch)</code>이라 한다.</em><br><code>new</code> -&gt; <code>메모리 적재</code> -&gt; <code>ready(in memory)</code> -&gt; <code>CPU 획득(디스패치)</code> -&gt; <code>running</code> -&gt; <em><code>타이머 인터럽트</code></em> -&gt; <code>ready</code></p>
<h3 id="문맥교환"><a href="#문맥교환" class="headerlink" title="문맥교환"></a>문맥교환</h3><blockquote>
<p>하나의 사용자 프로세스로부터 다른 사용자 프로세스로 <em>CPU의 제어권이 이양되는 과정</em></p>
</blockquote>
<h4 id="문맥-교환의-과정"><a href="#문맥-교환의-과정" class="headerlink" title="문맥 교환의 과정"></a>문맥 교환의 과정</h4><ul>
<li>원래 CPU를 보유하고 있던 프로세스가 프로세스 카운터 값 등 <strong>프로세스의 문맥을 자신의 PCB에 저장</strong></li>
<li>새롭게 CPU를 할당받을 프로세스가 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원</li>
<li>타이머 인터럽트나 I/O 요청으로 프로그램이 봉쇄 상태인 경우 문맥 교환이 발생하지만 <strong>그 밖의 인터럽트나 시스템 콜 발생 시에는 모드 변경만 있다.</strong> 프로세스의 실행 모드가 사용자에서 커널로 변경된 것일 뿐, CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 것이 아니기 때문이다.</li>
<li><p>프로세스 간 문맥 교환이 빈번해지면 오버헤드도 상당히 커진다.</p>
<ul>
<li><p>문맥 교환이 발생하지 않는 경우<br><code>user mode(사용자 프로세스 A)</code> -&gt; <em><code>interrupt or system call</code></em> -&gt; <code>kernel mode(ISR or system call 함수)</code> -&gt; -&gt; <em><code>문맥 교환 없이 user mode 복귀</code></em> -&gt; <code>user mode(사용자 프로세스 A)</code></p>
</li>
<li><p>문맥 교환이 발생하는 경우<br><code>user mode(사용자 프로세스 A)</code> -&gt; <em><code>timer interrupt or I/O 요청 system call</code></em> -&gt; <code>kernel mode</code> -&gt; <em><code>문맥 교환 발생</code></em> -&gt; <code>user mode(사용자 프로세스 B)</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O 요청이 발생한 경우에도 실행 상태에 있던 프로세스가 봉쇄 상태로 바뀌는 문맥 교환이 발생한다.<br><code>new</code> -&gt; <code>메모리 적재</code> -&gt; <code>ready(in memory)</code> -&gt; <code>CPU 획득(디스패치)</code> -&gt; <code>running</code> -&gt; <em><code>I/O 또는 사건 대기</code></em> -&gt; <em><code>waiting(blocked)</code></em> -&gt; <em><code>I/O 또는 사건 완료</code></em> -&gt; <code>ready</code></p>
</li>
</ol>
<hr>
<h2 id="프로세스-제어-블록-PCB-Process-Control-Block"><a href="#프로세스-제어-블록-PCB-Process-Control-Block" class="headerlink" title="프로세스 제어 블록 (PCB: Process Control Block)"></a>프로세스 제어 블록 (PCB: Process Control Block)</h2><p>운영 체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스당 유지하는 정보를 담는 커널 내의 자료 구조</p>
<table>
  <tr>
    <td rowspan="2">1.<br> 
    OS가 사용하는 정보</td>
    <td>pointer</td>
    <td>process state</td>
  </tr>
  <tr>
    <td colspan="3">process number</td>
  </tr>
    <tr>
    <td rowspan="2">2.<br>CPU 수행 관련 하드웨어 값</td>
    <td colspan="3">process counter</td>
  </tr>
    <tr>
    <td colspan="3">registers</td>
  </tr>
    <tr>
    <td>3.<br>메모리 관련</td>
    <td colspan="3">memory limits</td>
  </tr>
  </tr>
    <tr>
    <td rowspan="2">4.<br>파일 관련</td>
    <td colspan="3">open files</td>
  </tr>
    </tr>
    <tr>
    <td colspan="3">...</td>
  </tr>
</table>

<hr>
<h2 id="프로세스를-스케줄링하기-위한-큐"><a href="#프로세스를-스케줄링하기-위한-큐" class="headerlink" title="프로세스를 스케줄링하기 위한 큐"></a>프로세스를 스케줄링하기 위한 큐</h2><blockquote>
<p>프로세스는 각 큐를 오가며 수행한다.</p>
</blockquote>
<ul>
<li><code>작업 큐(job queue)</code>: 시스템 내 모든 프로세스를 관리하기 위한 큐. <em>프로세스 상태와 무관하게 모든 프로세스 상태가 속하지만 작업 큐에 있다고 해서 반드시 메모리를 가진 것은 아니다.</em></li>
<li><code>준비 큐(ready queue)</code>: CPU를 할당받고 실행되기 위해 기다리고 있는 프로세스의 집합. <em>프로세스는 준비 상태</em></li>
<li><code>장치 큐(device queue)</code>: 각각의 장치마다 서비스를 기다리며 줄 서 있는 프로세스의 큐. <em>프로세스는 봉쇄 상태</em></li>
</ul>
<hr>
<h2 id="스케줄러"><a href="#스케줄러" class="headerlink" title="스케줄러"></a>스케줄러</h2><blockquote>
<p>어떤 프로세스에게 자원을 할당할지를 결정하는 운영 체제 커널의 모듈</p>
</blockquote>
<ul>
<li><code>장기 스케줄러(job scheduler)</code>: <strong>어떤 프로세스를 준비 큐에 삽입할지를 결정한다.</strong> 준비 큐는 CPU만 얻으면 당장 실행 가능한 프로세스이기 때문에 메모리를 보유해야 하고, <strong>메모리 또는 각종 자원을 얼마나 할당할지에 대해서도 관여한다.</strong></li>
<li>수십 초 내 수 분 단위로 가끔 호출되므로 상대적으로 속도가 느려도 된다.</li>
<li>메모리에 동시에 올라가 있는 프로세스의 수를 조절한다.</li>
<li>현대 시분할 시스템에서는 보통 장기 스케줄러가 없다.</li>
</ul>
<p>중기 스케줄러: 현대 시분할 시스템용 운영체제에서 사용한다. 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하될 때 메모리에 적재된 프로세스의 수를 동적으로 조절한다.<br>프로세스당 보유 메모리량이 지나치게 적으면 일부 프로세스를 메모리에서 디스크로 스왑 아웃시킨다.</p>
<ul>
<li><code>단기 스케줄러(CPU scheduler)</code>: 준비 상태의 프로세스 중에서 <strong>어떤 프로세스를 다음 번에 실행 상태로 만들 것인지 결정한다.</strong> 준비 큐에 있는 프로세스 중 어떤 프로세스에게 CPU를 할당할지를 결정하고, <em>시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다.</em></li>
<li>ms 이하 단위로 매우 빈번하게 호출되므로 속도가 빨라야 한다.</li>
</ul>
<hr>
<h2 id="프로세스의-생성"><a href="#프로세스의-생성" class="headerlink" title="프로세스의 생성"></a>프로세스의 생성</h2><blockquote>
<p>시스템 부팅 후 최초의 프로세스는 운영 체제가 생성하고, 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성</p>
</blockquote>
<ul>
<li>부모 프로세스: 프로세스를 생성한 프로세스</li>
<li>자식 프로세스: 새롭게 생성된 프로세스</li>
</ul>
<p>부모 프로세스가 자식 프로세스를 생성하는 방식으로 족보(Tree)와 같은 계층 구조를 형성한다.</p>
<h3 id="프로세스의-작업-수행"><a href="#프로세스의-작업-수행" class="headerlink" title="프로세스의 작업 수행"></a>프로세스의 작업 수행</h3><p>프로세스가 작업을 하려면 자원이 필요한데 아래와 같은 세가지 유형으로 자원을 공유한다.</p>
<ul>
<li>부모-자식이 모든 자원을 공유</li>
<li>일부를 공유</li>
<li>전혀 공유하지 않음</li>
</ul>
<h3 id="프로세스가-수행되는-모델"><a href="#프로세스가-수행되는-모델" class="headerlink" title="프로세스가 수행되는 모델"></a>프로세스가 수행되는 모델</h3><ul>
<li>부모-자식이 공존하며 수행: 자식과 부모가 CPU를 획득하기 위해 경쟁하는 관계.</li>
<li>자식이 종료될 때까지 부모가 기다림: 자식 프로세스가 종료될 때까지 부모 프로세스는 봉쇄 상태에 있다가 자식 프로세스가 종료되면 부모는 준비 상태가 되어 다시 CPU를 얻을 권한이 생긴다.</li>
</ul>
<h3 id="프로세스의-생성-절차"><a href="#프로세스의-생성-절차" class="headerlink" title="프로세스의 생성 절차"></a>프로세스의 생성 절차</h3><blockquote>
<p>프로세스는 생성되면 자신만의 독자적인 주소 공간을 갖고, <strong>자식 프로세스는 부모 프로세스의 주소 공간 내용을 그대로 복사해서 생성한다.</strong></p>
</blockquote>
<ul>
<li><p><code>생성</code>: 유닉스에서는 fork() 시스템 콜로 새로운 프로세스를 생성하고, 자식 프로세스를 생성할 때 부모 프로세스의 내용을 그대로 복제 생성한다. 부모 프로세스의 모든 문맥을 복제해서 생성되었기 때문에 부모 프로세스가 현재 수행한 시점(프로그램 카운터 지점)부터 수행할 수 있다.</p>
</li>
<li><p><code>종료</code>: 부모 프로세스 종료 전에 자식 프로세스부터 종료되어야 한다.</p>
<ul>
<li><code>자발적 종료</code>: 프로세스가 마지막 명령 수행 후 exit() 시스템 콜로 운영 체제에게 알린다.</li>
<li><code>비자발적 종료</code>: 부모 프로세스가 abort()를 호출하여 자식 프로세스의 수행을 강제 종료시킨다.</li>
</ul>
</li>
</ul>
<h2 id="프로세스-간의-협력"><a href="#프로세스-간의-협력" class="headerlink" title="프로세스 간의 협력"></a>프로세스 간의 협력</h2><blockquote>
<p>프로세스는 각자 자신의 독립적인 주소 공간을 가지고 수행하므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없다.</p>
</blockquote>
<p>하지만 독립적인 프로세스들이 서로 협력할 때 효율적인 경우 <code>협력 매커니즘</code>을 제공하여 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있도록 한다.</p>
<h3 id="IPC-Inter-Process-Communication"><a href="#IPC-Inter-Process-Communication" class="headerlink" title="IPC(Inter-Process Communication)"></a>IPC(Inter-Process Communication)</h3><p>대표적인 협력 매커니즘으로 하나의 컴퓨터 안에서 실행중인 서로 다른 프로세스 간에 발생하는 통신. 의사 소통 기능과 동기화가 보장되어야 한다.</p>
<ul>
<li>메시지 전달: 프로세스 간 공유 변수를 사용하지 않고, 커널을 통해 메시지를 전달하는 방법으로 통신</li>
<li>공유 메모리: 프로세스 간 공유 변수를 사용하여 주소 공간의 일부를 공유한다.</li>
</ul>
<h3 id="스레드"><a href="#스레드" class="headerlink" title="스레드"></a>스레드</h3><p>스레드는 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 <strong>동일한 프로세스를 구성하는 스레드 간에는 주소 공간을 공유하므로 협력이 가능하다.</strong></p>
<ul>
<li>program counter, register set, stack space로 구성된다.</li>
<li>스레드가 동료 스레드와 공유하는 부분(task): code section, data section, OS resource</li>
</ul>
<hr>
<p><em>References</em><br><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323" target="_blank" rel="noopener">운영체제</a><br>[운영 체제와 정보 기술의 원리] 반효경 지음</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/15/20220516_os2/" rel="prev" title="Operating Systems - 컴퓨터 시스템의 동작 원리">
      <i class="fa fa-chevron-left"></i> Operating Systems - 컴퓨터 시스템의 동작 원리
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#프로세스의-개념"><span class="nav-number">1.</span> <span class="nav-text">프로세스의 개념</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#프로세스-문맥의-분류"><span class="nav-number">1.1.</span> <span class="nav-text">프로세스 문맥의 분류</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#프로세스의-상태"><span class="nav-number">2.</span> <span class="nav-text">프로세스의 상태</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#문맥교환"><span class="nav-number">2.1.</span> <span class="nav-text">문맥교환</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#문맥-교환의-과정"><span class="nav-number">2.1.1.</span> <span class="nav-text">문맥 교환의 과정</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#프로세스-제어-블록-PCB-Process-Control-Block"><span class="nav-number">3.</span> <span class="nav-text">프로세스 제어 블록 (PCB: Process Control Block)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#프로세스를-스케줄링하기-위한-큐"><span class="nav-number">4.</span> <span class="nav-text">프로세스를 스케줄링하기 위한 큐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#스케줄러"><span class="nav-number">5.</span> <span class="nav-text">스케줄러</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#프로세스의-생성"><span class="nav-number">6.</span> <span class="nav-text">프로세스의 생성</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#프로세스의-작업-수행"><span class="nav-number">6.1.</span> <span class="nav-text">프로세스의 작업 수행</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#프로세스가-수행되는-모델"><span class="nav-number">6.2.</span> <span class="nav-text">프로세스가 수행되는 모델</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#프로세스의-생성-절차"><span class="nav-number">6.3.</span> <span class="nav-text">프로세스의 생성 절차</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#프로세스-간의-협력"><span class="nav-number">7.</span> <span class="nav-text">프로세스 간의 협력</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IPC-Inter-Process-Communication"><span class="nav-number">7.1.</span> <span class="nav-text">IPC(Inter-Process Communication)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#스레드"><span class="nav-number">7.2.</span> <span class="nav-text">스레드</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Heejin Lee</p>
  <div class="site-description" itemprop="description">Today I Learned</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heejin Lee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
