<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heejinlee07.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="아이템 19 추론 가능한 타입을 사용해 장황한 코드 방지하기타입스크립트가 결국 타입을 위한 언어이기 때문에 변수를 선언할 때마다 타입을 명시해야 한다고 생각하기 쉽다. 하지만 코드의 모든 변수에 타입을 선언하는 것은 비생산적이다. 타입스크립트는 타입 추론이 된다면 명시적 타입 구문은 필요하지 않다. let x &#x3D; 12;와 같은 구문은 x가 number로 추">
<meta property="og:type" content="article">
<meta property="og:title" content="타입스크립트 이펙티브 아이템 19 - 아이템 20">
<meta property="og:url" content="https://heejinlee07.github.io/2022/02/07/220208_tsitem19to20/index.html">
<meta property="og:site_name" content="Heejin">
<meta property="og:description" content="아이템 19 추론 가능한 타입을 사용해 장황한 코드 방지하기타입스크립트가 결국 타입을 위한 언어이기 때문에 변수를 선언할 때마다 타입을 명시해야 한다고 생각하기 쉽다. 하지만 코드의 모든 변수에 타입을 선언하는 것은 비생산적이다. 타입스크립트는 타입 추론이 된다면 명시적 타입 구문은 필요하지 않다. let x &#x3D; 12;와 같은 구문은 x가 number로 추">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-02-07T15:00:00.000Z">
<meta property="article:modified_time" content="2022-02-21T20:02:18.479Z">
<meta property="article:author" content="Heejin Lee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://heejinlee07.github.io/2022/02/07/220208_tsitem19to20/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>타입스크립트 이펙티브 아이템 19 - 아이템 20 | Heejin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heejin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Front-end Developer</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/07/220208_tsitem19to20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          타입스크립트 이펙티브 아이템 19 - 아이템 20
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-08 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-08T00:00:00+09:00">2022-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-22 05:02:18" itemprop="dateModified" datetime="2022-02-22T05:02:18+09:00">2022-02-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="아이템-19-추론-가능한-타입을-사용해-장황한-코드-방지하기"><a href="#아이템-19-추론-가능한-타입을-사용해-장황한-코드-방지하기" class="headerlink" title="아이템 19 추론 가능한 타입을 사용해 장황한 코드 방지하기"></a>아이템 19 추론 가능한 타입을 사용해 장황한 코드 방지하기</h2><p>타입스크립트가 결국 타입을 위한 언어이기 때문에 변수를 선언할 때마다 타입을 명시해야 한다고 생각하기 쉽다. <em>하지만 코드의 모든 변수에 타입을 선언하는 것은 비생산적이다.</em> 타입스크립트는 타입 추론이 된다면 명시적 타입 구문은 필요하지 않다. <code>let x = 12;</code>와 같은 구문은 x가 number로 추론되기 때문에 굳이 <code>let x: number = 12;</code>로 작성하지 않아도 되고, 객체와 배열에 대해서도 동일하다. 아래 예시에서 1️⃣은 2️⃣로 작성해도 동일하다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="keyword">const</span> person: &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  born: &#123;</span><br><span class="line">    where: <span class="built_in">string</span>;</span><br><span class="line">    when: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  died: &#123;</span><br><span class="line">    where: <span class="built_in">string</span>;</span><br><span class="line">    when: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  name: <span class="string">'Sojourner Truth'</span>,</span><br><span class="line">  born: &#123;</span><br><span class="line">    where: <span class="string">'Swartekill, NY'</span>,</span><br><span class="line">    when: <span class="string">'c.1797'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  died: &#123;</span><br><span class="line">    where: <span class="string">'Battle Creek, MI'</span>,</span><br><span class="line">    when: <span class="string">'Nov. 26, 1883'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sojourner Truth'</span>,</span><br><span class="line">  born: &#123;</span><br><span class="line">    where: <span class="string">'Swartekill, NY'</span>,</span><br><span class="line">    when: <span class="string">'c.1797'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  died: &#123;</span><br><span class="line">    where: <span class="string">'Battle Creek, MI'</span>,</span><br><span class="line">    when: <span class="string">'Nov. 26, 1883'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>때로는 추론이 더 정확할 때가 있는데, 아래의 경우 명시적으로 string이라고 타입을 준 것 보다 추론된 ‘y’가 사실은 더 정확하다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axis1: <span class="built_in">string</span> = <span class="string">'x'</span>; <span class="comment">// Type is string</span></span><br><span class="line"><span class="keyword">const</span> axis2 = <span class="string">'y'</span>; <span class="comment">// Type is "y"</span></span><br></pre></td></tr></table></figure>
<p>아래 예시에서 Product의 id를 number라고 작성했다가 나중에 문자도 있을 수 있다는 것을 알게되어 string으로 작성했다고 가정해보자. 이 경우 선언된 타입과 함수 내의 타입이 일치하지 않아서 오류를 발생시킨다. 만약 여기서 명시적 타입 구문이 없었다면 문제없이 타입 체커를 통과했을 것이다. 그래서 이런 경우에는 비구조 할당문으로 구현하는 것이 더 나은 선택이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Product &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProduct</span>(<span class="params">product: Product</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id: <span class="built_in">number</span> = product.id;</span><br><span class="line">  <span class="comment">// ~~ Type 'string' is not assignable to type 'number'</span></span><br><span class="line">  <span class="keyword">const</span> name: <span class="built_in">string</span> = product.name;</span><br><span class="line">  <span class="keyword">const</span> price: <span class="built_in">number</span> = product.price;</span><br><span class="line">  <span class="built_in">console</span>.log(id, name, price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//비구조 할당 - 여기에 추가로 명시적 타입 구문을 넣는 것은 불필요하다.</span></span><br><span class="line"><span class="keyword">interface</span> Product &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProduct</span>(<span class="params">product: Product</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; id, name, price &#125; = product;</span><br><span class="line">  <span class="built_in">console</span>.log(id, name, price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>그러나 정보가 부족해서 타입스크립트가 스스로 판단하기 어려운 경우에는 명시적 타입 구문이 필요하다.</strong> 위 예제에서 logProduct 함수에서 매개밴수의 타입을 Product로 명시한 경우가 그 예이다. 이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역변수에는 타입 구문을 넣지 않는 것이다. 단, 기본값이 있는 경우에는 타입 구문을 생략하기도 한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseNumber</span>(<span class="params">str: <span class="built_in">string</span>, base = 10</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>타입이 추론될 수 있음에도 타입을 명시하고 싶은 경우가 있다. 객체 리터럴의 정의과 함수의 반환 타입을 명시할 때이다.</p>
<h3 id="객체-리터럴의-정의"><a href="#객체-리터럴의-정의" class="headerlink" title="객체 리터럴의 정의"></a>객체 리터럴의 정의</h3><p>객체 리터럴에서 타입을 명시하면 잉여 속성 체크가 동작해서 실제로 실수가 방생한 부분에 정확하게 오류를 표시해 줄 수 있다. 아래 예시에서 타입 구문을 제거하면 잉여 속성 체크가 동작하지 않아서 실제 오류가 발생한 id쪽이 아니라 객체가 사용되는 곳에서 오류가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Product &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProduct</span>(<span class="params">product: Product</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id: <span class="built_in">number</span> = product.id;</span><br><span class="line">  <span class="comment">// ~~ Type 'string' is not assignable to type 'number'</span></span><br><span class="line">  <span class="keyword">const</span> name: <span class="built_in">string</span> = product.name;</span><br><span class="line">  <span class="keyword">const</span> price: <span class="built_in">number</span> = product.price;</span><br><span class="line">  <span class="built_in">console</span>.log(id, name, price);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> furby: Product = &#123;</span><br><span class="line">  name: <span class="string">'Furby'</span>,</span><br><span class="line">  id: <span class="number">630509430963</span>,</span><br><span class="line">  <span class="comment">// ~~ Type 'number' is not assignable to type 'string'</span></span><br><span class="line">  price: <span class="number">35</span>,</span><br><span class="line">&#125;;</span><br><span class="line">logProduct(furby);</span><br></pre></td></tr></table></figure>
<h3 id="함수의-반환"><a href="#함수의-반환" class="headerlink" title="함수의 반환"></a>함수의 반환</h3><p>타입 추론이 가능한 경우에도 구현상의 오류가 함수를 호출한 곳까지 영향을 미치지 않도록 하기 위함이다. 반환 타입을 명시하면 구현상의 오류가 사용자 코드의 오류로 표시되지 않고, 오류의 위치를 제대로 표시해준다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache: &#123; [ticker: <span class="built_in">string</span>]: <span class="built_in">number</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQuote</span>(<span class="params">ticker: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//getQuote가 반환하는 것은 Promise.resolve(cache[ticker])이어야 한다.</span></span><br><span class="line">  <span class="comment">//따라서 여기에서 아래와 같은 오류가 발생해야 한다.</span></span><br><span class="line">  <span class="comment">//~~~~~~~~~~~~~ Type 'number' is not assignable to 'Promise&lt;number&gt;'</span></span><br><span class="line">  <span class="comment">//하지만 실제 오류는 가장 아래 getQuote를 호출한 코드에서 발생한다.</span></span><br><span class="line">  <span class="keyword">if</span> (ticker <span class="keyword">in</span> cache) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[ticker];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">`https://quotes.example.com/?q=<span class="subst">$&#123;ticker&#125;</span>`</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function">(<span class="params">quote</span>) =&gt;</span> &#123;</span><br><span class="line">      cache[ticker] = quote;</span><br><span class="line">      <span class="keyword">return</span> quote;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">considerBuying</span>(<span class="params">x: <span class="built_in">any</span></span>) </span>&#123;&#125;</span><br><span class="line">getQuote(<span class="string">'MSFT'</span>).then(considerBuying);</span><br><span class="line"><span class="comment">// ~~~~ Property 'then' does not exist on type</span></span><br><span class="line"><span class="comment">//        'number | Promise&lt;any&gt;'</span></span><br><span class="line"><span class="comment">//      Property 'then' does not exist on type 'number'</span></span><br></pre></td></tr></table></figure>
<p>그 외에도 반환타입을 명시하는 것은 아래 두 가지 장점이 있다.</p>
<ul>
<li><code>함수를 더욱 명확하게 알기 쉽다.</code> 반환 타입을 명시하려면 입력, 출력 타입에 대해 알아야 하고 미리 명시해야만 하기 때문에 타입을 미리 작성하여 구현이 맞추어 주먹구구식으로 타입이 작성되는 것이 아닌 테스트 주도 개발처럼 작성할 수 있게 된다.</li>
<li><code>명명된 타입을 사용할 수 있다.</code> 반환 타입을 명시하면 더욱 직관적인 표현이 되고, 반환 값을 별도의 타입으로 정의하면 타입에 대한 주석을 작설항 수 있어 함수에 대해 더 자세히 설명하게 된다.</li>
</ul>
<hr>
<h2 id="아이템-20-다른-타입에는-다른-변수-사용하기"><a href="#아이템-20-다른-타입에는-다른-변수-사용하기" class="headerlink" title="아이템 20 다른 타입에는 다른 변수 사용하기"></a>아이템 20 다른 타입에는 다른 변수 사용하기</h2><p>자바스크립트에서는 한 변수를 다른 목적을 가지는 다른 타입으로 재사용해도 되는데, 타입스크립트에서는 이렇게 사용하면 두 가지 오류가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//자바스크립트</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="string">'12-34-56'</span>;</span><br><span class="line">fetchProduct(id); <span class="comment">//string으로 사용</span></span><br><span class="line"></span><br><span class="line">id = <span class="number">123456</span>;</span><br><span class="line">fetchProductBySerialNumber(id); <span class="comment">//number로 사용</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//타입스크립트</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProduct</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProductBySerialNumber</span>(<span class="params">id: <span class="built_in">number</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> id = <span class="string">'12-34-56'</span>;</span><br><span class="line">fetchProduct(id);</span><br><span class="line"></span><br><span class="line">id = <span class="number">123456</span>;</span><br><span class="line"><span class="comment">// ~~ '123456' is not assignable to type 'string'.</span></span><br><span class="line">fetchProductBySerialNumber(id);</span><br><span class="line"><span class="comment">// ~~ Argument of type 'string' is not assignable to</span></span><br><span class="line"><span class="comment">//    parameter of type 'number'</span></span><br></pre></td></tr></table></figure>
<p>여기서 중요한 점은 <strong>변수의 값은 바뀔 수 있지만 타입은 바뀌지 않는다.</strong>는 점이다. 범위를 좁히는 방법으로 타입을 바꿀 수는 있지만 그것은 새로운 변수값을 포함하도록 확장하는 것이 아니라 타입을 더 작게 제한하는 것이다.</p>
<h3 id="유니온-타입을-이용한-타입의-확장"><a href="#유니온-타입을-이용한-타입의-확장" class="headerlink" title="유니온 타입을 이용한 타입의 확장"></a>유니온 타입을 이용한 타입의 확장</h3><p>id가 string, number를 모두 포함할 수 있도록 타입을 확장하는 유니온을 통해 아래와 같이 작성하면 에러는 해결된다. 하지만 이렇게 작성하면 매번 id값이 string인지 number인지 확인해야 하기 때문에 이런 경우에는 별도의 변수로 작성하는 것이 낫다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProduct</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProductBySerialNumber</span>(<span class="params">id: <span class="built_in">number</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> id: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">'12-34-56'</span>;</span><br><span class="line">fetchProduct(id);</span><br><span class="line"></span><br><span class="line">id = <span class="number">123456</span>; <span class="comment">// OK</span></span><br><span class="line">fetchProductBySerialNumber(id); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//유니온 타입 대신 별도의 변수로 작성</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProduct</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProductBySerialNumber</span>(<span class="params">id: <span class="built_in">number</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> id = <span class="string">'12-34-56'</span>;</span><br><span class="line">fetchProduct(id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serial = <span class="number">123456</span>; <span class="comment">// OK</span></span><br><span class="line">fetchProductBySerialNumber(serial); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>무엇보다 변수를 재사용하는 방식은 타입 체커는 물론 사람에게도 혼란을 주기 때문에 지양해야 한다. 타입이 다른 경우 별도의 변수를 사용하는 것이 바람직한 이유는 다음과 같다.</p>
<ul>
<li>서로 관련이 없는 두 개의 값을 분리한다.</li>
<li>변수명을 더 구체적으로 지을 수 있다.</li>
<li>타입 추론을 향상시키며, 타입 구문이 불필요해진다.</li>
<li>타입이 간결해진다.</li>
<li>let 대신 const로 변수를 선언하게 된다. 이렇게 하면 코드가 간결하고, 타입 체커의 타입 추론이 용이하다.</li>
</ul>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/06/220207_userAgent/" rel="prev" title="사용자 에이전트 (User Agent)">
      <i class="fa fa-chevron-left"></i> 사용자 에이전트 (User Agent)
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/09/220210_item21to27/" rel="next" title="타입스크립트 이펙티브 아이템 21 - 아이템 27">
      타입스크립트 이펙티브 아이템 21 - 아이템 27 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#아이템-19-추론-가능한-타입을-사용해-장황한-코드-방지하기"><span class="nav-number">1.</span> <span class="nav-text">아이템 19 추론 가능한 타입을 사용해 장황한 코드 방지하기</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#객체-리터럴의-정의"><span class="nav-number">1.1.</span> <span class="nav-text">객체 리터럴의 정의</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#함수의-반환"><span class="nav-number">1.2.</span> <span class="nav-text">함수의 반환</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#아이템-20-다른-타입에는-다른-변수-사용하기"><span class="nav-number">2.</span> <span class="nav-text">아이템 20 다른 타입에는 다른 변수 사용하기</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#유니온-타입을-이용한-타입의-확장"><span class="nav-number">2.1.</span> <span class="nav-text">유니온 타입을 이용한 타입의 확장</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Heejin Lee</p>
  <div class="site-description" itemprop="description">Today I Learned</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heejin Lee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
