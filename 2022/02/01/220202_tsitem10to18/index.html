<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heejinlee07.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="아이템 10 객체 래퍼 타입 피하기자바스크립트의 타입 기본형 값들에 대한 일곱가지 타입 (string, number, boolean, null, undefined, symbol(ES2015에서 추가), bigint(최종 확정 단계))객체  기본형은 불변이며, 메서드를 가지지 않는다. 그런데 기본형인 string이 메서드를 가진 것처럼 보이는 이유는 자바스크">
<meta property="og:type" content="article">
<meta property="og:title" content="타입스크립트 이펙티브 아이템 10 - 아이템 18">
<meta property="og:url" content="https://heejinlee07.github.io/2022/02/01/220202_tsitem10to18/index.html">
<meta property="og:site_name" content="Heejin">
<meta property="og:description" content="아이템 10 객체 래퍼 타입 피하기자바스크립트의 타입 기본형 값들에 대한 일곱가지 타입 (string, number, boolean, null, undefined, symbol(ES2015에서 추가), bigint(최종 확정 단계))객체  기본형은 불변이며, 메서드를 가지지 않는다. 그런데 기본형인 string이 메서드를 가진 것처럼 보이는 이유는 자바스크">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-02-01T15:00:00.000Z">
<meta property="article:modified_time" content="2022-02-07T08:16:28.708Z">
<meta property="article:author" content="Heejin Lee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://heejinlee07.github.io/2022/02/01/220202_tsitem10to18/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>타입스크립트 이펙티브 아이템 10 - 아이템 18 | Heejin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heejin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Front-end Developer</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/01/220202_tsitem10to18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          타입스크립트 이펙티브 아이템 10 - 아이템 18
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-02T00:00:00+09:00">2022-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-07 17:16:28" itemprop="dateModified" datetime="2022-02-07T17:16:28+09:00">2022-02-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="아이템-10-객체-래퍼-타입-피하기"><a href="#아이템-10-객체-래퍼-타입-피하기" class="headerlink" title="아이템 10 객체 래퍼 타입 피하기"></a>아이템 10 객체 래퍼 타입 피하기</h2><h3 id="자바스크립트의-타입"><a href="#자바스크립트의-타입" class="headerlink" title="자바스크립트의 타입"></a>자바스크립트의 타입</h3><blockquote>
<p>기본형 값들에 대한 일곱가지 타입 (string, number, boolean, null, undefined, symbol(ES2015에서 추가), bigint(최종 확정 단계))<br>객체</p>
</blockquote>
<p><strong>기본형은 불변이며, 메서드를 가지지 않는다.</strong> 그런데 기본형인 string이 메서드를 가진 것처럼 보이는 이유는 자바스크립트에 메서드를 가지는 <code>String 객체 타입</code>이 정의되어 있기 때문이다. 만약 charAt과 같은 메서드를 기본형에 사용한다면 기본형을 String 객체로 래핑하여 메서드를 호출한 후 마지막에 래핑한 객체를 버리는 방식으로 작동된다. null과 undefined를 제외한 모든 기본형에 이와 같은 객체 래퍼 타입이 존재한다. 이러한 래퍼 객체는 직접 생성할 필요가 없고, 기본형을 사용해야하는데 래퍼 객체를 사용하지 않도록 주의하여야 한다. <strong>타입스크립트가 제공하는 타입 선언은 전부 기본형 타입이다.</strong></p>
<hr>
<h2 id="아이템-11-잉여-속성-체크의-한계-인지하기"><a href="#아이템-11-잉여-속성-체크의-한계-인지하기" class="headerlink" title="아이템 11 잉여 속성 체크의 한계 인지하기"></a>아이템 11 잉여 속성 체크의 한계 인지하기</h2><p>타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지, <strong>그 외의 속성은 없는지</strong> 확인한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ 잉여 속성 체크</span></span><br><span class="line"><span class="keyword">interface</span> Room &#123;</span><br><span class="line">  numDoors: <span class="built_in">number</span>;</span><br><span class="line">  ceilingHeightFt: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> r: Room = &#123;</span><br><span class="line">  numDoors: <span class="number">1</span>,</span><br><span class="line">  ceilingHeightFt: <span class="number">10</span>,</span><br><span class="line">  elephant: <span class="string">'present'</span>,</span><br><span class="line">  <span class="comment">// ~~~~~~~~~~~~~~~~~~ Object literal may only specify known properties,</span></span><br><span class="line">  <span class="comment">//                    and 'elephant' does not exist in type 'Room'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">interface</span> Room &#123;</span><br><span class="line">  numDoors: <span class="built_in">number</span>;</span><br><span class="line">  ceilingHeightFt: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  numDoors: <span class="number">1</span>,</span><br><span class="line">  ceilingHeightFt: <span class="number">10</span>,</span><br><span class="line">  elephant: <span class="string">'present'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> r: Room = obj; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>1️⃣ 의 샘플코드는 <code>잉여 속성 체크</code>가 수행되었다. 구조적 타입 시스템에서 발생할 수 있는 중요한 오류를 잡을 수 있도록 한다. 1️⃣ 의 샘플코드는 <em>구조적 타입</em>의 관점에서 생각해보면 elephant 속성이 있어도 오류가 발생하지 않아야 하지만, 오류가 발생했다. 이처럼 잉여 속성 체크를 사용하면 타입 시스템의 구조적 본질을 해치치 않으면서도 객체 리터럴에 알 수 없는 속성을 허용하지 않음으로써 문제의 발생을 방지 할 수 있다. 단, 조건에 따라 동작하지 않을 수 있고, 통상적인 할당 가능 검사와 함께 쓰이면 구조적 타이핑이 무엇인지 혼란스러워 진다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Room &#123;</span><br><span class="line">  numDoors: <span class="built_in">number</span>;</span><br><span class="line">  ceilingHeightFt: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDarkMode</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  darkMode?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> intermediate = &#123; darkmode: <span class="literal">true</span>, title: <span class="string">'Ski Free'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> o: Options = intermediate; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o2 = &#123; darkmode: <span class="literal">true</span>, title: <span class="string">'Ski Free'</span> &#125; <span class="keyword">as</span> Options; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>위 예시에서 intermediate 변수의 오른쪽은 객체 리터럴이지만 o변수의 intermediate는 객체 리터럴이 아니다. 타입 구문이 없는 임시 변수이다. 이 경우 잉여 속성 체크가 적용되지 않아서 오류가 사라진다. 위의 예시에서 o2와 같이 타입 단언을 사용해도 잉여 속성 체크는 적용되지 않는다. 아래 예시처럼 선택적 속성만 가지는 약한 타입에도 비슷한 체크가 동작한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> LineChartOptions &#123;</span><br><span class="line">  logscale?: <span class="built_in">boolean</span>;</span><br><span class="line">  invertedYAxis?: <span class="built_in">boolean</span>;</span><br><span class="line">  areaChart?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; logScale: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> o: LineChartOptions = opts;</span><br><span class="line"><span class="comment">// ~ Type '&#123; logScale: boolean; &#125;' has no properties in common</span></span><br><span class="line"><span class="comment">//   with type 'LineChartOptions'</span></span><br></pre></td></tr></table></figure>
<p>위 예시에서 LineChartOptions 타입은 모든 속성이 선택적이므로 모든 객체를 포함할 수 있는 약한 타입이다. 이 경우 타입스크립트가 값 타입과 선언 타입에 공통된 속성이 있는지 확인하는 별도의 체크를 수행한다. 오타를 잡는데 효과적이며 구조적으로 엄격하지 않지만 잉여 속성 체크와 다른 점은 약한 타입과 관련된 할당문마다 수행된다는 점이다. 따라서 임시 변수를 제거하더라고 공통 속성 체크는 여전히 동작한다.</p>
<hr>
<p>TL;DR</p>
<ul>
<li>객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 체크 속성이 수행된다.</li>
<li>잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이 다르다. 할당의 개념을 정확히 알아야 잉여 속성 체크와 일반적인 구조적 할당 가능성 체크를 구분할 수 있다.</li>
<li>잉여 속성 체크에는 한계가 있다. 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다.</li>
</ul>
<h2 id="아이템-12-함수-표현식에-타입-적용하기"><a href="#아이템-12-함수-표현식에-타입-적용하기" class="headerlink" title="아이템 12 함수 표현식에 타입 적용하기"></a>아이템 12 함수 표현식에 타입 적용하기</h2><p>자바스크립트에서는 함수 문장(statement)와 함수 표현식(expression)을 다르게 인식한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rollDice1</span>(<span class="params">sides: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* COMPRESS */</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* END */</span></span><br><span class="line">&#125; <span class="comment">// Statement</span></span><br><span class="line"><span class="keyword">const</span> rollDice2 = <span class="function"><span class="keyword">function</span> (<span class="params">sides: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* COMPRESS */</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* END */</span></span><br><span class="line">&#125;; <span class="comment">// Expression</span></span><br><span class="line"><span class="keyword">const</span> rollDice3 = (sides: number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* COMPRESS */</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* END */</span></span><br><span class="line">&#125;; <span class="comment">// Also expression</span></span><br></pre></td></tr></table></figure>
<p>타입스크립트에서는 <code>함수 표현식</code>을 사용하는 것이 좋다. 그 이유는 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있기 때문이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ 사칙연산을 하는 함수 - 함수의 매개변수에 타입 선언</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ 함수 시그니처를 하나의 함수 타입으로 통합 - 함수 표현식 전체 타입을 정의</span></span><br><span class="line"><span class="keyword">type</span> BinaryFn = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">const</span> add: BinaryFn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">const</span> sub: BinaryFn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b;</span><br><span class="line"><span class="keyword">const</span> mul: BinaryFn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * b;</span><br><span class="line"><span class="keyword">const</span> div: BinaryFn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a / b;</span><br></pre></td></tr></table></figure>
<p>1️⃣ 에 비해 2️⃣ 가 코드가 간결하고 안전하다.</p>
<hr>
<h2 id="아이템-13-타입과-인터페이스-차이점-알기"><a href="#아이템-13-타입과-인터페이스-차이점-알기" class="headerlink" title="아이템 13 타입과 인터페이스 차이점 알기"></a>아이템 13 타입과 인터페이스 차이점 알기</h2><p>타입스크립트에서 명명된 타입을 정의하는 방법은 아래와 같이 <code>type</code>, <code>interface</code>의 두 가지 방법이 있다. 대부분의 경우 둘 중 어떤 것을 사용해도 상관없지만 <strong>두 가지 타입이 가지는 차이점을 명확히 알고 사용해야 한다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TState = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type-interface의-비슷한-점"><a href="#type-interface의-비슷한-점" class="headerlink" title="type, interface의 비슷한 점"></a><code>type</code>, <code>interface</code>의 비슷한 점</h3><ul>
<li>명명된 타입은 <code>type</code>, <code>interface</code> 둘 중 어떤 것으로 정의하든 상태에 차이가 없지만, <strong>추가 속성과 함께 할당하려고 하면 오류가 발생한다.</strong></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//예제코드에서 type은 T, interface는 I를 접두사로 사용했는데,</span></span><br><span class="line"><span class="comment">//이해를 돕기 위함이며, 실제코드에서는 이렇게 사용하지 않도록 한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TState = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wyoming: TState = &#123;</span><br><span class="line">  name: <span class="string">'Wyoming'</span>,</span><br><span class="line">  capital: <span class="string">'Cheyenne'</span>,</span><br><span class="line">  population: <span class="number">500</span>_000,</span><br><span class="line">  <span class="comment">// ~~~~~~~~~~~~~~~~~~ Type ... is not assignable to type 'TState'</span></span><br><span class="line">  <span class="comment">//                    Object literal may only specify known properties, and</span></span><br><span class="line">  <span class="comment">//                    'population' does not exist in type 'TState'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>인덱스 시그니처의 사용이 가능하다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TDict = &#123; [key: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">interface</span> IDict &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>함수 타입도 정의할 수 있고, 제너릭이 가능하다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TFn = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">interface</span> IFn &#123;</span><br><span class="line">  (x: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//단순한 함수 타입에서는 타입 별칭이 더 나은 선택일 수 있다.</span></span><br><span class="line"><span class="keyword">const</span> toStrT: TFn = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="string">''</span> + x; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> toStrI: IFn = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="string">''</span> + x; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<ul>
<li>타입을 확장할 수 있다. 단 interface는 주의사항이 몇 가지 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TState = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IStateWithPop <span class="keyword">extends</span> TState &#123;</span><br><span class="line">  population: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface는 유니온 타입과 같은 복잡한 타입을 확장하지 못한다.</span></span><br><span class="line"><span class="comment">// 확장하려면 아래와 같이 타입과 &amp;을 사용해야 한다.</span></span><br><span class="line"><span class="keyword">type</span> TStateWithPop = IState &amp; &#123; population: <span class="built_in">number</span> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="type-interface의-다른-점"><a href="#type-interface의-다른-점" class="headerlink" title="type, interface의 다른 점"></a><code>type</code>, <code>interface</code>의 다른 점</h3><ul>
<li>interface는 타입을 확장할 수 있고, 유니온은 할 수 없다. 유니온 타입은 있지만 유니온 인터페이스라는 개념은 없다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Input = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> Output = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input 타입과 Output 타입은 별도의 타입인데, VariableMap interface를 만들 수 있다.</span></span><br><span class="line"><span class="keyword">interface</span> VariableMap &#123;</span><br><span class="line">  [name: <span class="built_in">string</span>]: Input | Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//아래와 같이 유니온 타입에 name 속성을 붙인 타입을 만들 수도 있다.</span></span><br><span class="line"><span class="comment">//이 타입은 interface로 표현할 수 없다.</span></span><br><span class="line"><span class="keyword">type</span> NamedVariable = (Input | Output) &amp; &#123; name: <span class="built_in">string</span> &#125;;</span><br></pre></td></tr></table></figure>
<p><code>type</code> 키워드는 interface보다 쓰임새가 많은데, 유니온이 될 수도 있고, 매핑된 타입 또는 조건부 타입 같은 고급 기능에도 활용된다. 튜플과 배열 타입을 표현하는 것도 용이하다. interface로 튜플과 비슷하게 구현할 수 있지만 concat과 같은 메서드를 사용할 수 없다.</p>
<ul>
<li>interface는 보강이 가능하고, type은 그렇지 않다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  population: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wyoming: IState = &#123;</span><br><span class="line">  name: <span class="string">'Wyoming'</span>,</span><br><span class="line">  capital: <span class="string">'Cheyenne'</span>,</span><br><span class="line">  population: <span class="number">500</span>_000,</span><br><span class="line">&#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>위 예제에서 속싱이 확장되었는데 이를 <code>선언 병합(declaration merging)</code>라고 한다. 선언 병합은 주로 타입 선언 파일에 사용횐다. <em>즉 타입 선언 파일을 작성할 때는 선언 병합을 지원하기 위해 반드시 interface를 사용해야 한다.</em></p>
<h3 id="type-interface를-언제-써야하는가"><a href="#type-interface를-언제-써야하는가" class="headerlink" title="type, interface를 언제 써야하는가?"></a><code>type</code>, <code>interface</code>를 언제 써야하는가?</h3><ul>
<li>타입 선언 파일 뿐 아니라 일반적인 코드에서도 병합이 지원된다. 따라서 보강이 있는 경우는 interface, 기존 타입에 추가 보강이 없는 경우는 type을 쓴다.</li>
<li>복잡한 타입은 타입 별칭을 사용한다.</li>
<li>type, interface 두 가지 모두로 표현할 수 있는 간단한 객체 타입이라면?<ul>
<li>일관성과 보강의 관점을 고려해 본다.</li>
<li>코드베이스에서 일관되게 type을 쓰고 있다면 type을, interface를 쓰고 있다면 interface를 쓴다.</li>
<li>API에 대한 타입 선언은 API가 변경될 때 사용자가 interface를 통해 새로운 필드를 병합할 수 있으니 interface를 쓴다. 단, 프로젝트 내부적으로 사용되는 타입에 선언 병합이 발생하는 것은 잘못된 설께이며, 이럴 때는 type을 쓴다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="아이템-14-타입-연산과-제너릭-사용으로-반복-줄이기"><a href="#아이템-14-타입-연산과-제너릭-사용으로-반복-줄이기" class="headerlink" title="아이템 14 타입 연산과 제너릭 사용으로 반복 줄이기"></a>아이템 14 타입 연산과 제너릭 사용으로 반복 줄이기</h2><p>코드를 작성할 때 코드를 반복하지 말라는 DRY(don’t repeat yourself)원칙에 따라 코드 중복을 제거하려고 노력하는 사람도 타입에 대해 간과하기 쉽다. 그 이유는 중복을 제거하는 매커니즘이 기존 코드에 대해 행하던 것에 비해 익숙치 않기 때문이다. 그러나 타입의 중복도 많은 문제를 일으키기 때문에 중복을 최소화해야 한다.</p>
<h3 id="반복을-줄이는-방법"><a href="#반복을-줄이는-방법" class="headerlink" title="반복을 줄이는 방법"></a>반복을 줄이는 방법</h3><ul>
<li><code>타입에 이름을 붙인다.</code> 아래 예시에서 파라미터 a, b에 반복되는 타입인 <code>{ x: number; y: number }</code>은 Point2D interface로 이름을 붙여서 중복을 제거하였다. 몇몇 함수가 같은 타입 시그니처를 공유한다고 할 때도 해당 시그니처를 명명된 타입으로 본리할 수 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">a: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;, b: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(a.x - b.x, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">a: Point2D, b: Point2D</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>interface를 사용할 경우, 한 interface가 다른 interface를 확장하게 해서 반복을 제거한다.</code></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  lastName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PersonWithBirthDate <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  birth: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>이미 존재하는 타입을 확장한다면 intersection 연산자(&amp;)을 쓴다.</code> 단, 일반적이지는 않다. 주로 확장할 수 없는 유니온 타입에 속성을 추가하려고 할 때 유용한 방법이다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  lastName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PersonWithBirthDate = Person &amp; &#123; birth: <span class="built_in">Date</span> &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>매핑된 타입</code>을 사용한다.<br>아래 예시에서 State는 전체 어플리케이션의 상태, TopNavState는 부분만 표현하는 상태라고 하고, 어떻게 매핑된 타입을 사용하는지 살펴보자. TopNavState를 확장해서 State를 구성할 수도 있지만, 의미상 State의 TopNavState를 정의하는 것이 바람직 할 것이다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">  userId: <span class="built_in">string</span>;</span><br><span class="line">  pageTitle: <span class="built_in">string</span>;</span><br><span class="line">  recentFiles: <span class="built_in">string</span>[];</span><br><span class="line">  pageContents: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> TopNavState &#123;</span><br><span class="line">  userId: <span class="built_in">string</span>;</span><br><span class="line">  pageTitle: <span class="built_in">string</span>;</span><br><span class="line">  recentFiles: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>아래 예시에서 1️⃣은 의미상 TopNavState를 State의 부분 집합이 되도록 작성하기 위해 State를 인덱싱해서 속성의 타입에 중복을 제거하였다. 이렇게 하면 State에 있는 속성의 타입이 바뀌더라도 잘 반영된다. 하지만 여전히 반복되는 코드가 있기 때문에 <strong>2️⃣와 같이 매핑된 타입을 사용한다.</strong> 매핑된 타입은 배열의 필드를 루프 도는 것과 같은 방식이다. 표준 라이브러리에서는 <code>Pick</code>이라 한다. Pick은 제너릭 타입이며, 3️⃣과 같이 사용한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ - 인덱싱하여 중복제거</span></span><br><span class="line"><span class="keyword">type</span> TopNavState = &#123;</span><br><span class="line">  userId: State[<span class="string">'userId'</span>];</span><br><span class="line">  pageTitle: State[<span class="string">'pageTitle'</span>];</span><br><span class="line">  recentFiles: State[<span class="string">'recentFiles'</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ - 매핑된 타입 사용</span></span><br><span class="line"><span class="keyword">type</span> TopNavState = &#123;</span><br><span class="line">  [k <span class="keyword">in</span> <span class="string">'userId'</span> | <span class="string">'pageTitle'</span> | <span class="string">'recentFiles'</span>]: State[k];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3️⃣ - Pick 사용</span></span><br><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123; [k <span class="keyword">in</span> K]: T[k] &#125;; <span class="comment">// Pick의 정의</span></span><br><span class="line"><span class="comment">//만약 Pick에 잘못된 키를 넣으면 오류가 발생한다.</span></span><br><span class="line"><span class="keyword">type</span> TopNavState = Pick&lt;State, <span class="string">'userId'</span> | <span class="string">'pageTitle'</span> | <span class="string">'recentFiles'</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>태그된 유니온에서 중복이 발생하면 어떻게 할 수 있을까? 아래 예시에서 ‘save’,’load’가 중복된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SaveAction &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'save'</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> LoadAction &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'load'</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Action = SaveAction | LoadAction;</span><br></pre></td></tr></table></figure>
<p>위와 같이 중복이 발생할 때는 Action 유니온을 인덱싱하여 ActionType을 정의한다. 이제 Action에 타입이 더 추가되더라도 ActionType은 자동으로 그 타입을 포함하게 된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ActionType = Action[<span class="string">'type'</span>]; <span class="comment">// Type is "save" | "load"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Pick을 사용하여 type 속성을 가지는 interface와 인덱싱을 사용하는 방법은 다르다.</span></span><br><span class="line"><span class="keyword">type</span> ActionRec = Pick&lt;Action, <span class="string">'type'</span>&gt;; <span class="comment">// &#123;type: "save" | "load"&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>매핑된 타입과 keyof를 사용한다.</code> 아래와 같이 생성한 후 업데이트가 되는 클래스를 정의할 때를 가정해본다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">  width: <span class="built_in">number</span>;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> OptionsUpdate &#123;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">  height?: <span class="built_in">number</span>;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  label?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> UIWidget &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">init: Options</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  update(options: OptionsUpdate) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이때 매핑된 타입과 keyof를 사용하여 OptionsUpdate를 만든다.</p>
<ul>
<li>keyof는 타입을 받아서 속성 타입의 유니온을 반환한다.</li>
<li>매핑된 타입[k in keyof Options]은 순회하며 Options 내 k 값에 해당하는 속성이 있는지 찾는다.</li>
<li><code>?</code>는 속성을 선택적으로 만드는데 표준 라이브러리에는 <code>Partial</code>이라는 이름으로 포함되어 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OptionsUpdate = &#123; [k <span class="keyword">in</span> keyof Options]?: Options[k] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OptionsKeys = keyof Options;</span><br><span class="line"><span class="comment">// Type is "width" | "height" | "color" | "label"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>typeof</code>를 사용한다. 값의 형태에 해당하는 타입을 정의하고 싶을 때 사용하는 방법이다. 자바스트립트의 typeof처럼 보이지만 실제로는 타입스크립트 단계에서 연산된다. 단, 값으로부터 타입을 만들어 낼 때 <em>선언의 순서에 주의한다.</em> 타입 정의 후 값이 그 타입에 할당 가능하다고 선언하는 것이 명확하고, 예상하기 어려운 타입 변동을 방지할 수 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> INIT_OPTIONS = &#123;</span><br><span class="line">  width: <span class="number">640</span>,</span><br><span class="line">  height: <span class="number">480</span>,</span><br><span class="line">  color: <span class="string">'#00FF00'</span>,</span><br><span class="line">  label: <span class="string">'VGA'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">  width: <span class="built_in">number</span>;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Options = <span class="keyword">typeof</span> INIT_OPTIONS;</span><br></pre></td></tr></table></figure>
<ul>
<li>함수나 메서드의 반환 값에 명명된 타입을 만들고 싶다면 <code>ReturnType</code>을 사용한다. <em>아래 예시에서 <code>ReturnType</code>은 함수의 <code>값</code>인 getUserInfo가 아닌 typeof getUserInfo에 적용되었다.</em></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> INIT_OPTIONS = &#123;</span><br><span class="line">  width: <span class="number">640</span>,</span><br><span class="line">  height: <span class="number">480</span>,</span><br><span class="line">  color: <span class="string">'#00FF00'</span>,</span><br><span class="line">  label: <span class="string">'VGA'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">userId: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// COMPRESS</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">'Bob'</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">const</span> height = <span class="number">48</span>;</span><br><span class="line">  <span class="keyword">const</span> weight = <span class="number">70</span>;</span><br><span class="line">  <span class="keyword">const</span> favoriteColor = <span class="string">'blue'</span>;</span><br><span class="line">  <span class="comment">// END</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    userId,</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    height,</span><br><span class="line">    weight,</span><br><span class="line">    favoriteColor,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Return type inferred as &#123; userId: string; name: string; age: number, ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo = ReturnType&lt;<span class="keyword">typeof</span> getUserInfo&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>제너릭 타입을 사용한다.</code> 제너릭 타입은 타입을 위한 함수와 같다. 다만 함수에서 매개변수로 매핑할 수 있는 값을 제한하기 위해 타입 시스템을 사용하는 것처럼 매개변수를 제한할 수 있는 방법이 필요하다. 제너릭 타입에서 그 방법은 <code>extends</code>를 사용하는 것이다. 이는 제너릭 매개변수가 특정 타입을 확장한다고 선언할 수 있게 한다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Name &#123;</span><br><span class="line">  first: <span class="built_in">string</span>;</span><br><span class="line">  last: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> DancingDuo&lt;T <span class="keyword">extends</span> Name&gt; = [T, T];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> couple1: DancingDuo&lt;Name&gt; = [</span><br><span class="line">  &#123; first: <span class="string">'Fred'</span>, last: <span class="string">'Astaire'</span> &#125;,</span><br><span class="line">  &#123; first: <span class="string">'Ginger'</span>, last: <span class="string">'Rogers'</span> &#125;,</span><br><span class="line">]; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;first:string&#125;은 Name을 확장하지 않기 때문에 오류 발생</span></span><br><span class="line"><span class="keyword">const</span> couple2: DancingDuo&lt;&#123; first: <span class="built_in">string</span> &#125;&gt; = [</span><br><span class="line">  <span class="comment">// ~~~~~~~~~~~~~~~</span></span><br><span class="line">  <span class="comment">// Property 'last' is missing in type</span></span><br><span class="line">  <span class="comment">// '&#123; first: string; &#125;' but required in type 'Name'</span></span><br><span class="line">  &#123; first: <span class="string">'Sonny'</span> &#125;,</span><br><span class="line">  &#123; first: <span class="string">'Cher'</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-15-동적-데이터에-인덱스-시그니처-사용하기"><a href="#아이템-15-동적-데이터에-인덱스-시그니처-사용하기" class="headerlink" title="아이템 15 동적 데이터에 인덱스 시그니처 사용하기"></a>아이템 15 동적 데이터에 인덱스 시그니처 사용하기</h2><hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/03/220104_rtkCreatApi/" rel="prev" title="RTK Query - createApi">
      <i class="fa fa-chevron-left"></i> RTK Query - createApi
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/06/220207_userAgent/" rel="next" title="사용자 에이전트 (User Agent)">
      사용자 에이전트 (User Agent) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#아이템-10-객체-래퍼-타입-피하기"><span class="nav-number">1.</span> <span class="nav-text">아이템 10 객체 래퍼 타입 피하기</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#자바스크립트의-타입"><span class="nav-number">1.1.</span> <span class="nav-text">자바스크립트의 타입</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#아이템-11-잉여-속성-체크의-한계-인지하기"><span class="nav-number">2.</span> <span class="nav-text">아이템 11 잉여 속성 체크의 한계 인지하기</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#아이템-12-함수-표현식에-타입-적용하기"><span class="nav-number">3.</span> <span class="nav-text">아이템 12 함수 표현식에 타입 적용하기</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#아이템-13-타입과-인터페이스-차이점-알기"><span class="nav-number">4.</span> <span class="nav-text">아이템 13 타입과 인터페이스 차이점 알기</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#type-interface의-비슷한-점"><span class="nav-number">4.1.</span> <span class="nav-text">type, interface의 비슷한 점</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-interface의-다른-점"><span class="nav-number">4.2.</span> <span class="nav-text">type, interface의 다른 점</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-interface를-언제-써야하는가"><span class="nav-number">4.3.</span> <span class="nav-text">type, interface를 언제 써야하는가?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#아이템-14-타입-연산과-제너릭-사용으로-반복-줄이기"><span class="nav-number">5.</span> <span class="nav-text">아이템 14 타입 연산과 제너릭 사용으로 반복 줄이기</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#반복을-줄이는-방법"><span class="nav-number">5.1.</span> <span class="nav-text">반복을 줄이는 방법</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#아이템-15-동적-데이터에-인덱스-시그니처-사용하기"><span class="nav-number">6.</span> <span class="nav-text">아이템 15 동적 데이터에 인덱스 시그니처 사용하기</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Heejin Lee</p>
  <div class="site-description" itemprop="description">Today I Learned</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">107</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heejin Lee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
