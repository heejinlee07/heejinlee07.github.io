---
title: Operating Systems - CPU 스케줄링
date: 2022-05-20
tags:
---

> CPU: 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙 처리 장치

CPU는 일반적으로 시스템 내에 하나 뿐이기 때문에 여러 프로그램이 동시에 수행되는 시분할 환경에서 매우 효율적으로 관리되어야 한다.

프로그램 실행에는 CPU 내에서 수행되는 기계어 명령은 다음의 세 가지가 있다.

1. CPU 내에서 수행되는 명령
2. 메모리 접근을 필요로 하는 명령
3. 입출력을 동반하는 명령

- `CPU 버스트(CPU burst)`: 1,2는 사용자 프로그램이 직접 CPU를 가지고 수행하는 비교적 빠른 명령. 프로그램이 I/O를 한 번 수행한 후 다음번 I/O를 수행하기까지 직접 CPU가지고 명령을 수행하는 일련의 작업이다.
- `I/O 버스트`: 3은 I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하기 때문에 비교적 느린 명령이다. I/O 작업이 요청된 후 완료되어 다시 CPU 버트스토 돌아가기까지 일어나는 일련의 작업이다.

각 프로그램마다 CPU버스트와 I/O 버스트가 차지하는 비율은 균일하지 않지만 아래와 같이 프로세스를 분류해볼 수 있다.

- `I/O 바운드 프로세스`: I/O 요청이 빈번해서 CPU 버스트가 짧게 나타난다. e.g. 대화형 프로그램
- `CPU 바운드 프로세스`: I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타난다. e.g. 계산위주 job

CPU는 이와 같이 사용하는 패턴이 상이한 여러 프로그램이 동일한 시스템 내에서 실행되기 때문에 효율적인 스케줄링이 매우 중요하다. CPU 스케줄링 시 **CPU 버스터가 짧은 프로세스(I/O 바운드 프로세스)에게 우선적으로 CPU를 사용할 수 있도록 한다.** CPU 바운드 프로세스를 먼저 CPU에 할당하면 그 프로세스가 CPU를 다 사용할 때까지 I/O 바운드 프로세스의 응답 시간이 길어지고, 해당 I/O 장치도 그 시간동안 작업을 수행하지 않기 때문이다.

---

## CPU 스케줄러

> 준비 상태에 있는 프로세스 중 *어떠한 프로세스에게 CPU를 할당할지 결정*하는 운영 체제의 코드

### 스케줄링 방식

1. 비선점형 방식(nonpreemptive): CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지 CPU를 빼앗기지 않음.
   1. 실행 상태 -> I/O 요청 -> blocked
   2. CPU에서 실행 중이던 프로세스 종료
2. 선점형 방식(preemptive): 프로세스가 CPU를 계속 사용하기 원하더라도 강제로 빼앗을 수 있음.
   1. 실행 상태 -> 타이머 인터럽트 -> Ready
   2. I/O 요청 -> 봉쇄 -> I/O 작업 완료 -> 인터럽트 -> Ready

## 디스패치

CPU 스케줄러가 어떤 프로세스에세 CPU를 할당할지 결정하고 나면 _새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경 설정을 하는 커널 모듈_

## 스케줄링의 성능 평가

- `시스템 관점`: 시스템 입장에서의 성능 척도. CPU 활용도와 처리량
- `사용자 관점`: 프로그램 입장에서의 성능 척도. 소요 시간, 대기 시간, 응답 시간 등 기다린 시간과 관련된 지표

1. `CPU 활용도`: 전체 시간 중 CPU가 명령을 수행한 시간의 비율. 휴면(idle) 상태에 머무르는 시간을 최대한 줄이는 것이 중요하다.
2. `처리량`: 주어진 시간 동안 CPU 버스트를 완료한 프로세스의 개수. CPU 버스트가 짧은 프로세스에게 우선적으로 할당하는 것이 유리하다.
3. `소요 시간`: 프로세스가 CPU 요청 시점부터 CPU 버스터가 끝날 때까지 걸린 시간. 준비 큐에서 기다린 시간 + 실제로 CPU를 사용한 시간
4. `대기 시간`: 프로세스가 CPU 버스트 기간 중 준비 큐에서 기다린 시간의 합
5. `응답 시간`: 프로세스가 CPU 요청 시점부터 처음으로 CPU를 얻을 때까지 걸린 시간. 시분할 환경에서 매우 중요함.
