---
title: 다차원 배열
date: 2021-06-06
tags: C#
---

- 1차원 배열: [x]
- 2차원 배열: 1차원 배열들의 모임. [x,y] e.g. 엑셀의 테이블형 데이터, 구구단
- 3차원 배열: 2차원 배열들의 모임. [x,y,z]

```c#
static void Main(string[] args)
{
  //배열을 만드는데 콤마가 하나 있다. 2개가 들어온다.
  int[,] table = new int[9,9];

  for (int i = 0; i < 9; ++i)
  {
    for (int j = 0; j < 9; ++j)
    {
      table[i, j] = (i + 1) * (j + 1);
      Console.Write($" {(i + 2), 2} * {j + 1, -2} = {table[i, j], -3}");
    }
    Console.WriteLine("");
  }
}
```

## 2차원 배열 선언하기

> int[,] table = new int[2,4];

> <자료형>[,] <변수명> = new <자료형>[<행의 개수>, <열의 개수>];

- [,]은 2차원을 의미: int[,]은 int형 2차원 배열.([,]와 같은 형태는 다른 언어에는 없다.)
- <행의 개수> \* <열의 개수> 개의 <자료형> 데이터를 담을 2D배열[,]을 만든다.
  - e.g. 2 \* 4개의 int형 자료를 저장할 2차원 배열을 만든다.
- 배열의 이름, 즉 그 배열을 저장할 변수의 이름은 <변수명>
  - e.g. 2 \* 4개의 int형 자료를 저장할 2차원 배열을 만드는데 그 이름은 table이다.

## 2차원 배열의 선언과 동시에 대입하기

- <자료형>[,] <변수명> = new <자료형>[,]{{<데이터>}, {<데이터>}};
- <자료형>[,] <변수명> = new <자료형>[<행의 개수>, <열의 개수>]{{<데이터>}, {<데이터>}};

```c#
int[,] table1 = new int[,] { {1, 2, 3}, {2, 4, 6} };
int[,] table2 = new int[2, 3] { {3, 6, 9}, {4, 8, 12} };
```

| `table1` | [0] | [1] | [2] |
| -------- | --- | --- | --- |
| [0]      | 1   | 2   | 3   |
| [1]      | 2   | 4   | 6   |

| `table2` | [0] | [1] | [2] |
| -------- | --- | --- | --- |
| [0]      | 3   | 6   | 9   |
| [1]      | 4   | 8   | 12  |

---

## for문 속 for문

> 2차원 배열을 순차적으로 접근하기 위해서는 for문이 2개 필요

- `행`을 위한 for문
- `열`을 위한 for문

```c#
int[,] table = new int[2, 3];

for (int i = 0; i < 2; ++i) //행을 위한 for 문
{
  for (int j = 0; j < 3; ++j) //열을 위한 for 문
  {
    table[i, j] = (i + 1) * (j + 1);
  }
}
```

| `table` | [0] | [1] | [2] |
| ------- | --- | --- | --- |
| [0]     | 1   | 2   | 3   |
| [1]     | 2   | 4   | 6   |

1. table[0,0] = (0 + 1) \* (0 + 1) = 1;
2. table[0,1] = (0 + 1) \* (1 + 1) = 2;
3. table[0,2] = (0 + 1) \* (2 + 1) = 3;
4. table[1,0] = (1 + 1) \* (0 + 1) = 2;
5. table[1,1] = (1 + 1) \* (1 + 1) = 4;
6. table[1,2] = (1 + 1) \* (2 + 1) = 6;

---

## 3차원 4차원 배열

### 3차원 배열

- 많이 쓰이지 않음.
- 주로 3차원 정보를 처리하는 프로그램 사용(e.g. 3D 블록데이터를 저장하는 게임(테트리스), 의료 프로그램(CT, MRI 등))

### 4차원 배열

- for문 4개가 필요
- 차원이 늘어날 수록 for문의 수도 증가

### n차원

- 물리 시뮬레이션
- 머신 러닝

> 3차원, 4차원, n차원 등 차원이 늘어날수록 반복문도 많아진다.

- 반복문이 많아질수록 성능이 기하급수적으로 떨어진다.
- **프로그램의 런타임 복잡도는 내포(중첩)된 반복문 개수에 비례한다.**
  - 반복문이 1개: N개의 요소에 방문, O(N)
  - 이중 반복문: N \* N => O(N<sup>2</sup>)
  - 삼중 반복문: N \* N \* N => O(N<sup>3</sup>)
  - N = 100 이면 반복문 개수에 따라 100 => 10,000 => 1,000,000 증가
- O(N<sup>3</sup>)을 O(N)으로 만들 수 있다면 100,000배 빨라질 수 있다.

---

_References_
[실무 프로그래밍 입문(C#)](https://www.udemy.com/share/101tfkAEYTcVxXTXQJ/)
