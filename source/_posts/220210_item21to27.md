---
title: 타입스크립트 이펙티브 아이템 19 - 아이템 20
date: 2022-02-10
tags:
---

## 아이템 21 타입 넓히기

런타임에 모든 변수는 유일한 `값`을 가지고, 타입스크립트가 코드를 체크하는 정적 분석 시점에 변수는 가능한 값들의 집합인 `타입`을 가진다. 그래서 상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커가 타입을 결정해야 한다. *즉 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다.*는 뜻이다. 그리고 이를 `넓히기(widening)`라고 부른다.

```ts
const mixed = ['x', 1];

//추론 가능한 타입
('x' | 1)[]
['x',1]
[string, number]
(string|number)[]

//생략
```

위 예제에서 mixed는 추론 가능한 타입이 여러개이다. 만약 mixed에 대한 타입이 충분하지 않다면 어떤 타입으로 추론되어야 하는지 할 수 없어서 타입스크립트는 작성자의 의도를 추측한다.

### 넓히기 과정을 제어하는 방법

- const의 사용 : let 대신 const로 변수를 선언한다. const는 재할당이 불가하기 때문에 타입스크립트가 추론 가능한 타입이 여러개여서 모호한 과정에 빠지지 않는다. 다만 객체와 배열의 경우 const를 써도 문제가 있다.

```ts
const v = {
  x: 1,
};
v.x = 3; // OK
v.x = '3';
// ~ Type '"3"' is not assignable to type 'number'
v.y = 4;
// ~ Property 'y' does not exist on type '{ x: number; }'
v.name = 'Pythagoras';
// ~~~~ Property 'name' does not exist on type '{ x: number; }'
```

**타입스크립트는 명확성과 유연성 사이의 균형을 유지하려고 한다.** 그래서 구체적으로 타입을 추론해야 하지만, 잘못된 추론을 할 정도로 구체적으로 수행하진 않는다. 만약 타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의한다.

### 타입스크립트의 기본 동작 제어방법

- 명시적 타입 구문 제공
- 타입 체커에 추가적인 문맥 제공
- const 단언만 사용
  - 이 const는 변수 선언에 쓰이는 const와 가른 것이므로 헷갈려서는 안된다. _const 단언문은 온전히 타입 공간의 기법이다._
  - 아래 예제에서 값 뒤에 `as const`를 작성하면 최대한 좁은 타입으로 추론하기 때문에 v3에서 넓히기가 동작하지 않는다.
  - 배열을 튜플로 추론할 때도 `as const`를 쓸 수 있다.

```ts
interface Vector3 {
  x: number;
  y: number;
  z: number;
}
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
  return vector[axis];
}
const v1 = {
  x: 1,
  y: 2,
}; // Type is { x: number; y: number; }

const v2 = {
  x: 1 as const,
  y: 2,
}; // Type is { x: 1; y: number; }

const v3 = {
  x: 1,
  y: 2,
} as const; // Type is { readonly x: 1; readonly y: 2; }
```

---

## 아이템 22 타입 좁히기

`타입 넓히기의 반대개념이다.` 타입스크립트가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말한다.

- null 체크

```ts
//1️⃣
const el = document.getElementById('foo'); // Type is HTMLElement | null
if (el) {
  el; // Type is HTMLElement
  el.innerHTML = 'Party Time'.blink();
} else {
  el; // Type is null
  alert('No element #foo');
}

//2️⃣
const el = document.getElementById('foo'); // Type is HTMLElement | null
if (!el) throw new Error('Unable to find #foo');
el; // Now type is HTMLElement
el.innerHTML = 'Party Time'.blink();
```

위 예시에서 1️⃣의 el이 null이면 첫번 째 블록의 _const el = document.getElementById('foo'); // Type is HTMLElement | null_ 을 실행하지 않기 때문에 *Type is HTMLElement | null*에서 null을 제외하므로 더 좁은 타입이 된다. 2️⃣와 같이 분기문에서 예외를 던지거나 함수를 반환해서 블록의 나머지 부분에서 변수의 타입을 좁힐 수도 있다.

- instanceof사용
- 속성 체크
- Array.isArray 사용
- 조건문 사용

```ts
const el = document.getElementById('foo'); // type is HTMLElement | null
if (typeof el === 'object') {
  el; // Type is HTMLElement | null
}
```

조건문이 가장 타입을 좁히는 데 능숙한 방법이지만 위와 같은 예제처럼 실수를 일으키기 쉽다. 위 예제에서 `typeof null은 object`이기 때문에 if문에서 null이 제외되지 않는다. 다음과 같은 기본형에서도 기본형 값이 잘못되어도 제대로 좁혀지지 않는다. 빈 문자열 ''와 0 모두 false가 되기 때문에 좁혀지지 않는다.

```ts
function foo(x?: number | string | null) {
  if (!x) {
    x; // Type is string | number | null | undefined
  }
}
```

- 명시적 태그를 붙이기 (태그된 유니온 또는 구별된 유니온
- 사용자 정의 타입 가드 사용: 타입스크립트가 타입을 식별하지 못할 때 커스텀 함수를 도입할 수 있다.
- 타입 가드 사용

```ts
const jackson5 = ['Jackie', 'Tito', 'Jermaine', 'Marlon', 'Michael'];
function isDefined<T>(x: T | undefined): x is T {
  return x !== undefined;
}
const members = ['Janet', 'Michael']
  .map((who) => jackson5.find((n) => n === who))
  .filter(isDefined); // Type is string[]
```

---

## 아이템 23 한꺼번에 객체 생성하기
