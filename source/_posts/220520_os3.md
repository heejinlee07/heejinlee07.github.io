---
title: Operating Systems - 프로세스 관리
date: 2022-05-20
tags:
---

## 프로세스의 개념

- `프로세스`: 수행중인 프로그램
- `프로세스 문맥(context)`: 프로세스가 현재 어떤 상태에서 수행되고 있는지를 정확히 규명하기 위해 필요한 정보
- `프로세스 문맥이 중요한 이유` : 타임 쉐어링, 멀티태스킹 등 프로세스들이 번갈아가며 실행되기 때문에 프로세스의 문맥을 파악하고 있어야 이미 실행되던 프로세스를 처음부터 다시 실행한다던가 하는 문제가 생기지 않는다.

프로세스 문맥을 파악하려면 다음의 3가지 요소를 알아야 한다.

- 프로그램 카운터가 어디를 가리키고 있는가? (code의 어느 부분까지 실행했는가?)
- 메모리에 어떤 내용을 담고 있는가?
- 레지스터에 어떤 값을 넣어두고, 어떤 instruction(프로그램의 기계어를 읽어서 CPU 안으로 불러들임)까지 실행했는가?

### 프로세스 문맥의 분류

- 하드웨어 문맥: **CPU의 수행상태.** 카운터 값, 각종 레지스터에 저장하고 있는 값들
- 프로세스의 주소 공간: **프로세스는 코드, 데이터, 스택으로 구성되는 자기만의 독자적인 주소 공간을 가지고 있고,** 이것이 프로세스의 문맥을 결정짓는 중요한 요소이다.
- 커널 상의 문맥: 프로그램이 수행되어 프로세스가 되면 **프로세스를 관리하기 위한 자료 구조를 유지하게 된다.** PCB, 커널 스택이 이에 해당한다.

## 프로세스의 상태

> 프로세스는 상태가 변경되며 수행되고, 항상 아래 상태 중 어느 한 상태에 머물러 있게 된다.

- `실행 상태(running)`: 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태. CPU는 하나 뿐이기 때문에 여러 프로세스가 동시에 실행된다고 해도 **실제 실행 상태에 있는 프로세스는 매 시점 하나 뿐이다.**
- `준비 상태(ready)`: 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태.
- `봉쇄 상태(blocked, wait, sleep)`: 프로세스에게 CPU를 주어도 당장 명령을 실행할 수 없는 상태.
- `시작 상태(new)`: 프로세스가 시작되어 각종 자료 구조가 생성되었지만 아직 메모리 획득을 승인받지 못한 상태
- `완료 상태(terminated)`: 프로세스가 종료되었으나 운영 체제가 프로세스와 관련된 자료 구조를 완전히 정리하지 못한 상태
- `중지(stopped, suspended)`: 중기 스케줄러의 등장으로 추가된 상태. 외부적인 이유로 프로세스의 수행이 정지된 상태이다.

  - `중지 준비(suspended ready)`: **준비 상태에 있던** 프로세스가 중기 스케줄러에 의해 디스크로 스왑 아웃되면 중지 준비 상태가 된다. 외부에서 재개시키지 않는 이상 다시 활성화되지 않는다.
  - `중지 봉쇄(suspended block)`: **봉쇄 상태에 있던** 프로세스가 중기 스케줄러에 의해 스왑 아웃된다. 이 상태에서 프로세스가 봉쇄되었던 조건을 만족하면 중지 준비 상태로 바뀐다.

  - **봉쇄 상태와 중지 상태의 차이**
    - 봉쇄 상태: 자신이 요청한 이벤트가 만족되어야 Ready
    - 중지 상태: 외부에서 resume를 해주어야 Active

1. 프로세스의 상태는 시간의 흐름에 따라 변화한다. _준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정을 `CPU 디스패치`라고 한다._
   `new` -> `메모리 적재` -> `ready(in memory)` -> `CPU 획득(디스패치)` -> `running` -> `terminated`
2. 타이머 인터럽트가 발생한 경우 원래 진행하던 프로세스의 문맥을 저장하고, ready 상태에 있는 프로세스 중 하나에 새롭게 CPU 제어권을 부여하고 실행한다. _실행시킬 프로세스를 변경하기 위해 원래 수행중이던 프로세스의 문맥을 저장하고, 새로운 프로세스의 문맥을 세팅하는 과정을 `문맥 교환(context switch)`이라 한다._
   `new` -> `메모리 적재` -> `ready(in memory)` -> `CPU 획득(디스패치)` -> `running` -> _`타이머 인터럽트`_ -> `ready`

   ### 문맥교환

   > 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 _CPU의 제어권이 이양되는 과정_

   #### 문맥 교환의 과정

   - 원래 CPU를 보유하고 있던 프로세스가 프로세스 카운터 값 등 **프로세스의 문맥을 자신의 PCB에 저장**
   - 새롭게 CPU를 할당받을 프로세스가 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원
   - 타이머 인터럽트나 I/O 요청으로 프로그램이 봉쇄 상태인 경우 문맥 교환이 발생하지만 **그 밖의 인터럽트나 시스템 콜 발생 시에는 모드 변경만 있다.** 프로세스의 실행 모드가 사용자에서 커널로 변경된 것일 뿐, CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 것이 아니기 때문이다.
   - 프로세스 간 문맥 교환이 빈번해지면 오버헤드도 상당히 커진다.

     - 문맥 교환이 발생하지 않는 경우
       `user mode(사용자 프로세스 A)` -> _`interrupt or system call`_ -> `kernel mode(ISR or system call 함수)` -> -> _`문맥 교환 없이 user mode 복귀`_ -> `user mode(사용자 프로세스 A)`

     - 문맥 교환이 발생하는 경우
       `user mode(사용자 프로세스 A)` -> _`timer interrupt or I/O 요청 system call`_ -> `kernel mode` -> _`문맥 교환 발생`_ -> `user mode(사용자 프로세스 B)`

3. I/O 요청이 발생한 경우에도 실행 상태에 있던 프로세스가 봉쇄 상태로 바뀌는 문맥 교환이 발생한다.
   `new` -> `메모리 적재` -> `ready(in memory)` -> `CPU 획득(디스패치)` -> `running` -> _`I/O 또는 사건 대기`_ -> _`waiting(blocked)`_ -> _`I/O 또는 사건 완료`_ -> `ready`

---

## 프로세스 제어 블록 (PCB: Process Control Block)

운영 체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스당 유지하는 정보를 담는 커널 내의 자료 구조

<table>
  <tr>
    <td rowspan="2">1.<br> 
    OS가 사용하는 정보</td>
    <td>pointer</td>
    <td>process state</td>
  </tr>
  <tr>
    <td colspan="3">process number</td>
  </tr>
    <tr>
    <td rowspan="2">2.<br>CPU 수행 관련 하드웨어 값</td>
    <td colspan="3">process counter</td>
  </tr>
    <tr>
    <td colspan="3">registers</td>
  </tr>
    <tr>
    <td>3.<br>메모리 관련</td>
    <td colspan="3">memory limits</td>
  </tr>
  </tr>
    <tr>
    <td rowspan="2">4.<br>파일 관련</td>
    <td colspan="3">open files</td>
  </tr>
    </tr>
    <tr>
    <td colspan="3">...</td>
  </tr>
</table>

---

## 프로세스를 스케줄링하기 위한 큐

> 프로세스는 각 큐를 오가며 수행한다.

- `작업 큐(job queue)`: 시스템 내 모든 프로세스를 관리하기 위한 큐. _프로세스 상태와 무관하게 모든 프로세스 상태가 속하지만 작업 큐에 있다고 해서 반드시 메모리를 가진 것은 아니다._
- `준비 큐(ready queue)`: CPU를 할당받고 실행되기 위해 기다리고 있는 프로세스의 집합. _프로세스는 준비 상태_
- `장치 큐(device queue)`: 각각의 장치마다 서비스를 기다리며 줄 서 있는 프로세스의 큐. _프로세스는 봉쇄 상태_

---

## 스케줄러

> 어떤 프로세스에게 자원을 할당할지를 결정하는 운영 체제 커널의 모듈

- `장기 스케줄러(job scheduler)`: **어떤 프로세스를 준비 큐에 삽입할지를 결정한다.** 준비 큐는 CPU만 얻으면 당장 실행 가능한 프로세스이기 때문에 메모리를 보유해야 하고, **메모리 또는 각종 자원을 얼마나 할당할지에 대해서도 관여한다.**
- 수십 초 내 수 분 단위로 가끔 호출되므로 상대적으로 속도가 느려도 된다.
- 메모리에 동시에 올라가 있는 프로세스의 수를 조절한다.
- 현대 시분할 시스템에서는 보통 장기 스케줄러가 없다.

중기 스케줄러: 현대 시분할 시스템용 운영체제에서 사용한다. 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하될 때 메모리에 적재된 프로세스의 수를 동적으로 조절한다.
프로세스당 보유 메모리량이 지나치게 적으면 일부 프로세스를 메모리에서 디스크로 스왑 아웃시킨다.

- `단기 스케줄러(CPU scheduler)`: 준비 상태의 프로세스 중에서 **어떤 프로세스를 다음 번에 실행 상태로 만들 것인지 결정한다.** 준비 큐에 있는 프로세스 중 어떤 프로세스에게 CPU를 할당할지를 결정하고, _시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다._
- ms 이하 단위로 매우 빈번하게 호출되므로 속도가 빨라야 한다.

---

## 프로세스의 생성

> 시스템 부팅 후 최초의 프로세스는 운영 체제가 생성하고, 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성

- 부모 프로세스: 프로세스를 생성한 프로세스
- 자식 프로세스: 새롭게 생성된 프로세스

부모 프로세스가 자식 프로세스를 생성하는 방식으로 족보(Tree)와 같은 계층 구조를 형성한다.

### 프로세스의 작업 수행

프로세스가 작업을 하려면 자원이 필요한데 아래와 같은 세가지 유형으로 자원을 공유한다.

- 부모-자식이 모든 자원을 공유
- 일부를 공유
- 전혀 공유하지 않음

### 프로세스가 수행되는 모델

- 부모-자식이 공존하며 수행: 자식과 부모가 CPU를 획득하기 위해 경쟁하는 관계.
- 자식이 종료될 때까지 부모가 기다림: 자식 프로세스가 종료될 때까지 부모 프로세스는 봉쇄 상태에 있다가 자식 프로세스가 종료되면 부모는 준비 상태가 되어 다시 CPU를 얻을 권한이 생긴다.

### 프로세스의 생성 절차

> 프로세스는 생성되면 자신만의 독자적인 주소 공간을 갖고, **자식 프로세스는 부모 프로세스의 주소 공간 내용을 그대로 복사해서 생성한다.**

- `생성`: 유닉스에서는 fork() 시스템 콜로 새로운 프로세스를 생성하고, 자식 프로세스를 생성할 때 부모 프로세스의 내용을 그대로 복제 생성한다. 부모 프로세스의 모든 문맥을 복제해서 생성되었기 때문에 부모 프로세스가 현재 수행한 시점(프로그램 카운터 지점)부터 수행할 수 있다.

- `종료`: 부모 프로세스 종료 전에 자식 프로세스부터 종료되어야 한다.
  - `자발적 종료`: 프로세스가 마지막 명령 수행 후 exit() 시스템 콜로 운영 체제에게 알린다.
  - `비자발적 종료`: 부모 프로세스가 abort()를 호출하여 자식 프로세스의 수행을 강제 종료시킨다.

## 프로세스 간의 협력

> 프로세스는 각자 자신의 독립적인 주소 공간을 가지고 수행하므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없다.

하지만 독립적인 프로세스들이 서로 협력할 때 효율적인 경우 `협력 매커니즘`을 제공하여 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있도록 한다.

### IPC(Inter-Process Communication)

대표적인 협력 매커니즘으로 하나의 컴퓨터 안에서 실행중인 서로 다른 프로세스 간에 발생하는 통신. 의사 소통 기능과 동기화가 보장되어야 한다.

- 메시지 전달: 프로세스 간 공유 변수를 사용하지 않고, 커널을 통해 메시지를 전달하는 방법으로 통신
- 공유 메모리: 프로세스 간 공유 변수를 사용하여 주소 공간의 일부를 공유한다.

### 스레드

스레드는 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 **동일한 프로세스를 구성하는 스레드 간에는 주소 공간을 공유하므로 협력이 가능하다.**

- program counter, register set, stack space로 구성된다.
- 스레드가 동료 스레드와 공유하는 부분(task): code section, data section, OS resource

---

_References_
[운영체제](http://www.kocw.net/home/search/kemView.do?kemId=1046323)
[운영 체제와 정보 기술의 원리] 반효경 지음
