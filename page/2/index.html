<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heejinlee07.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Today I Learned">
<meta property="og:type" content="website">
<meta property="og:title" content="Heejin">
<meta property="og:url" content="https://heejinlee07.github.io/page/2/index.html">
<meta property="og:site_name" content="Heejin">
<meta property="og:description" content="Today I Learned">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Heejin Lee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://heejinlee07.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Heejin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heejin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Front-end Developer</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/01/220302_blockchain01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/220302_blockchain01/" class="post-title-link" itemprop="url">블록체인 무엇인가? 1장 소프트웨어 공학에서 변하지 않는 주요 개념들</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-02T00:00:00+09:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 13:09:35" itemprop="dateModified" datetime="2022-05-18T13:09:35+09:00">2022-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>블록체인의 기본 개념을 제대로 알지 못하면 블록체인의 전반적인 가치나 잠재적인 영향력을 가늠할 수 없을뿐더러 블록체인이 창출하는 부가가치를 이해하기가 어렵다. 또한 (블록체인을 포함해서) 새로운 기술에 대한 개념적 이해가 부족하면 자극적이고 과장된 광고에 휩쓸려 비현실적이고 실현 불가능한 망상에 사로잡히기 쉬워 나중에 실망할 수도 있다. 따라서 이 책은 ‘블록체인의 기본 개념’에 집중한다.<br>&lt;책 서문 발췌&gt;</p>
</blockquote>
<h1 id="1-소프트웨어-공학에서-변하지-않는-주요-개념들"><a href="#1-소프트웨어-공학에서-변하지-않는-주요-개념들" class="headerlink" title="1. 소프트웨어 공학에서 변하지 않는 주요 개념들"></a>1. 소프트웨어 공학에서 변하지 않는 주요 개념들</h1><h2 id="1-시스템을-보는-눈-장착하기"><a href="#1-시스템을-보는-눈-장착하기" class="headerlink" title="1. 시스템을 보는 눈 장착하기"></a>1. 시스템을 보는 눈 장착하기</h2><h3 id="시스템을-계층과-측면으로-분리해-분석하기"><a href="#시스템을-계층과-측면으로-분리해-분석하기" class="headerlink" title="시스템을 계층과 측면으로 분리해 분석하기"></a>시스템을 계층과 측면으로 분리해 분석하기</h3><p>시스템을 개념적으로 분리하기 위해 사용하는 구분 기준은 다음의 두 가지다.</p>
<ul>
<li>응용계층 vs 구현계층</li>
<li>기능적 측면 vs 비기능적 측면</li>
</ul>
<h3 id="1-응용계층-vs-구현계층"><a href="#1-응용계층-vs-구현계층" class="headerlink" title="1. 응용계층 vs 구현계층"></a>1. 응용계층 vs 구현계층</h3><ul>
<li>응용계층: 사용자의 요구사항</li>
<li>구현계층: 요구사항을 실현. 구성요소는 본질적으로 기술적이다. 응용계층에서 사용자의 필요사항을 만족시키기 위한 수단.</li>
</ul>
<h3 id="2-기능적-측면-vs-비기능적-측면"><a href="#2-기능적-측면-vs-비기능적-측면" class="headerlink" title="2. 기능적 측면 vs 비기능적 측면"></a>2. 기능적 측면 vs 비기능적 측면</h3><ul>
<li>기능적 측면: 시스템이 <code>무엇</code>을 하는가? 동사적 역할. e.g. 네트워크를 통한 데이터 전송, 음악 연주 등</li>
<li>비기능적 측면: 시스템이 무엇을 <code>어떻게</code> 하는가? 부사적 역할. e.g. 멋진 인터페이스, 실행속도가 빠른 소프트웨어<ul>
<li>보안: 정확성을 포함하는 개념</li>
<li><code>무결성(integrity)</code>: 시스템이 의도한 대로 작동하는 것. 보안과 정확성 모두를 포함하는 개념</li>
</ul>
</li>
</ul>
<h3 id="사용자는-응용계층의-기능적-측면을-중시한다"><a href="#사용자는-응용계층의-기능적-측면을-중시한다" class="headerlink" title="사용자는 응용계층의 기능적 측면을 중시한다."></a>사용자는 응용계층의 기능적 측면을 중시한다.</h3><p>응용계층의 기능적 측면은 사용자의 명확한 요구사항들이므로 시스템에서 가장 중요하게 부각된다. <strong>반면 구현계층의 비기능적 요소는 시스템의 주요 요소가 아니라 아주 당연한 것으로 여겨진다. 그런데 비기능적 요소 중 무결성 같은 것은 눈에 보이지 않지만 매우 중요하다.</strong></p>
<h3 id="무결성의-주요-요소"><a href="#무결성의-주요-요소" class="headerlink" title="무결성의 주요 요소"></a>무결성의 주요 요소</h3><ul>
<li>데이터 무결성: 시스템에서 사용하고 유지 관리하는 데이터는 완전하고 정확하며 모순이 없다.</li>
<li>작동 무결성: 시스템은 의도한 대로 작동하며 논리적 오류가 없다.</li>
<li>보안: 시스템은 허가받은 사용자에게만 데이터 및 기능에 대한 접근 권한을 부여할 수 있다.</li>
</ul>
<hr>
<h2 id="2-큰-그림으로-바라보기"><a href="#2-큰-그림으로-바라보기" class="headerlink" title="2. 큰 그림으로 바라보기"></a>2. 큰 그림으로 바라보기</h2><p>노드, 컴퓨터, 피어는 동일한 의미를 가질 때가 많지만 반드시 그렇지 않다. 구조에 따라 단일 컴퓨터가 복수의 노드 역할을 할 수 있고, 하나의 노드에 복수의 컴퓨터가 연결되어 있을 수도 있다.</p>
<ul>
<li>피어:<ul>
<li>전체 시스템 노드 중 나와 직접 연결된 노드. 이더리움에서 구분해서 사용한다.</li>
<li>일대일의 의미를 강조하거나 노드를 사용해 특정 행위를 하는 사람의 관점에서 피어라 부름.</li>
</ul>
</li>
<li>노드: 보통의 책에서 전체 시스템 내의 한 요소임을 강조할 때 사용.</li>
<li>컴퓨터: 공유하는 자원 측면에 대해 기술할 때.</li>
</ul>
<h3 id="소프트웨어-아키텍처란-무엇이고-블록체인과-어떤-관계인가"><a href="#소프트웨어-아키텍처란-무엇이고-블록체인과-어떤-관계인가" class="headerlink" title="소프트웨어 아키텍처란 무엇이고 블록체인과 어떤 관계인가?"></a>소프트웨어 아키텍처란 무엇이고 블록체인과 어떤 관계인가?</h3><p>소프트웨어 시스템을 구현하는 방법은 여러가지가 있는데, <code>시스템 아키텍처</code>는 필수적으로 결정해야 한다. <em>시스템 아키텍처는 구성요소를 구조화하고, 구성요소 간 관계를 설정하는 방식을 의미한다.</em> 주로 사용되는 아키텍처는 <code>중앙 통제 방식</code>,<code>분산방식</code>이 있다.</p>
<ul>
<li>중앙 통제 방식<ul>
<li>구성요소들이 하나의 중앙요소에 연결되며, 중앙 요소를 가운데 두고 나머지 요소들이 둘러싸고 있는 구조.</li>
<li>모든 구성요소끼리 직접적으로 연결되지 않고 오직 중앙 요소와만 직접 연결되어 있다.</li>
</ul>
</li>
<li>분산 방식<ul>
<li>시스템을 통제하거나 조정하는 요소 없이 서로 연결된 네트워크 구조를 형성.</li>
<li>모든 구성 요소와 직접적으로 연결된 노드는 단 하나도 없지만 모든 노드는 간접적으로 서로 완전히 연결되어 있다.</li>
</ul>
</li>
</ul>
<h3 id="분산-시스템의-장점"><a href="#분산-시스템의-장점" class="headerlink" title="분산 시스템의 장점"></a>분산 시스템의 장점</h3><ol>
<li><p>계산 능력이 뛰어나다.</p>
<ol>
<li>서로 연결된 모든 컴퓨터의 계산 능력이 합쳐져 발현되기 때문에 단일 컴퓨터보다 더 강력한 계산 능력을 가진다.</li>
</ol>
</li>
<li><p>비용이 절감된다.</p>
<ol>
<li>여러 대의 컴퓨터로 구성되므로 초기 구성 비용은 슈퍼 컴퓨터보다 많지만 유지 운영 비용은 훨씬 적다. 또 슈퍼 컴퓨터와 달리 개별 컴퓨터가 교체 될 때 전체 시스템에 별 영향을 끼치지 않는다.</li>
</ol>
</li>
<li><p>더 안정적이다.</p>
<ol>
<li>시스템을 구성하는 개별 컴퓨터가 고장나면 나머지 구성요소들이 그 일을 대신하기 때문에 전체 네트워크는 문제없이 잘 작동한다.</li>
</ol>
</li>
<li><p>자연스럽게 확장된다.</p>
<ol>
<li>앞서 계산 능력은 연결된 모든 컴퓨터의 계산 능력을 합친 것이라 했으므로, 시스템에 컴퓨터를 추가하면 손쉽게 전체 계산 능력을 높일 수 있다.</li>
</ol>
</li>
</ol>
<h3 id="분산-시스템의-단점"><a href="#분산-시스템의-단점" class="headerlink" title="분산 시스템의 단점"></a>분산 시스템의 단점</h3><ol>
<li><p>조정 오버헤드가 발생한다.</p>
<ol>
<li>중앙 통제 방식과 달리 중앙 요소가 존재하지 않기 때문에 구성요소들 스스로 조정을 해야하는데 이 조정이 쉽지 않아 많은 자원이 소모되는 오버헤드가 발생한다.</li>
</ol>
</li>
<li><p>통신 오버헤드가 발생한다.</p>
<ol>
<li>조정을 위해서 통신이 필수적이고, 이 통신을 위해 계산 능력의 일부가 통신 프로토콜 지원 및 메시지 송수신 및 처리에 소모된다.</li>
</ol>
</li>
<li><p>네트워크 의존도가 높다.</p>
<ol>
<li>컴퓨터들은 네트워크를 통해 통신하는데, 모든 네트워크는 자체적인 결함과 장애 가능성이 내재되어 있기 때문에 통신과 조정에 영향을 끼친다. 그리고 네트워크가 없으면 각 구성요소 간의 협력이 불가하기 때문에 네트워크 의존도가 높다.</li>
</ol>
</li>
<li><p>프로그램이 복잡해진다.</p>
<ol>
<li>앞서 말한 단점들을 해결하기 위해 중앙 통제 방식에서는 필요없는 조정, 통신, 네트워크 이용에 관련된 추가적인 문제 해결 등이 필요하다.</li>
</ol>
</li>
<li><p>보안에 신경써야 한다.</p>
<ol>
<li>네트워크를 통한 통신은 계산 작업 시 데이터의 전송과 공유가 꼭 필요하다. 그러나 이런 행위로 인해 악의를 가진 개체가 정보에 접근하여 악용하는 보안문제가 발생할 수 있다.</li>
</ol>
</li>
</ol>
<h3 id="사용자가-많아질수록-더-강력해지는-분산-P2P-시스템"><a href="#사용자가-많아질수록-더-강력해지는-분산-P2P-시스템" class="headerlink" title="사용자가 많아질수록 더 강력해지는 분산 P2P 시스템"></a>사용자가 많아질수록 더 강력해지는 분산 P2P 시스템</h3><blockquote>
<p>Peer to Peer 네트워크 또는 P2P 네트워크. 분산 네트워크의 특수한 형태</p>
</blockquote>
<p>개별 컴퓨터(노드)로 구성된 시스템으로 중앙 노드의 조정 없이 네트워크의 모든 구성원이 서로에게 계산 자원을 제공한다. <strong>네트워크의 각 노드는 시스템 내에서 동등한 권리와 역할을 가지고, 모두가 자원의 공급자인 동시에 소비자이다.</strong> 사용자들의 컴퓨터를 분산 시스템을 구성하는 노드로 만든다는 아이디어를 배경으로 다양한 분야에 응용이 가능하다.</p>
<h3 id="중앙-통제와-분산-시스템의-장점만-모은-혼합-시스템"><a href="#중앙-통제와-분산-시스템의-장점만-모은-혼합-시스템" class="headerlink" title="중앙 통제와 분산 시스템의 장점만 모은 혼합 시스템"></a>중앙 통제와 분산 시스템의 장점만 모은 혼합 시스템</h3><p>중앙 통제 시스템과 분산 시스템은 정반대의 구조를 가지고 있는데, 이 각각의 강점만 결합한 혼합 시스템이 있다.</p>
<ul>
<li><p>분산 시스템 내의 중앙 통제<br>분산 시스템 내부에 중앙 통제 요소를 구축한 아키텍처로 겉보기에 분산 시스템을 이루는 것처럼 보이지만 <strong>모든 노드는 중앙의 큰 원에 직접 연결되어 있다.</strong></p>
</li>
<li><p>중앙 통제 시스템 내의 분산 시스템<br>겉보기에 주변 노드가 모드 중앙의 큰 원에 직접 연결되어 있는 중앙 통제 시스템처럼 보이는데, 중앙의 큰 원 내부를 들여다보면 분산 시스템으로 구성되어 있다. 심지어 주변 구성요소들은 중앙 요소가 분산 시스템으로 이루어져 있는지 모를 수도 있다.</p>
</li>
</ul>
<h3 id="분산-시스템인지-구분하는-방법"><a href="#분산-시스템인지-구분하는-방법" class="headerlink" title="분산 시스템인지 구분하는 방법"></a>분산 시스템인지 구분하는 방법</h3><p>전체 시스템을 동시에 종료할 수 있는 단일 구성요소가 있는지 찾는다. 이런 요소가 있다면 분산 시스템이 아니다.</p>
<h3 id="큰-그림으로-본-블록체인의-목적"><a href="#큰-그림으로-본-블록체인의-목적" class="headerlink" title="큰 그림으로 본 블록체인의 목적"></a>큰 그림으로 본 블록체인의 목적</h3><p>소프트웨어 시스템 디자인에서 아키텍처의 선정은 시스템 구현 관점에서 목적 달성을 위한 수단이기 때문에 분산 방식 또는 중앙 통제 방식 중 어떤 것으로도 구현할 수 있다. 다만 어떤 아키텍처를 선택하느냐에 따라 시스템이 기능적, 비기능적 측면을 달성하는 방법에 영향을 미친다. <strong>특히 무결성에 대해서 두 가지 아키텍처가 매우 다른 방식으로 접근하기 때문에 이런 점에서 블록 체인이 중요하다.</strong> <code>블록체인은 분산 시스템이 무결성을 확보하게 해주는 도구이며, 분산 시스템의 무결성을 구현하고 유지하는 것이 바로 블록체인의 목적이다.</code>즉 구현계층의 비기능적 측면을 성취하게 해주는 도구이다.</p>
<hr>
<h2 id="3-P2P-시스템의-엄청난-잠재력"><a href="#3-P2P-시스템의-엄청난-잠재력" class="headerlink" title="3. P2P 시스템의 엄청난 잠재력"></a>3. P2P 시스템의 엄청난 잠재력</h2><h3 id="P2P-시스템이-세상을-어떻게-바꿀-것인가"><a href="#P2P-시스템이-세상을-어떻게-바꿀-것인가" class="headerlink" title="P2P 시스템이 세상을 어떻게 바꿀 것인가?"></a>P2P 시스템이 세상을 어떻게 바꿀 것인가?</h3><p>P2P 시스템이 음악산업을 어떻게 변화시켰는지를 보면서 블록체인과 어떤 관계가 있는지 살펴본다. 전통적인 음악산업은 음악가와 스튜디오가 계약을 맺고, 스튜디오가 음악가의 노래를 녹음해서 다양한 유통채널을 통해 판매하는 구조로 운영되어 왔다. 스튜디오가 사실상 음악가와 음악을 청취하고자 하는 사람들 사이의 <code>중개자</code>역할을 한 것이다. 중개자로서 스튜디오는 음반제작 전반에 관한 독점적 지식을 가지고 있었는데 2000년대 이후 음악의 디지털화, 개인 PC 보급 확대, 인터넷의 등장 등이 스튜디오를 더이상 필요하지 않게 만들었다. 즉 스튜디오가 가지고 있던 독점적인 지식인 제작, 마케팅, 판매를 스튜디오를 거치지 않고도 가능하게 된 것이다. 특히 냅스터라는 소프트웨어의 등장은 P2P 접근방식으로 MP3 파일을 공유하는 방식으로 음악을 소비하게 해주었기 때문에 스튜디오의 효용성이 더욱 떨어지게 되었다. 냅스터의 사례처럼 <strong>중개자 역할을 개인간의 상호작용으로 대체한다.</strong>는 아이디어를 기반으로 P2P 시스템이 음악 산업이 생태계 전쳬를 뒤흔든 것이다.</p>
<p>그런데 이런 P2P 시스템은 앞으로도 무형의 상품이나 디지털화된 상품 또는 서비스를 중개하는 역할을 주업으로 하는 산업에 큰 영향을 미치게 될 것이고, 결국은 이런 산업의 생태계도 P2P로 대체될 가능성이 높다. 금융업이 대표적인 예라고 할 수 있다. 대부분의 돈과 자산은 물리적인 지폐나 동전으로 거래되기 보다는 금융회사의 중앙 정보 기술 시스템에 저장되어 있고, 은행은 소비하는 사람들과 회사 사이의 중개자 역할을 주로 수행한다. 다만 간단한 거래 하나에도 상당수 많은 중개자가 관여하고 있어서 오랜 처리 시간과 많은 거래 비용을 필요로 하는 상황이다. 만약 P2P 거래 시스템을 사용한다면 훨씬 적은 시간과 비용을 들여 거래를 진행할 수 있다. 현재 은행의 중앙 통제 시스템에 비해 P2P 시스템은 중개자를 통해 간접적으로 상호작용하지 않고 거래 당사자끼리 직접 상호작용하기 때문에 처리 시간과 비용이 줄어든다.</p>
<h3 id="P2P-시스템과-블록체인은-어떤-관련이-있나"><a href="#P2P-시스템과-블록체인은-어떤-관련이-있나" class="headerlink" title="P2P 시스템과 블록체인은 어떤 관련이 있나?"></a>P2P 시스템과 블록체인은 어떤 관련이 있나?</h3><ol>
<li>P2P 시스템의 정의</li>
</ol>
<blockquote>
<p>여러 노드(개별 컴퓨터)들로 구성된 분산 소프트웨어 시스템. <code>한 노드의 자원을 다른 노드들이 직접 사용</code>할 수 있다는 특징이 있다.</p>
</blockquote>
<p>P2P 시스템에 참여하면 사용자의 컴퓨터는 시스템의 노드로 전환되고, 모든 노드에게는 동등한 권리와 역할이 주어진다. <strong>즉 시스템의 모든 노드는 동일한 기능과 책임을 가지고, 모든 사용자의 컴퓨터는 자원의 공급자인 동시에 소비자가 된다.</strong></p>
<ol>
<li>P2P 시스템의 아키텍처</li>
</ol>
<blockquote>
<p>P2P 시스템의 구조는 <code>분산 컴퓨터 시스템</code></p>
</blockquote>
<p>개별 노드로 구성된 컴퓨터들은 서로 자원을 공유한다. 순수 분산 P2P 시스템은 중앙에서 통제하거나 조정하는 어떤 요소도 없다. 따라서 모든 노드는 동일한 과제를 수행하고, 자원과 서비스의 생산자인 동시에 소비자 역할을 한다. 물론 중앙 통제 요소를 가지는 P2P 시스템도 존재한다. 이 시스템은 중앙 통제와 분산 시스템이 장점만을 뽑아 만들어진 것으로 중앙 노드를 이용해 노드 간 상호작용을 중개하고, 피어 노드가 제공하는 서비스 목록들을 유지 관리하고 노드를 검색하고 식별한다.</p>
<ol>
<li>P2P 시스템과 블록체인의 연관성</li>
</ol>
<blockquote>
<p>블록체인은 분산 시스템에서 무결성을 확보하고 유지하는 도구이다. <code>즉 순수 분산 P2P 시스템은 무결성의 확보와 유지를 위해 블록체인을 사용한다.</code></p>
</blockquote>
<p>이러한 P2P 시스템과 블록체인의 연관성 때문에 블록체인이 중요한 요소가 된 것이고, 무결성을 유지하고 확보하기 위한 도구라는 점보다 더욱 중요한 점은 <code>탈중개화</code>이다. 블록체인은 단지 <code>탈중개화</code>를 위한 도구일 뿐이다.</p>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/01/220302_item56to62/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/220302_item56to62/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 56 - 아이템 62</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-02T00:00:00+09:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 13:09:35" itemprop="dateModified" datetime="2022-05-18T13:09:35+09:00">2022-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-56-정보를-감추는-목적으로-private-사용하지-않기"><a href="#아이템-56-정보를-감추는-목적으로-private-사용하지-않기" class="headerlink" title="아이템 56 정보를 감추는 목적으로 private 사용하지 않기"></a>아이템 56 정보를 감추는 목적으로 private 사용하지 않기</h2><p>자바스크립트는 클래스에 비공개 속성을 만들 수 없다. 비공개 속성임을 나태내기 위해 <code>언더스코어(_)</code>를 접두사로 붙이던 것이 관례로 인정되어 왔던 것 뿐이다. <em>하지만 언더스코어를 붙이는 것은 비공개라고 표시한 것 뿐, 일반적인 속성과 동일하게 클래스 외부로 공개되어 있다.</em></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Diary &#123;</span><br><span class="line">  <span class="keyword">private</span> secret = <span class="string">'cheated on my English test'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> diary = <span class="keyword">new</span> Diary()</span><br><span class="line">;(diary <span class="keyword">as</span> <span class="built_in">any</span>).secret <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>타입스크립트에서 위의 예시처럼 public, protected, private 접근 제어자를 사용하기 때문에 규칙을 강제하는 것으로 오해하기 쉬운데 <strong>이는 타입스크립트 키워드이기 때문에 컴파일 후에 제거된다.</strong> 그래서 타입스크립트의 컴파일되면 위의 예제는 아래의 예제처럼 자바스크립트 코드(target=ES2017)로 변환된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Diary &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.secret = <span class="string">'cheated on my English test'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> diary = <span class="keyword">new</span> Diary()</span><br><span class="line">diary.secret</span><br></pre></td></tr></table></figure>
<p>컴파일 후에 확인해보면 타입스크립트 키워드인 private이 제거되었고, secret은 일반적인 속성이어서 접근할 수 있다. 즉 언더스코어의 관례처럼 타입스크립트의 접근 제어자들도 런타임에는 아무런 효력이 없다. 심지어 타입스크립트 상태에서도 단언문을 사용하면 private에 접근 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">text: string</span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">PasswordChecker</span> </span>&#123;</span><br><span class="line">  checkPassword: <span class="function">(<span class="params">password: string</span>) =&gt;</span> boolean</span><br><span class="line">  <span class="keyword">constructor</span>(passwordHash: number) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkPassword = <span class="function">(<span class="params">password: string</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> hash(password) === passwordHash</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checker = <span class="keyword">new</span> PasswordChecker(hash(<span class="string">'s3cret'</span>))</span><br><span class="line">checker.checkPassword(<span class="string">'s3cret'</span>) <span class="comment">// Returns true</span></span><br></pre></td></tr></table></figure>
<p>따라서 정보를 감추기 위한 목적으로 private을 사용하면 안된다. <em>자바스크립트에서 정보를 숨기기 위한 가장 효과적은 방법은 클로저이다.</em> 위의 예시는 생성자에서 클로저를 만드는 예시이다. 이렇게 작성하면 PasswordChecker의 생성자 외부에서 passwordHash 변수에 접근할 수 없어서 정보를 숨기는 목적은 달성하게 되는데, 주의사항이 있다. passwordHash를 생성자 외부에서 접근할 수 없기 때문에 passwordHash에 접근해야 하는 메서드는 생성자 내부에 정의되어야 한다. 또 메서드 정의가 생성자 내부에 존재하게 되면, 인스턴스를 생성할 때마다 각 메서드의 복사본이 생성되기 때문에 메모리를 낭비하게 된다. 클로저를 쓰지 않으면 현재 표준화가 진행 중인 비공개 필드 기능을 사용할 수 있는데, 접두사 #을 붙여서 타입 체크과 런타임 모두에서 비공개로 만드는 역할을 한다.</p>
<hr>
<h2 id="아이템-57-소스맵을-사용하여-타입스크립트-디버깅하기"><a href="#아이템-57-소스맵을-사용하여-타입스크립트-디버깅하기" class="headerlink" title="아이템 57 소스맵을 사용하여 타입스크립트 디버깅하기"></a>아이템 57 소스맵을 사용하여 타입스크립트 디버깅하기</h2><p>타입스크립트 코드를 실행한다는 것은 타입스크립트 컴파일러가 생성한 자바스크립트 코드를 생성한다는 것이다. 그런데 변환된 자바스크립트 코드는 복잡해서 디버깅하기가 어렵다. <strong>디버깅하기 쉽도록 해결책을 내놓은 것이 소스맵이다.</strong> 소스맵은 변환된 코드의 위치와 심벌들을 원본 코드의 원래 위치와 심벌들로 매핑한다. 보통 자바스크립트로 변환된 코드는 원본 코드와 거의 비슷해서 디버깅하기 쉽지만 복잡하게 변환된다면 소스맵이 필요하다. 타입스크립트가 소스맵을 생성할 수 있도록 tsconfig.json에 소스맵 옵션을 다음과 같이 설정한다.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compiletOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"sourceMap"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-58-모던-자바스크립트로-작성하기"><a href="#아이템-58-모던-자바스크립트로-작성하기" class="headerlink" title="아이템 58 모던 자바스크립트로 작성하기"></a>아이템 58 모던 자바스크립트로 작성하기</h2><p>타입스크립트 코드를 특정 버전의 자바스크립트로 컴파일 할 수 있다. 즉 타입스크립트를 자바스크립트 트랜스 파일러로 사용할 수 있다. 옛날 버전의 자바스크립트 코드를 타입스크립트 컴파일러에서 동작하게 만들면 그 이후 회신 버전의 자바스크립트 기능을 코드에 추가해도 문제가 없다. 이렇게 옛날 버전의 자바스크립트 코드를 최신 버전의 자바스크립트로 바꾸는 작업이 타입스크립트로 전환하는 작업의 일부라 볼 수 있다. <em>타입스크립트는 자바스크립트의 상위 집합이기 때문에 코드를 최신 버전으로 바꾸다 보면 타입스크립트의 일부를 저절로 익힐 수 있다.</em> 타입스크립트 도입 시 가장 중요하나 기능은 ECMAScript 모듈과 ES2015 클래스이다.</p>
<h3 id="ECMA-모듈-사용하기"><a href="#ECMA-모듈-사용하기" class="headerlink" title="ECMA 모듈 사용하기"></a>ECMA 모듈 사용하기</h3><p>ES2015부터 import, export를 사용하는 ECMAScript 모듈이 표준이 되었다. 따라서 자바스크립트 코드가 단일 파일이거나 비표준 모듈 시스템을 사용 중이라면 ES 모듈로 전환해야 한다. 이 과정에서 웹팩이나 ts-node와 같은 도구가 필요할 수도 있다. ES 모듈 시스템은 모듈 단위로 전환할 수 있게 해주기 때문에 점진적 마이그레이션이 원활해진다.</p>
<h3 id="프로토타입-대신-클래스-사용하기"><a href="#프로토타입-대신-클래스-사용하기" class="headerlink" title="프로토타입 대신 클래스 사용하기"></a>프로토타입 대신 클래스 사용하기</h3><p>자바스크립트에서 프로토타입 기반의 객체 모델을 사용하는데, 많은 개발자들이 클래스 기반 모델을 선호했기 때문에 ES2015에서 class 키워드를 사용하는 클래스 기반 모델이 도입되었다. <em>만약 단순한 객체를 다룰 때 프로토타입을 사용하고 있었다면 클래스로 바꾸는 것이 좋다.</em></p>
<h3 id="var-대신-let-const-사용하기"><a href="#var-대신-let-const-사용하기" class="headerlink" title="var 대신 let/const 사용하기"></a>var 대신 let/const 사용하기</h3><p>var 키워드에는 스코프 규칙의 문제가 있었고, let이나 const를 쓰는 것으로 이러한 문제를 피할 수 있었다. var로 되어있던 코드를 let이나 const로 수정하면 일부 코드에서 타입스크립트가 오류를 표시할 수 있다. 만약 오류가 발생했다면 잠재적으로 스코프 문제가 존재하는 코드이니 수정이 필요하다.</p>
<h3 id="for-대신-for-of-또는-배열-메서드-사용하기"><a href="#for-대신-for-of-또는-배열-메서드-사용하기" class="headerlink" title="for(;;) 대신 for-of 또는 배열 메서드 사용하기"></a>for(;;) 대신 for-of 또는 배열 메서드 사용하기</h3><p>과거에는 자바스크립트가 배열을 순회할 때 for 루프를 사용했는데 모던 자바스크립트에는 <code>for~of</code>가 존재하기 때문에 이를 사용하면 된다. for~of가 for문에 비해 코드가 짧고 인덱스 변수를 사용하지 않기 때문에 실수를 줄일 수 있다. 만약 인덱스 변수가 필요하다면 forEach를 사용하면 되고, 비슷한 루프문으로 for~in도 있지만 몇 가지 문제점이 있으므로 쓰지 않는 것이 좋다.</p>
<h3 id="함수-표현식보다-화살표-함수-사용하기"><a href="#함수-표현식보다-화살표-함수-사용하기" class="headerlink" title="함수 표현식보다 화살표 함수 사용하기"></a>함수 표현식보다 화살표 함수 사용하기</h3><p>this 키워드는 일반 변수들과 다른 스코프 규칙을 가지기 때문에 가장 어려운 개념 중 하나이다. 그러나 화살표 함수를 사용하면 상위 스코프의 this를 유지할 수 있다. 컴파일러 옵션에 noImplicitThis(또는 strict)를 설정하면 타입스크립트가 this 바인딩 관련된 오류를 표시해준다.</p>
<h3 id="단축-객체-표현과-구조-분해-할당-사용하기"><a href="#단축-객체-표현과-구조-분해-할당-사용하기" class="headerlink" title="단축 객체 표현과 구조 분해 할당 사용하기"></a>단축 객체 표현과 구조 분해 할당 사용하기</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>,</span><br><span class="line">  y = <span class="number">2</span>,</span><br><span class="line">  z = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123;</span><br><span class="line">  x: x,</span><br><span class="line">  y: y,</span><br><span class="line">  z: z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같은 코드는 아래와 같이 구조 분해 할당을 이용하여 더 간단하게 표현할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>,</span><br><span class="line">  y = <span class="number">2</span>,</span><br><span class="line">  z = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123; x, y, z &#125;</span><br></pre></td></tr></table></figure>
<h3 id="함수-매개변수-기본값-사용하기"><a href="#함수-매개변수-기본값-사용하기" class="headerlink" title="함수 매개변수 기본값 사용하기"></a>함수 매개변수 기본값 사용하기</h3><p>자바스크립트의 함수의 모든 매개변수는 선택적(생략 가능)이며, 매개변수를 지정하지 않았을 때는 undefined로 간주된다. 매개변수에 기본값을 직접 지정할 수도 있는데 이렇게 하면 코드가 간결해진다.</p>
<h3 id="저수준-프로미스나-콜백-대신-async-await-사용하기"><a href="#저수준-프로미스나-콜백-대신-async-await-사용하기" class="headerlink" title="저수준 프로미스나 콜백 대신 async/await 사용하기"></a>저수준 프로미스나 콜백 대신 async/await 사용하기</h3><p>async/await가 코드의 가독성을 높이는 것 뿐 아니라 비동기 코드에 타입 정보가 전달되어 타입 추론을 가능하게 한다.</p>
<h3 id="연관-배열에-객체-대신-Map과-Set-사용하기"><a href="#연관-배열에-객체-대신-Map과-Set-사용하기" class="headerlink" title="연관 배열에 객체 대신 Map과 Set 사용하기"></a>연관 배열에 객체 대신 Map과 Set 사용하기</h3><h3 id="타입스크립트에-use-strict-넣지-않기"><a href="#타입스크립트에-use-strict-넣지-않기" class="headerlink" title="타입스크립트에 use strict 넣지 않기"></a>타입스크립트에 use strict 넣지 않기</h3><p>버그가 될 수 있는 코드 패턴에 오류를 표시해 주는 엄격 모드가 ES5에서 도입되었는데 타입스크립트에서 수행되는 안정성 검사가 엄격 모드보다 훨싼 더 엄격한 체크를 수행한다.</p>
<hr>
<h2 id="아이템-59-타입스크립트-도입-전에-ts-check와-JSDoc으로-시험해-보기"><a href="#아이템-59-타입스크립트-도입-전에-ts-check와-JSDoc으로-시험해-보기" class="headerlink" title="아이템 59 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기"></a>아이템 59 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기</h2><p>@ts-check 지시자를 써서 타입 체커가 파일을 분석하고, 발견된 오류를 보고하도록 지시할 수 있다. 단 매우 느슨한 수준으로 타입 체크를 수행하고, noImplicitAny를 해제한 것보다 헐거운 체크를 수행한다. <em>JSDoc의 @types 구문을 사용해서 타입 단언을 대체할 수 있는데 이때 중요한 것은 타입을 감싸는 중괄호가 필요하다는 것이다.</em> 이처럼 자바스크립트 환경에서도 @ts-check 지시자와 JSDoc 주석으로 타입스크립트와 비슷한 경험의 작업이 가능하다.</p>
<h2 id="아이템-60-allowJs로-타입스크립트와-자바스크립트-같이-사용하기"><a href="#아이템-60-allowJs로-타입스크립트와-자바스크립트-같이-사용하기" class="headerlink" title="아이템 60 allowJs로 타입스크립트와 자바스크립트 같이 사용하기"></a>아이템 60 allowJs로 타입스크립트와 자바스크립트 같이 사용하기</h2><p>마이그레이션 기간 중에 자바스크립트와 타입스크립트가 동시에 동작할 수 있도록 해야 한다. 이 두 가지가 공존할 수 있도록 하는 핵심은 <code>allowJs</code>컴파일러 옵션이다. 타입스크립트 파일과 자바스크립트 파일을 서로 임포트할 수 있게 해준다. 타입 체크와 관련이 없지만 기존 빌드 과정에 타입스크립트 컴파일러를 추가하기 위해서도 allowJs 옵션이 필요하고, 모듈 단위로 타입스크립트로 전환하는 과정에서 테스트를 수행해야 하기 때문에도 이 옵션이 필요하다.</p>
<hr>
<h2 id="아이템-61-의존성-관계에-따라-모듈-단위로-전환하기"><a href="#아이템-61-의존성-관계에-따라-모듈-단위로-전환하기" class="headerlink" title="아이템 61 의존성 관계에 따라 모듈 단위로 전환하기"></a>아이템 61 의존성 관계에 따라 모듈 단위로 전환하기</h2><p>점진적 마이그레이션에서는 모듈 단위로 각개격파하는 것이 이상적인데, 한 모듈을 골라서 타입 정보를 추가하면 <em>해당 모듈이 의존하는 모듈에서 비롯되는 타입 오류</em>가 발생하게 된다. 따라서 다른 모듈에 의존하지 않는 최하단 모듈부터 시작하여 의존성의 최상단에 있는 모듈을 마지막으로 완성해야 한다.</p>
<ul>
<li>서드파티 라이브러리 타입 정보를 가장 먼저 해결한다.</li>
</ul>
<p>프로젝트 내에 존재하는 모듈은 서드파티 라이브러리에 의존하지만 서드파티 라이브러리는 해당 모듈에 의존하지 않기 때문에 가장 먼저 타입 정보를 해결해야 한다. <code>@types</code>모듈을 설치하면 된다. (e.g. @types/lodash)</p>
<ul>
<li>외부 API의 타입 정보 추가</li>
</ul>
<p>프로젝트 내의 모듈은 API에 의존하지만 API는 해당 모듈에 의존하지 않기 때문에 먼저 해결한다. 단 특별한 문맥이 없어서 타입스크립트가 추론하기 어렵기 때문에 <strong>API에 대한 사양을 기반으로 타입 정보를 생성하도록 한다.</strong></p>
<ul>
<li><p>의존성 관계도에서 가장 의존성이 낮은 모듈부터 타입 정보 추가<br>대부분의 프로젝트 최하단에 유틸리티 종류의 모듈이 위치하는 패턴이 있다. <strong>이때 중요한 것은 타입정보를 추가한 것이지 리팩토링을 하려 해서는 안된다.</strong></p>
</li>
<li><p>선언되지 않은 클래스 멤버</p>
</li>
</ul>
<p>자바스크립트에서 클래스 멤버 변수를 선언할 필요가 없지만 타입스크립트에서는 명시적으로 선언해야 한다.</p>
<ul>
<li>타입이 바뀌는 값</li>
</ul>
<p>자바스크립트일 때 문제가 없다가 타입스크립트가 되는 순간 오류가 발생하는 값들이 많은데, 한꺼번에 객체를 생성하여 간단히 오류를 해결할 수 있다. 한꺼번에 생성이 어렵다면 타입 단언문을 사용할 수 있다. <em>단, 당장 마이그레이션이 최우선이라 임시 방편으로 사용한 것이지 마이그레이션이 완료된 후에는 적절한 방법으로 타입을 선언해야 한다.</em> 또한 자바스크립트에서 JSDoc와 @ts-check를 사용해서 타입 정보를 추가했다면 타입스크립트로 전환하는 순간 타입 정보가 무효화 된다는 것에 유의하도록 한다.</p>
<ul>
<li>테스트 코드를 타입스크립트로 전환<br>로직 코드가 테스트 코드에 의존하지 않기 때문에, 테스트 코드는 항상 의존성 관계도의 최상단에 위치한다. 따라서 최하단의 모듈부터 마이그레이션 하는 중에도 테스트는 정상적으로 수행할 수 있다.</li>
</ul>
<hr>
<h2 id="아이템-62-마이그레이션의-완성을-위해-noImplicitAny-설정하기"><a href="#아이템-62-마이그레이션의-완성을-위해-noImplicitAny-설정하기" class="headerlink" title="아이템 62 마이그레이션의 완성을 위해 noImplicitAny 설정하기"></a>아이템 62 마이그레이션의 완성을 위해 noImplicitAny 설정하기</h2><p>만약 noImplicitAny를 설정하지 않았다면 타입 선언에서 비롯되는 실제 오류를 완벽하게 잡을 수 없으므로 마이그레이션이 완료되었다고 말하기 어렵다. 아래와 같은 코드는 <code>noImplicitAny:true</code>를 설정한 순간 에러가 발생하게 된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsConfig: &#123;"noImplicitAny":true,"strictNullChecks":false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HIDE</span></span><br><span class="line"><span class="keyword">class</span> Chart &#123;</span><br><span class="line">  indices: <span class="built_in">number</span>[]</span><br><span class="line">  <span class="comment">// END</span></span><br><span class="line">  getRanges() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> r of <span class="keyword">this</span>.indices) &#123;</span><br><span class="line">      <span class="keyword">const</span> low = r[<span class="number">0</span>]</span><br><span class="line">      <span class="comment">// ~~~~ Element implicitly has an 'any' type because</span></span><br><span class="line">      <span class="comment">//      type 'Number' has no index signature</span></span><br><span class="line">      <span class="keyword">const</span> high = r[<span class="number">1</span>]</span><br><span class="line">      <span class="comment">// ~~~~ Element implicitly has an 'any' type because</span></span><br><span class="line">      <span class="comment">//      type 'Number' has no index signature</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// HIDE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// END</span></span><br></pre></td></tr></table></figure>
<p>noImplicitAny를 설정할 때는 로컬에만 설정하고 작업을 하여 점진적 마이그레이션이 가능하도록 한다.</p>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/22/220223_item49to55/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/22/220223_item49to55/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 49 - 아이템 55</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-23 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-23T00:00:00+09:00">2022-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 13:09:35" itemprop="dateModified" datetime="2022-05-18T13:09:35+09:00">2022-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-49-콜백에서-this에-대한-타입-제공하기"><a href="#아이템-49-콜백에서-this에-대한-타입-제공하기" class="headerlink" title="아이템 49 콜백에서 this에 대한 타입 제공하기"></a>아이템 49 콜백에서 this에 대한 타입 제공하기</h2><p>this는 let,const와 달리 dynamic scope이기 때문에 정의된 방식이 아닌 <code>호출된 방식</code>에 따라 값이 달라진다. 아래 코드는 현재의 객체 인스턴스를 참조하는 <code>클래스</code>에서 많이 쓰이는 this이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">  vals = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  logSquares() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> val of <span class="keyword">this</span>.vals) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val * val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> C()</span><br><span class="line"><span class="keyword">const</span> method = c.logSquares</span><br><span class="line">method()</span><br></pre></td></tr></table></figure>
<p>이 코드는 런타임에 <em>uncaught TypeError: undefined의 ‘vals’속성을 읽을 수 없습니다.</em>는 오류를 발생시킨다. 그 이유는 <code>c.logSquares</code>가 <code>C.prototype.logSquares</code>를 호출하고, <code>this 값을 c로 바인딩</code>하는 두 가지 작업을 수행하기 때문이다. 이 작업에 따르면 this의 값은 undefined로 설정된다. 이런 문제를 해결하는 첫 번째 방법은 <code>call</code>을 사용해서 명시적으로 this를 바인딩하는 것이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> C()</span><br><span class="line"><span class="keyword">const</span> method = c.logSquares</span><br><span class="line">method.call(c) <span class="comment">// 제곱 출력</span></span><br></pre></td></tr></table></figure>
<p>이처럼 명시적인 <code>this 바인딩</code>을 통해 this의 타입에 대해 구체화할 수 있다. this 바인딩은 어떤 것에도 가능하며, 콜백 함수에도 쓰일 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">makeButton</span>(<span class="params">props: &#123; text: <span class="built_in">string</span>; onClick: () =&gt; <span class="built_in">void</span> &#125;</span>): <span class="title">void</span></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">ResetButton</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> makeButton(&#123; text: <span class="string">'Reset'</span>, onClick: <span class="keyword">this</span>.onClick &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  onClick() &#123;</span><br><span class="line">    alert(<span class="string">`Reset <span class="subst">$&#123;<span class="keyword">this</span>&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그런데 여기서도 this 바인딩 문제로 인해 <em>Reset이 정의되지 않았다는 에러가 발생한다.</em> 이때 해결하는 방법은 아래와 같이 <code>생성자에서 메서드에 this를 바인딩시키는 것이다.</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">makeButton</span>(<span class="params">props: &#123; text: <span class="built_in">string</span>; onClick: () =&gt; <span class="built_in">void</span> &#125;</span>): <span class="title">void</span></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">ResetButton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onClick = <span class="keyword">this</span>.onClick.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> makeButton(&#123; text: <span class="string">'Reset'</span>, onClick: <span class="keyword">this</span>.onClick &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  onClick() &#123;</span><br><span class="line">    alert(<span class="string">`Reset <span class="subst">$&#123;<span class="keyword">this</span>&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onClick()은 ResetButton.proptotype의 속성을 정의한다. 따라서 ResetButton의 모든 인스턴스에 공유된다. 그런데 위와 같이 생성자 함수에 바인딩하게 되면 onClick 속성에 this가 바인딩되어 해당 인스턴스에 생성된다. onClick 인스턴스 속성은 프로토타입 속성보다 앞에 놓이므로 <code>render() 메서드의 this.onClick은 바인딩된 함수를 참조하게 된다.</code> 하지만 onClick을 화살표 함수로 바꾸는 방법으로 좀 더 간단하게 해결할 수도 있다. 그 이유는 화살표 함수 내부에서 this를 참조하면 상위 컨텍스트의 this를 그대로 참조하기 때문이다. 따라서 ResetButton이 생성될 때 마다 제대로 바인딩된 this를 가지는 새 함수를 생성한다.</p>
<hr>
<h2 id="아이템-50-오버로딩-타입보다는-조건부-타입을-사용하기"><a href="#아이템-50-오버로딩-타입보다는-조건부-타입을-사용하기" class="headerlink" title="아이템 50 오버로딩 타입보다는 조건부 타입을 사용하기"></a>아이템 50 오버로딩 타입보다는 조건부 타입을 사용하기</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">any</span></span>) </span>&#123;</span></span><br><span class="line"><span class="function">  <span class="title">return</span> <span class="title">x</span> + <span class="title">x</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span></span><br><span class="line"><span class="function">  <span class="title">return</span> <span class="title">x</span> + <span class="title">x</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>함수 오버로딩(동일한 이름에 매개변수만 다른 여러 버전의 함수를 허용하는 것.단, 타입 수준에서 동작)의 개념을 통해 위와 같이 함수의 타입 정보를 추가한다. 그런데 이렇게 작성하면 선언문에서 number타입을 매개변수로 넣고, string타입을 반환하는 경우도 포함되어 있어서 모호한 지점이 생긴다. 이런 상황에서 <code>첫 번째 해결법은 제너릭을 사용하는 것</code>이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">number</span> | <span class="title">string</span>&gt;(<span class="params">x: T</span>): <span class="title">T</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">any</span></span>) </span>&#123;</span></span><br><span class="line"><span class="function">  <span class="title">return</span> <span class="title">x</span> + <span class="title">x</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">num</span> = <span class="title">double</span>(<span class="params">12</span>) // <span class="title">Type</span> <span class="title">is</span> 12</span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">str</span> = <span class="title">double</span>(<span class="params">'x'</span>) // <span class="title">Type</span> <span class="title">is</span> "<span class="title">x</span>"</span></span><br></pre></td></tr></table></figure>
<p>제너릭 타입을 쓰면서 앞서 말했던 number로 선언되어 string 타입을 반환하는 경우에 대해서 해결은 되었으나 지나치게 구체적인 타입이 되었다. string을 넣으면 string만 반환해야 하게 되었다. 좀 더 다른 방법으로 <code>여러 가지 타입 선언으로 분리</code>해 볼 수 있다. 함수의 구현체는 하나여도 타입 선언은 여러 개 만들 수 있기 때문에 함수 타입을 보다 명확하게 할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">any</span></span>) </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">return</span> <span class="title">x</span> + <span class="title">x</span></span></span></span><br><span class="line"><span class="function"><span class="function">&#125;</span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="title">const</span> <span class="title">num</span> = <span class="title">double</span>(<span class="params">12</span>) // <span class="title">Type</span> <span class="title">is</span> <span class="title">number</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="title">const</span> <span class="title">str</span> = <span class="title">double</span>(<span class="params">'x'</span>) // <span class="title">Type</span> <span class="title">is</span> <span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">return</span> <span class="title">double</span>(<span class="params">x</span>)</span></span></span><br><span class="line"><span class="function"><span class="function">  // ~ <span class="title">Argument</span> <span class="title">of</span> <span class="title">type</span> '<span class="title">string</span> | <span class="title">number</span>' <span class="title">is</span> <span class="title">not</span> <span class="title">assignable</span></span></span></span><br><span class="line"><span class="function"><span class="function">  //   <span class="title">to</span> <span class="title">parameter</span> <span class="title">of</span> <span class="title">type</span> '<span class="title">string</span>'</span></span></span><br><span class="line"><span class="function"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>단 유니온 타입에 대해서는 문제가 발생한다. <strong>타입스크립트는 오버로딩 타입 중에서 일치하는 타입을 찾을 때까지 순차적으로 검색한다.</strong> 마지막 선언인 string까지 검색했을 때 string | number 타입은 string에 할당할 수 없기 때문에 에러가 발생하는 것이다. 이때는 <code>오버로딩 타입으로 string|number를 추가</code>하여 문제를 해결할 수 있고, 더 좋은 방법은 아래와 같이 <code>조건부 타입</code>을 사용하는 것이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">number</span> | <span class="title">string</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  x: T</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">T</span> <span class="title">extends</span> <span class="title">string</span> ? <span class="title">string</span> : <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x: <span class="built_in">any</span></span>) </span>&#123;</span></span><br><span class="line"><span class="function">  <span class="title">return</span> <span class="title">x</span> + <span class="title">x</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>조건부 타입을 사용하면 아래와 같이 반환 타입이 정교해진다.</p>
<ul>
<li>T가 string의 부분 집합이면 반환 타입이 string이다.</li>
<li>그 외의 경우는 반환 타입이 number이다.</li>
</ul>
<p>이처럼 조건부 타입은 개별 타입의 유니온으로 일반화하기 때문에 타입이 더욱 정확해진다. 조건부 타입은 타입 체커가 단일 표현식으로 받아들이기 때문에 타입 오버로딩에서 유니온 문제가 발생했을 때 문제를 해결할 수 있다.</p>
<hr>
<h2 id="아이템-51-의존성-분리를-위해-미러-타입-사용하기"><a href="#아이템-51-의존성-분리를-위해-미러-타입-사용하기" class="headerlink" title="아이템 51 의존성 분리를 위해 미러 타입 사용하기"></a>아이템 51 의존성 분리를 위해 미러 타입 사용하기</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseCSV</span>(<span class="params">contents: <span class="built_in">string</span> | Buffer</span>): </span>&#123; [column: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125;[] &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> contents === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="comment">// It's a buffer</span></span><br><span class="line">    <span class="keyword">return</span> parseCSV(contents.toString(<span class="string">'utf8'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// COMPRESS</span></span><br><span class="line">  <span class="keyword">return</span> []</span><br><span class="line">  <span class="comment">// END</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>다음 코드는 NodeJs 사용자를 위해 매개변수에 Buffer 타입을 허용한 예시이다. 그리고 Buffer의 타입 정의는 npm install —save-dev @types/node로 설치하여 얻을 수 있다. 단 타입 선언이 @types/node에 의존하기 때문에 devDependencies로 포함해야 하는데 이를 포함하면 <em>@types와 무관한 자바스크립트 개발자 또는 NodeJS와 무관한 타입스크립트 웹 개발자</em>에게 혼란을 줄 수 있다. 그 이유는 두 그룹 사용자가 사용하지 않는 모듈이 포함되어 있기 때문이다. Buffer는 NodeJS 개발자에게만 필요하다. 따라서 Buffer를 사용하는 대신 아래와 같이 필요한 메서드와 속성만 별도로 작성하는 방식으로 개선할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CsvBuffer &#123;</span><br><span class="line">  toString(encoding: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseCSV</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  contents: <span class="built_in">string</span> | CsvBuffer</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): </span>&#123; [column: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125;[] &#123;</span><br><span class="line">  <span class="comment">// COMPRESS</span></span><br><span class="line">  <span class="keyword">return</span> []</span><br><span class="line">  <span class="comment">// END</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>만약 작성 중인 라이브러리가 의존하는 라이브러리의 구현과 무관하게 타입에만 의존한다면, 필요한 선언부만 추출해서 작성 중인 라이브러리에 넣는 미러링을 고려해 볼 수 있다.</strong></p>
<hr>
<h2 id="아이템-52-테스팅-타입의-함정에-주의하기"><a href="#아이템-52-테스팅-타입의-함정에-주의하기" class="headerlink" title="아이템 52 테스팅 타입의 함정에 주의하기"></a>아이템 52 테스팅 타입의 함정에 주의하기</h2><p>타입 선언도 테스트를 거쳐야 하고, dtslint 또는 타입 시스템 외부의 타입을 검사하는 도구를 사용할 수 있다. 타입 선언이 예상한 타입으로 결과를 내는지 체크할 수 있는 한 가지 방법은 <code>함수를 호출하는 테스트 파일의 작성</code>이다. 그러나 단순히 함수를 실행만 하는 테스트 코드를 작성하는 것보다는 <code>반환 타입을 체크하는 것이 중요하다.</code> 반환값을 특정 타입의 변수에 할당하여 간단히 반환 타입을 체크할 수 있는 방법은 다음과 같다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lengths: <span class="built_in">number</span>[] = map([<span class="string">'john'</span>, <span class="string">'paul'</span>], <span class="function"><span class="params">name</span> =&gt;</span> name.length)</span><br></pre></td></tr></table></figure>
<p>이 코드는 불필요한 타입 선언에 해당하지만 테스트 관점에서는 매우 중요하다. 그런데 테스팅을 위해서 할당하는 방법에는 두 가지 문제가 있다.</p>
<ul>
<li><p>불필요한 변수를 만들어야 하고, 일부 린팅 규칙을 비활성화해야한다.</p>
<ul>
<li><strong>변수를 도입하는 대신 헬퍼 함수를 정의하는 것으로 해결한다.</strong></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertType</span>&lt;<span class="title">T</span>&gt;(<span class="params">x: T</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">assertType&lt;<span class="built_in">number</span>[]&gt;(map([<span class="string">'john'</span>, <span class="string">'paul'</span>], <span class="function"><span class="params">name</span> =&gt;</span> name.length))</span><br></pre></td></tr></table></figure>
</li>
<li><p>두 타입이 동일한지에 대한 체크 대신 <strong>할당 가능성을 체크한다.</strong></p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">12</span></span><br><span class="line">assertType&lt;<span class="built_in">number</span>&gt;(n) <span class="comment">//정상</span></span><br></pre></td></tr></table></figure>
<p>n 심벌은 타입이 숫자 리터럴 12인데, 12는 number의 서브타입이라서 할당 가능성 체크를 통과한다. 그러나 객체 타입 체크해서 문제가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> beatles = [<span class="string">'john'</span>, <span class="string">'paul'</span>, <span class="string">'george'</span>, <span class="string">'ringo'</span>]</span><br><span class="line">assertType&lt;&#123; name: <span class="built_in">string</span> &#125;[]&gt;(</span><br><span class="line">  map(beatles, <span class="function"><span class="params">name</span> =&gt;</span> (&#123;</span><br><span class="line">    name,</span><br><span class="line">    inYellowSubmarine: name === <span class="string">'ringo'</span></span><br><span class="line">  &#125;))</span><br><span class="line">) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>map은 {name: string, inYellowSubmarine: boolean}객체의 배열을 반환하는데, 반환된 배열은 {name: string}[]에 할당 가능하지만 inYellowSubmarine 속성에 대해 체크되지 않는다.</p>
<h3 id="assertType-사용-방법"><a href="#assertType-사용-방법" class="headerlink" title="assertType 사용 방법"></a>assertType 사용 방법</h3><p>아래 예제처럼 parameters와 ReturnType 제너릭 타입을 이용해서 함수의 매개변수 타입과 반환 타입만 분리하여 테스트한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">2</span> * x</span><br><span class="line"><span class="keyword">let</span> p: Parameters&lt;<span class="keyword">typeof</span> double&gt; = <span class="literal">null</span>!</span><br><span class="line">assertType&lt;[<span class="built_in">number</span>, <span class="built_in">number</span>]&gt;(p)</span><br><span class="line"><span class="comment">//                           ~ Argument of type '[number]' is not</span></span><br><span class="line"><span class="comment">//                             assignable to parameter of type [number, number]</span></span><br><span class="line"><span class="keyword">let</span> r: ReturnType&lt;<span class="keyword">typeof</span> double&gt; = <span class="literal">null</span>!</span><br><span class="line">assertType&lt;<span class="built_in">number</span>&gt;(r) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-53-타입스크립트-기능보다는-ECMAScript-기능을-사용하기"><a href="#아이템-53-타입스크립트-기능보다는-ECMAScript-기능을-사용하기" class="headerlink" title="아이템 53 타입스크립트 기능보다는 ECMAScript 기능을 사용하기"></a>아이템 53 타입스크립트 기능보다는 ECMAScript 기능을 사용하기</h2><p>타입스크립트 초기 버전에는 자바스크립트가 가진 결함들도 수용해야 했기 때문에 독립적으로 개발한 클래스, 열거형, 모듈 시스템을 포함시켰다. 시간이 흐르면서 부족했던 부분들을 내장 기능으로 추가하게 되었는데 <em>자바스크립트에 새로 추가된 기능은 타입스크립트 초기 버전에서 독립적으로 개발했던 기능과 호환성 문제를 발생시킨다.</em> 그래서 타입스크립트는 <strong>자바스크립트의 신규 기능을 그대로 채택하고 타입스크립트 초기 버전</strong>과 호환성을 포기하는 방법을 택했다. 그런데 이 기능과 타입스크립트 팀은 타입만 발전시킨다는 원칙이 세워지기 이전에 이미 사용되던 몇 가지 기능들이 있고, 이런 것들이 타입 공간(타입스크립트), 값 공간(자바스크립트)의 경계를 혼란스럽게 하기 때문에 사용을 지양해야 한다.</p>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/20/220221_item42to48/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/20/220221_item42to48/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 42 - 아이템 48</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-21 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-21T00:00:00+09:00">2022-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 13:09:35" itemprop="dateModified" datetime="2022-05-18T13:09:35+09:00">2022-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-42-모르는-타입의-값에는-any-대신-unknown을-사용하기"><a href="#아이템-42-모르는-타입의-값에는-any-대신-unknown을-사용하기" class="headerlink" title="아이템 42 모르는 타입의 값에는 any 대신 unknown을 사용하기"></a>아이템 42 모르는 타입의 값에는 any 대신 unknown을 사용하기</h2><h3 id="any의-특성"><a href="#any의-특성" class="headerlink" title="any의 특성"></a>any의 특성</h3><ul>
<li>어떠한 타입이든 any 타입에 할당 가능하다.</li>
<li>any 타입은 never를 제외한 어떠한 타입으로도 할당 가능하다.</li>
</ul>
<p>이러한 any의 특성은 집합 기반의 타입시스템과 상충된다. 따라서 any를 쓰면 타입 체커가 무용지물이 된다. 마치 any와 같은 역할을 하면서 타입시스템에 부합하는 타입이 바로 <code>unknown</code>이다.</p>
<h3 id="unknown의-특성"><a href="#unknown의-특성" class="headerlink" title="unknown의 특성"></a>unknown의 특성</h3><ul>
<li>어떠한 타입도 unknown에 할당 가능하다.</li>
<li>오직 unknown과 any에만 할당 가능하다.</li>
</ul>
<h3 id="never의-특성"><a href="#never의-특성" class="headerlink" title="never의 특성"></a>never의 특성</h3><ul>
<li>어떤 타입도 never에 할당 할 수 없다.</li>
<li>어떠한 타입으로도 할당 가능하다.</li>
</ul>
<hr>
<h3 id="1-unknown의-함수의-반환값과-관련된-형태"><a href="#1-unknown의-함수의-반환값과-관련된-형태" class="headerlink" title="1. unknown의 함수의 반환값과 관련된 형태"></a>1. unknown의 함수의 반환값과 관련된 형태</h3><p><em>함수의 반환타입으로 any를 쓰는 것은 좋지 않기 때문에</em> 그보다는 함수를 호출한 곳에서 반환값을 원하는 타입으로 할당하는 것이 바람직하다. 그러나 함수의 반환값에 타입 선언을 강제할 수 없기 때문에 호출한 곳에서 타입 선언을 생략하면 아래 예제를 예시로 들었을 때 1️⃣, 2️⃣처럼 book 변수가 암시적 any타입이 되고, 사용되는 곳마다 타입 오류가 발생한다. 이런 경우에 any 대신 unknown을 쓰면 훨씬 안전하다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseYAML</span>(<span class="params">yaml: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Book &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  author: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeParseYAML</span>(<span class="params">yaml: <span class="built_in">string</span></span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parseYAML(yaml)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> book = safeParseYAML(<span class="string">`</span></span><br><span class="line"><span class="string">  name: The Tenant of Wildfell Hall</span></span><br><span class="line"><span class="string">  author: Anne Brontë</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">alert(book.title)</span><br><span class="line"><span class="comment">// 1️⃣ - No error, alerts "undefined" at runtime</span></span><br><span class="line"><span class="comment">// ~~~~ Object is of type 'unknown'</span></span><br><span class="line">book(<span class="string">'read'</span>)</span><br><span class="line"><span class="comment">// No error, throws "TypeError: book is not a</span></span><br><span class="line"><span class="comment">// 2️⃣ - function" at runtime</span></span><br><span class="line"><span class="comment">// ~~~~~~~~~~ Object is of type 'unknown'</span></span><br></pre></td></tr></table></figure>
<p>하지만 unknown인 타입의 값을 사용하려고 하거나 함수 호출 또는 연산을 진행할 때 오류가 발생하기 때문에 적절한 타입으로 변환하도록 강제할 수 있다.</p>
<h3 id="2-변수선언과-관련된-unknown"><a href="#2-변수선언과-관련된-unknown" class="headerlink" title="2. 변수선언과 관련된 unknown"></a>2. 변수선언과 관련된 unknown</h3><p>어떠한 값이 있지만 그 타입을 모르는 경우에 사용한다.</p>
<hr>
<h2 id="아이템-43-몽키-패치보다는-안전한-타입을-사용하기"><a href="#아이템-43-몽키-패치보다는-안전한-타입을-사용하기" class="headerlink" title="아이템 43 몽키 패치보다는 안전한 타입을 사용하기"></a>아이템 43 몽키 패치보다는 안전한 타입을 사용하기</h2><p>몽키 패치는 프로그램이 런타임 되는 동안 사용되는 모듈이나 클래스를 변경하는 것이다. 자바스크립트는 객체와 클래스에 임의의 속성을 추가할 수 있을 만큼 유연하기 때문에 이 성질을 이용해서 전역 변수를 만들 수도 있다. 예를 들어 window나 document에 값을 할당해서 전역 변수를 만드는 것이다. 그런데 window 또는 DOM 노드에 데이터를 추가하면 그 데이터는 기본적으로 전역 변수기 때문에 프로그랢 내에서 의존성을 만들고, 사이드 이펙트를 만들 수 있다. 그리고 타입스크립트의 타입 체커는 아래와 같이 임의로 추가한 속성에 대해서 알지 못한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.monkey = <span class="string">'Tamarin'</span></span><br><span class="line"><span class="comment">// ~~~~~~ Property 'monkey' does not exist on type 'Document'</span></span><br></pre></td></tr></table></figure>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/15/220216_item35to41/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/15/220216_item35to41/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 35 - 아이템 41</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-16 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-16T00:00:00+09:00">2022-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 13:09:35" itemprop="dateModified" datetime="2022-05-18T13:09:35+09:00">2022-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-35-데이터가-아닌-API와-명세를-보고-타입-만들기"><a href="#아이템-35-데이터가-아닌-API와-명세를-보고-타입-만들기" class="headerlink" title="아이템 35 데이터가 아닌, API와 명세를 보고 타입 만들기"></a>아이템 35 데이터가 아닌, API와 명세를 보고 타입 만들기</h2><p>파일 형식, API, 명세 등 우리가 다루는 타입 중 최소한 몇 개는 프로젝트 외부에서 비롯된 것이다. <em>이런 경우 자동으로 타입 생성이 가능하다.</em> 단 중요한 포인트는 예시 데이터가 아니라 <code>명세</code>를 참고해서 타입을 생성한다는 것이다. 명세를 참고하지 않고 예시 데이터를 참고해서 타입을 작성하게 되면 눈앞에 있는 데이터만 고려하게 되므로 오류 발생을 야기하기 쉽다. 그래서 명세가 존재한다면 아래 예시처럼 이미 존재하는 타입스크립트 타입 선언을 명시해서 사용할 수 있다. 다만 이미 존재하는 타입 선언을 import해서 쓰더라도 GeometryCollection에 coordinates의 속성이 없다면 에러가 발생할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requires node modules: @types/geojson</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BoundingBox &#123;</span><br><span class="line">  lat: [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line">  lng: [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> &#123; Feature, Geometry &#125; <span class="keyword">from</span> <span class="string">'geojson'</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> f: Feature;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">coordinates: <span class="built_in">any</span>[]</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> geometryHelper = <span class="function">(<span class="params">g: Geometry</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (geometry.type === <span class="string">'GeometryCollection'</span>) &#123;</span><br><span class="line">    geometry.geometries.forEach(geometryHelper);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    helper(geometry.coordinates); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; geometry &#125; = f;</span><br><span class="line"><span class="keyword">if</span> (geometry) &#123;</span><br><span class="line">  geometryHelper(geometry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이럴 때는 아래와 같이 명시적으로 해당하는 타입을 차단하는 방법을 사용할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; geometry &#125; = f;</span><br><span class="line"><span class="keyword">if</span> (geometry) &#123;</span><br><span class="line">  <span class="keyword">if</span> (geometry.type === <span class="string">'GeometryCollection'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'GeometryCollection are not supported.'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    helper(geometry.coordinates); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>하지만 명시적 타입 차단보다는 모든 타입을 지원하되 조건을 분기하여 helper함수를 지원하는 방식으로 작성해야 한다.</p>
<hr>
<h2 id="아이템-36-해당-분야의-용어로-타입-이름-짓기"><a href="#아이템-36-해당-분야의-용어로-타입-이름-짓기" class="headerlink" title="아이템 36 해당 분야의 용어로 타입 이름 짓기"></a>아이템 36 해당 분야의 용어로 타입 이름 짓기</h2><blockquote>
<p>엄선된 타입, 속성, 변수의 이름은 의도를 명확히 하고, 코드와 타입의 추상화 수준을 높여 준다.</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 속성에 대한 정보가 모호하고,</span></span><br><span class="line"><span class="comment">// 선언된 용어로 그 의미를 파악하기 어렵다.</span></span><br><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  endangered: <span class="built_in">boolean</span>;</span><br><span class="line">  habitat: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> leopard: Animal = &#123;</span><br><span class="line">  name: <span class="string">'Snow Leopard'</span>,</span><br><span class="line">  endangered: <span class="literal">false</span>,</span><br><span class="line">  habitat: <span class="string">'tundra'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//위의 코드를 전문용어를 베이스로 하여</span></span><br><span class="line"><span class="comment">//보다 분명한 의미를 나타내도록 변경하였다.</span></span><br><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  commonName: <span class="built_in">string</span>;</span><br><span class="line">  genus: <span class="built_in">string</span>;</span><br><span class="line">  species: <span class="built_in">string</span>;</span><br><span class="line">  status: ConservationStatus;</span><br><span class="line">  climates: KoppenClimate[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ConservationStatus = <span class="string">'EX'</span> | <span class="string">'EW'</span> | <span class="string">'CR'</span> | <span class="string">'EN'</span> | <span class="string">'VU'</span> | <span class="string">'NT'</span> | <span class="string">'LC'</span>;</span><br><span class="line"><span class="keyword">type</span> KoppenClimate =</span><br><span class="line">  | <span class="string">'Af'</span></span><br><span class="line">  | <span class="string">'Am'</span></span><br><span class="line">  | <span class="string">'As'</span></span><br><span class="line">  | <span class="string">'Aw'</span></span><br><span class="line">  | <span class="string">'BSh'</span></span><br><span class="line">  | <span class="string">'BSk'</span></span><br><span class="line">  | <span class="string">'BWh'</span></span><br><span class="line">  | <span class="string">'BWk'</span></span><br><span class="line">  | <span class="string">'Cfa'</span>;</span><br><span class="line"><span class="keyword">const</span> snowLeopard: Animal = &#123;</span><br><span class="line">  commonName: <span class="string">'Snow Leopard'</span>,</span><br><span class="line">  genus: <span class="string">'Panthera'</span>,</span><br><span class="line">  species: <span class="string">'Uncia'</span>,</span><br><span class="line">  status: <span class="string">'VU'</span>, <span class="comment">// vulnerable</span></span><br><span class="line">  climates: [<span class="string">'ET'</span>, <span class="string">'EF'</span>, <span class="string">'Dfd'</span>], <span class="comment">// alpine or subalpine</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>이처럼 코드로 표현하고자 하는 모든 분야에는 <strong>주제를 설명하기 위한 전문 용어들이 존재한다.</strong> 전문 용어가 있다면 자체적으로 용어를 만들어 내기 보다 전문 용어를 사용하는 것이 좋지만 잘못 사용하여 혼란을 주지 않도록 아래의 세가지를 주의하여 정확하게 사용해야 한다.</p>
<ul>
<li>동일한 의미를 나타낼 때는 같은 용어를 사용한다.</li>
<li>data, info, thing, item, object, entity와 같이 모호하고 의미없는 이름은 붙이지 않는다.</li>
<li><strong>이름을 지을 때 포함된 내용이나 계산 방식이 아닌 데이터 자체가 무엇인지를 고려한다.</strong></li>
</ul>
<hr>
<h2 id="아이템-37-공식-명칭에는-상표를-붙이기"><a href="#아이템-37-공식-명칭에는-상표를-붙이기" class="headerlink" title="아이템 37 공식 명칭에는 상표를 붙이기"></a>아이템 37 공식 명칭에는 상표를 붙이기</h2><p>타입스크립트가 가진 <em>구조적 타이핑 특성 때문에 코드가 이상한 결과를 낼 수 있다.</em> 1️⃣은 구조적 타이핑 관점에서는 문제가 없는데, 수학적으로는 2차원 벡터를 사용해야 이치에 맞다. 만약 calculateNorm 함수가 3차원 벡터를 허용하지 않게 하려면 2️⃣의 _brand처럼 <code>공식 명칭</code>을 사용한다. <strong>공식 명칭이란 상표(_brand)를 붙이는 것이다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="keyword">interface</span> Vector2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateNorm</span>(<span class="params">p: Vector2D</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(p.x * p.x + p.y * p.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calculateNorm(&#123; x: <span class="number">3</span>, y: <span class="number">4</span> &#125;); <span class="comment">// OK, result is 5</span></span><br><span class="line"><span class="keyword">const</span> vec3D = &#123; x: <span class="number">3</span>, y: <span class="number">4</span>, z: <span class="number">1</span> &#125;;</span><br><span class="line">calculateNorm(vec3D); <span class="comment">// OK! result is also 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">interface</span> Vector2D &#123;</span><br><span class="line">  _brand: <span class="string">'2d'</span>;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vec2D</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; x, y, _brand: <span class="string">'2d'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateNorm</span>(<span class="params">p: Vector2D</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(p.x * p.x + p.y * p.y); <span class="comment">// Same as before</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calculateNorm(vec2D(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// OK, returns 5</span></span><br><span class="line"><span class="keyword">const</span> vec3D = &#123; x: <span class="number">3</span>, y: <span class="number">4</span>, z: <span class="number">1</span> &#125;;</span><br><span class="line">calculateNorm(vec3D);</span><br><span class="line"><span class="comment">// ~~~~~ Property '_brand' is missing in type...</span></span><br></pre></td></tr></table></figure>
<p>위 예시처럼 <code>공식명칭(_brand)</code>을 붙여두면 Vector2D함수가 Vector2D만 받는 것을 보장하게 된다. <em>이 기법은 타입 시스템 내에서 표현할 수 없는 수많은 속성들을 모델링하는 데 사용하기도 한다.</em> 아래와 같이 number 타입에 상표도 단위를 붙여서 사용하는 것처럼 숫자의 단위를 문서화하는데 사용할 수도 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Meters = <span class="built_in">number</span> &amp; &#123; _brand: <span class="string">'meters'</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> Seconds = <span class="built_in">number</span> &amp; &#123; _brand: <span class="string">'seconds'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> meters = <span class="function">(<span class="params">m: <span class="built_in">number</span></span>) =&gt;</span> m <span class="keyword">as</span> Meters;</span><br><span class="line"><span class="keyword">const</span> seconds = <span class="function">(<span class="params">s: <span class="built_in">number</span></span>) =&gt;</span> s <span class="keyword">as</span> Seconds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> oneKm = meters(<span class="number">1000</span>); <span class="comment">// Type is Meters</span></span><br><span class="line"><span class="keyword">const</span> oneMin = seconds(<span class="number">60</span>); <span class="comment">// Type is Seconds</span></span><br><span class="line"><span class="keyword">const</span> tenKm = oneKm * <span class="number">10</span>; <span class="comment">// Type is number</span></span><br><span class="line"><span class="keyword">const</span> v = oneKm / oneMin; <span class="comment">// Type is number</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-38-any-타입은-가능한-한-좁은-범위에서만-사용하기"><a href="#아이템-38-any-타입은-가능한-한-좁은-범위에서만-사용하기" class="headerlink" title="아이템 38 any 타입은 가능한 한 좁은 범위에서만 사용하기"></a>아이템 38 any 타입은 가능한 한 좁은 범위에서만 사용하기</h2><p>전통적으로 프로그래밍 언어들의 타입 시스템은 완전히 정적이거나 완전히 동적으로 구분되어 있다. 그러나 타입스크립트의 타입 시스템은 선택적이고 점진적이기 때문에 정적이면서도 동적인 특성을 동시에 가진다. 그래서 프로그램의 일부에만 타입스크립트를 적용할 수 있어 점진적 마이그레이션이 가능하다. 이 마이그레이션 단계에서 any 타입이 아주 중요한 역할을 하는데, any를 어떻게 현명하게 사용할 수 있을지 잘 고민해보아야 한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  foo: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Bar &#123;</span><br><span class="line">  bar: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">expressionReturningFoo</span>(<span class="params"></span>): <span class="title">Foo</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processBar</span>(<span class="params">b: Bar</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x: <span class="built_in">any</span> = expressionReturningFoo(); <span class="comment">// Don't do this</span></span><br><span class="line">  processBar(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = expressionReturningFoo();</span><br><span class="line">  processBar(x <span class="keyword">as</span> <span class="built_in">any</span>); <span class="comment">// Prefer this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 예제에서 x가 Foo와 Bar에 동시에 할당가능하다면 위와 같이 any를 사용한 두 가지 방법으로 해결할 수 있는데 1️⃣보다 2️⃣가 권장된다. 그 이유는 any 타입이 processBar 함수의 매개변수에만 사용된 표현식이라서 다른 코드에 영향을 미치지 않기 때문이다. 그래서 1️⃣의 x는 끝까지 any타입이고, 2️⃣에서 x는 Foo 타입을 유지한다. 1️⃣의 x가 끝까지 any 타입이기 때문에 아래와 같이 x를 반환하는 코드에서는 문제가 된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x: <span class="built_in">any</span> = expressionReturningFoo();</span><br><span class="line">  processBar(x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> foo = f1(); <span class="comment">// Type is any</span></span><br><span class="line">  foo.fooMethod(); <span class="comment">// This call is unchecked!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>객체에서 any를 사용할 때도 조심해야 하는데, 아래와 같이 오류를 발생하는 코드가 있다고 생각해본다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config: Config = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: &#123;</span><br><span class="line">    key: value,</span><br><span class="line">    <span class="comment">// ~~~ Property ... missing in type 'Bar' but required in type 'Foo'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>여기서 발생하는 오류를 해결하기 위해 아래의 두 가지 방법으로 any를 쓸 수 있다. 하지만 1️⃣처럼 사용하면 다른 속성들인 a,b의 타입도 체크되지 않는다. 따라서 2️⃣와 같이 사용하도록 한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="keyword">const</span> config: Config = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: &#123;</span><br><span class="line">    key: value,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="built_in">any</span>; <span class="comment">// Don't do this!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">const</span> config: Config = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>, <span class="comment">// These properties are still checked</span></span><br><span class="line">  c: &#123;</span><br><span class="line">    key: value <span class="keyword">as</span> <span class="built_in">any</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-39-any를-구체적으로-변형해서-사용하기"><a href="#아이템-39-any를-구체적으로-변형해서-사용하기" class="headerlink" title="아이템 39 any를 구체적으로 변형해서 사용하기"></a>아이템 39 any를 구체적으로 변형해서 사용하기</h2><ul>
<li>any는 타입의 범위가 매우 넓기 때문에 사용할 때는 정말로 모든 값이 허용되어야하만 하는지 면밀히 검토한다.</li>
<li>any보다 더 정확하게 모델링할 수 있도록 <code>any[]</code> 또는 <code>{[id:string]:any}</code>또는 <code>() =&gt; any</code>를 사용한다.</li>
<li><code>{[id:string]:any}</code>는 함수의 매개변수가 객체인데 값을 알 수 없는 경우에 쓰인다.</li>
</ul>
<hr>
<h2 id="아이템-40-함수-안으로-타입-단언문-감추기"><a href="#아이템-40-함수-안으로-타입-단언문-감추기" class="headerlink" title="아이템 40 함수 안으로 타입 단언문 감추기"></a>아이템 40 함수 안으로 타입 단언문 감추기</h2><p>프로젝트 전반에 위험한 타입 단언문이 드러나 있는 것보다 <em>제대로 타입이 정의된 함수 안으로 타입 단언문을 감추는 것이 좋다.</em></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): <span class="title">boolean</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cacheLast</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Function</span>&gt;(<span class="params">fn: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastArgs: <span class="built_in">any</span>[] | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> lastResult: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lastArgs || !shallowEqual(lastArgs, args)) &#123;</span><br><span class="line">      lastResult = fn(...args);</span><br><span class="line">      lastArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastResult;</span><br><span class="line">  &#125; <span class="keyword">as</span> unknown <span class="keyword">as</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 예제함수에서 함수 내부에는 any가 많이 보이지만 타입 정의에는 any가 없기 때문에 cacheLast를 호출하는 쪽에는 any가 사용됐는지 알 수 없다. 아래 예제에서 shallowobjectEqual은 객체를 매개변수로 하는 함수로 타입 정의는 간단하지만 구현이 복잡하다. 여기서 <code>b as any</code>로 선언할 수 있었던 것은 체크를 통해 <code>k in b</code>를 체크하였기 때문이다. 이 타입 단언문이 없다면 <code>k in b</code>가 b 객체에 k 속성이 있다는 것이 확인되었음에도 불구하고, <em>Element implicitly has an ‘any’ type because type ‘{}’ has no index signature</em> 에러가 발생한다. 이는 실제 에러가 아니기 때문에 any로 타입을 단언한 것이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): <span class="title">boolean</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowObjectEqual</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params">a: T, b: T</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [k, aVal] of <span class="built_in">Object</span>.entries(a)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(k <span class="keyword">in</span> b) || aVal !== (b <span class="keyword">as</span> <span class="built_in">any</span>)[k]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(a).length === <span class="built_in">Object</span>.keys(b).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이처럼 타입 선언문은 일반적으로 타입을 위험하게 만들지만 상황에 따라 필요하기도 하고 현실적이 해결책이 되기도 한다. 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 한다.</p>
<hr>
<h2 id="아이템-41-any의-진화를-이해하기"><a href="#아이템-41-any의-진화를-이해하기" class="headerlink" title="아이템 41 any의 진화를 이해하기"></a>아이템 41 any의 진화를 이해하기</h2><p><strong>타입스크립트에서 일반적으로 변수의 타입을 선언할 때 타입이 결정된다.</strong> null 체크 등을 통해 타입을 정제할 수는 있지만 새로운 값이 추가되도록 확장할 수 없다. 단 any 타입은 예외이다. 타입은 진화하는데 이는 타입 좁히기의 개념과 전혀 다르다.</p>
<h3 id="배열에-다양한-타입의-요소를-넣으면-배열의-타입이-확장되며-진화한다"><a href="#배열에-다양한-타입의-요소를-넣으면-배열의-타입이-확장되며-진화한다" class="headerlink" title="배열에 다양한 타입의 요소를 넣으면 배열의 타입이 확장되며 진화한다."></a>배열에 다양한 타입의 요소를 넣으면 배열의 타입이 확장되며 진화한다.</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = []; <span class="comment">// Type is any[]</span></span><br><span class="line">result.push(<span class="string">'a'</span>);</span><br><span class="line">result; <span class="comment">// Type is string[]</span></span><br><span class="line">result.push(<span class="number">1</span>);</span><br><span class="line">result; <span class="comment">// Type is (string | number)[]</span></span><br></pre></td></tr></table></figure>
<h3 id="조건문에서-분기에-따라-타입이-변한다"><a href="#조건문에서-분기에-따라-타입이-변한다" class="headerlink" title="조건문에서 분기에 따라 타입이 변한다."></a>조건문에서 분기에 따라 타입이 변한다.</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val; <span class="comment">// Type is any</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">  val = <span class="regexp">/hello/</span>;</span><br><span class="line">  val; <span class="comment">// Type is RegExp</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  val = <span class="number">12</span>;</span><br><span class="line">  val; <span class="comment">// Type is number</span></span><br><span class="line">&#125;</span><br><span class="line">val; <span class="comment">// Type is number | RegExp</span></span><br></pre></td></tr></table></figure>
<h3 id="변수의-초기값이-null일-때-진화한다"><a href="#변수의-초기값이-null일-때-진화한다" class="headerlink" title="변수의 초기값이 null일 때 진화한다."></a>변수의 초기값이 null일 때 진화한다.</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">somethingDangerous</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> val = <span class="literal">null</span>; <span class="comment">// Type is any</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  somethingDangerous();</span><br><span class="line">  val = <span class="number">12</span>;</span><br><span class="line">  val; <span class="comment">// Type is number</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">'alas!'</span>);</span><br><span class="line">&#125;</span><br><span class="line">val; <span class="comment">// Type is number | null</span></span><br></pre></td></tr></table></figure>
<h3 id="noImplicitAny가-설정된-상태에서-변수의-타입이-암시적-any이다"><a href="#noImplicitAny가-설정된-상태에서-변수의-타입이-암시적-any이다" class="headerlink" title="noImplicitAny가 설정된 상태에서 변수의 타입이 암시적 any이다."></a>noImplicitAny가 설정된 상태에서 변수의 타입이 암시적 any이다.</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val: <span class="built_in">any</span>; <span class="comment">// Type is any</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">  val = <span class="regexp">/hello/</span>;</span><br><span class="line">  val; <span class="comment">// Type is any</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  val = <span class="number">12</span>;</span><br><span class="line">  val; <span class="comment">// Type is any</span></span><br><span class="line">&#125;</span><br><span class="line">val; <span class="comment">// Type is any</span></span><br></pre></td></tr></table></figure>
<p>any타입의 진화는 암시적 any 타입에 어떤 값을 할당할 때만 발생한다. 그래서 어떤 변수가 암시적 any 상태일 때 어떠한 변수에도 할당하지 않고 값을 읽으려 하면 오류가 발생한다.</p>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/13/220214_item28to34/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/13/220214_item28to34/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 28 - 아이템 34</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-14 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-14T00:00:00+09:00">2022-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 13:09:35" itemprop="dateModified" datetime="2022-05-18T13:09:35+09:00">2022-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-28-유효한-상태만-표현하는-타입을-지향하기"><a href="#아이템-28-유효한-상태만-표현하는-타입을-지향하기" class="headerlink" title="아이템 28 유효한 상태만 표현하는 타입을 지향하기"></a>아이템 28 유효한 상태만 표현하는 타입을 지향하기</h2><blockquote>
<p>효과적으로 타입을 설계하려면 유효한 상태만 표현할 수 있는 타입을 만드는 것이 중요하다.</p>
</blockquote>
<h3 id="유효하지-않은-상태"><a href="#유효하지-않은-상태" class="headerlink" title="유효하지 않은 상태"></a>유효하지 않은 상태</h3><ul>
<li>A,B가 있다고 했을 때, 상태 값의 두 가지 속성이 동시에 정보가 부족하다. (A가 성공인지 실패인지 알 수 없다.)</li>
<li>A,B의 두 가지 속성이 충돌한다. (A이면서 B인 상태가 있다.)</li>
</ul>
<p>이런 무효한 상태가 존재하면 두 가지 모두를 제대로 구현할 수 없게 된다. 유효한 상태를 구현하려면 아래와 같이 명시적으로 모델링하는 <code>태그된 유니온(또는 구별된 유니온)</code>을 사용해서 나타낸다. 이렇게 작성하면 코드가 길어지고 작성하기 어렵지만 무효한 상태를 허용하지 않도록 개선할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> RequestPending &#123;</span><br><span class="line">  state: <span class="string">'pending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> RequestError &#123;</span><br><span class="line">  state: <span class="string">'error'</span>;</span><br><span class="line">  error: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> RequestSuccess &#123;</span><br><span class="line">  state: <span class="string">'ok'</span>;</span><br><span class="line">  pageText: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RequestState = RequestPending | RequestError | RequestSuccess;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">  currentPage: <span class="built_in">string</span>;</span><br><span class="line">  requests: &#123; [page: <span class="built_in">string</span>]: RequestState &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>타입을 설계할 때 어떤 값들을 포함하고, 어떤 값들을 제외할지 신중하게 생각하도록 한다. 유효한 상태를 표현하는 값만 허용하면 코드를 작성하기 쉬워지고 타입 체크가 용이해진다.</p>
<hr>
<h2 id="아이템-29-사용할-때는-너그럽게-생성할-때는-엄격하게"><a href="#아이템-29-사용할-때는-너그럽게-생성할-때는-엄격하게" class="headerlink" title="아이템 29 사용할 때는 너그럽게, 생성할 때는 엄격하게"></a>아이템 29 사용할 때는 너그럽게, 생성할 때는 엄격하게</h2><p>함수의 시그니처는 <code>당신의 작업은 엄격하게, 다른 사람의 작업은 너그럽게 받아들인다</code>는 일반적인 원칙을 따라야 한다. 즉 함수의 매개변수는 타입의 범위가 넓어도 되지만 결과를 반환할 때는 타입의 범위가 더 구체적이어야 한다.</p>
<ul>
<li>viewportForBounds의 타입의 선언이 만들어지고 사용될 때처럼 너무 자유로우면 오류가 발생하기 쉽다.</li>
<li>너무 자유롭다는 것은 수많은 선택적 속성(?)을 가지는 반환 타입을 가지고 있거나 유니온 타입을 사용하는 경우를 말한다.</li>
<li>유니온 타입의 요소별 분기를 위한 방법: 좌표를 위한 기본 형식을 구분한다.<ul>
<li>e.g. 배열과 배열 같은 것: LngLat, LngLatLike</li>
</ul>
</li>
<li>완전하게 정의된 버전과 부분적으로 정의된 부분을 구분한다.<ul>
<li>완전하게 정의된 버전: Camera</li>
<li>부분적으로 정의된 버전: Camera option</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Feature = <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">calculateBoundingBox</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  f: Feature</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">number</span>, <span class="title">number</span>, <span class="title">number</span>, <span class="title">number</span>]</span>;</span><br><span class="line"><span class="keyword">interface</span> LngLat &#123;</span><br><span class="line">  lng: <span class="built_in">number</span>;</span><br><span class="line">  lat: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LngLatLike = LngLat | &#123; lon: <span class="built_in">number</span>; lat: <span class="built_in">number</span> &#125; | [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Camera &#123;</span><br><span class="line">  center: LngLat;</span><br><span class="line">  zoom: <span class="built_in">number</span>;</span><br><span class="line">  bearing: <span class="built_in">number</span>;</span><br><span class="line">  pitch: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> CameraOptions <span class="keyword">extends</span> Omit&lt;Partial&lt;Camera&gt;, 'center'&gt; &#123;</span><br><span class="line">  center?: LngLatLike;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LngLatBounds =</span><br><span class="line">  | &#123; northeast: LngLatLike; southwest: LngLatLike &#125;</span><br><span class="line">  | [LngLatLike, LngLatLike]</span><br><span class="line">  | [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">setCamera</span>(<span class="params">camera: CameraOptions</span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">viewportForBounds</span>(<span class="params">bounds: LngLatBounds</span>): <span class="title">Camera</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">focusOnFeature</span>(<span class="params">f: Feature</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bounds = calculateBoundingBox(f);</span><br><span class="line">  <span class="keyword">const</span> camera = viewportForBounds(bounds);</span><br><span class="line">  setCamera(camera);</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    center: &#123; lat, lng &#125;,</span><br><span class="line">    zoom,</span><br><span class="line">  &#125; = camera; <span class="comment">// OK</span></span><br><span class="line">  zoom; <span class="comment">// Type is number</span></span><br><span class="line">  <span class="built_in">window</span>.location.search = <span class="string">`?v=@<span class="subst">$&#123;lat&#125;</span>,<span class="subst">$&#123;lng&#125;</span>z<span class="subst">$&#123;zoom&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-30-문서에-타입-정보를-쓰지-않기"><a href="#아이템-30-문서에-타입-정보를-쓰지-않기" class="headerlink" title="아이템 30 문서에 타입 정보를 쓰지 않기"></a>아이템 30 문서에 타입 정보를 쓰지 않기</h2><p>코드에 대한 정보가 주석으로 남아있을 때 그 주석의 정보와 코드가 맞이 않을 때가 있다. 타입스크립트의 타입 구문 시스템은 간결하고 구체적이며, 쉽게 읽을 수 있도록 설계되었기 때문에 코드에 대한 설명 및 타입 정보를 주석으로 남기기 보다 타입스크립트의 타입 구문을 사용하도록 한다. <em>타입 구문은 타입스크립트 컴파일러가 체크해 주기 때문에 구현체와의 정합성이 어긋나지도 않는다.</em> 또 주석은 누군가 고치기 전에 강제로 동기화 되지 않는다. 타입스크립트는 타입 체커가 타입 정보를 동기화하도록 강제한다.</p>
<p>타입스크립트는 명시적으로 사용하는 것이 좋다. ageNum이라는 변수를 선언하는 것보다 age로 변수 선언 후 타입은 num임을 명시하는 것이 더 좋다. 단 단위가 있는 숫자들은 단위가 무엇인지 확실하지 않다면 변수명 또는 속성 이름에 단위를 포한한다. 예를 들어 temperature보다 temperatureC가 훨씬 명확하다.</p>
<hr>
<h2 id="아이템-31-타입-주변에-null-값-배치하기"><a href="#아이템-31-타입-주변에-null-값-배치하기" class="headerlink" title="아이템 31 타입 주변에 null 값 배치하기"></a>아이템 31 타입 주변에 null 값 배치하기</h2><p>어떤 변수가 null인지 아닌지를 분명히 해야한다. null과 null이 아닌 값을 섞어서 사용하면 문제가 생긴다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extent</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> min, max;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num of nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!min) &#123;</span><br><span class="line">      min = num;</span><br><span class="line">      max = num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      min = <span class="built_in">Math</span>.min(min, num);</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, num);</span><br><span class="line">      <span class="comment">// ~~~ Argument of type 'number | undefined' is not</span></span><br><span class="line">      <span class="comment">//     assignable to parameter of type 'number'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [min, max];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [min, max] = extent([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">const</span> span = max - min;</span><br><span class="line"><span class="comment">// ~~~   ~~~ Object is possibly 'undefined'</span></span><br></pre></td></tr></table></figure>
<p>위 예제에서 extent의 반환값이 (number | undefined)[]로 추론된다. 이렇게 되면 extent를 호출하는 곳마다 타입 오류의 형태로 나타난다. 더 나은 해법으로는 min, max를 한 객체 안에 넣고 null이거나 null이 아니게 하는 아래와 같은 방법으로 작성한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extent</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: [<span class="built_in">number</span>, <span class="built_in">number</span>] | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num of nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">      result = [num, num];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = [<span class="built_in">Math</span>.min(num, result[<span class="number">0</span>]), <span class="built_in">Math</span>.max(num, result[<span class="number">1</span>])];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TL;DR</p>
<ul>
<li>한 값의 null 여부가 다른 값의 null 여부에 암시적으로 관련되도록 설계하면 안된다.</li>
<li>API 작성 시에는 반환 타입을 큰 객체로 만들고 반환 타입 전체가 null이거나 null이 아니게 만들어야 한다.</li>
<li>클래스를 만들 때는 필요한 모든 값이 준비되었을 때 생성하여 null이 존재하지 않도록 한다.</li>
<li>strictNullChecks를 설정하면 코드에 많은 오류가 표시되갰지만, null 값과 관련된 문제점을 찾아낼 수 있기 때문에 반드시 필요하다.</li>
</ul>
<hr>
<h2 id="아이템-32-유니온의-인터페이스보다는-인터페이스의-유니온을-사용하기"><a href="#아이템-32-유니온의-인터페이스보다는-인터페이스의-유니온을-사용하기" class="headerlink" title="아이템 32 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기"></a>아이템 32 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기</h2><p>유니온 타입의 속성을 가지는 인터페이스를 작성 중이라면, 인터페이스의 유니온 타입을 사용하는 게 더 알맞지 않을지 검토해보아야 한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Layer &#123;</span><br><span class="line">  layout: FillLayout | LineLayout | PointLayout;</span><br><span class="line">  paint: FillPaint | LinePaint | PointPaint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 예제는 벡터를 그리는 프로그램을 작성 중이고, 특정한 기하학적 타입을 가지는 계층의 인터페이스를 정의한다고 가정하는 코드이다. 그런데 이 코드에서 layout이 LineLayout(직선)이면서 paint 속성이 FillPaint타입이 되는 조합은 성립하지 않는다. 그런데 위의 코드는 그런 조합을 허용하는 코드이기 때문에 오류가 발생하기 쉽다. 이런 상황에서는 layout과 paint 속성이 지금처럼 잘못된 조합으로 섞이지 않도록 아래와 같이 <strong>각각 타입의 계층을 분리된 인터페이스로 작성하도록 한다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> FillLayer &#123;</span><br><span class="line">  layout: FillLayout;</span><br><span class="line">  paint: FillPaint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> LineLayer &#123;</span><br><span class="line">  layout: LineLayout;</span><br><span class="line">  paint: LinePaint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> PointLayer &#123;</span><br><span class="line">  layout: PointLayout;</span><br><span class="line">  paint: PointPaint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Layer = FillLayer | LineLayer | PointLayer;</span><br></pre></td></tr></table></figure>
<p>이렇게 작성하면 유효한 상태만을 표현하게 된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Layer &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'fill'</span> | <span class="string">'line'</span> | <span class="string">'point'</span>;</span><br><span class="line">  layout: FillLayout | LineLayout | PointLayout;</span><br><span class="line">  paint: FillPaint | LinePaint | PointPaint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같은 태그된 유니온에서도 유효하지 못한 상태가 섞이는 문제가 발생한다. 태그된 유니온은 여러개의 타입을 유니온으로 선언할 때 각 타입에 태그가 있어서 이것으로 구분하는 것을 말한다. 여기서 Layer 속성 중 하나는 문자열 타입의 유니온인데, 이 역시 type: ‘fill’일 때 LineLayout과 PointPaint 타입이 함께 쓰이는 것은 유효하지 않다. 그래서 아래와 같이 Layer의 인터페이스를 유니온으로 변환하는 방식으로 개선할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> FillLayer &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'fill'</span>;</span><br><span class="line">  layout: FillLayout;</span><br><span class="line">  paint: FillPaint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> LineLayer &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'line'</span>;</span><br><span class="line">  layout: LineLayout;</span><br><span class="line">  paint: LinePaint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> PointLayer &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'paint'</span>;</span><br><span class="line">  layout: PointLayout;</span><br><span class="line">  paint: PointPaint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Layer = FillLayer | LineLayer | PointLayer;</span><br></pre></td></tr></table></figure>
<p>이와 같이 어떤 데이터 타입을 <code>태그된 유니온</code>으로 표현할 수 있다면 그렇게 하는 것이 좋다. 특히 여러 개의 선택적 필드가 동시에 값이 있거나 동시에 undefined일 때 이 패턴이 적절하다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// These will either both be present or not be present</span></span><br><span class="line">  placeOfBirth?: <span class="built_in">string</span>;</span><br><span class="line">  dateOfBirth?: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 주석으로 타입에 대한 정보를 남기 코드가 있다고 했을 때, 이 타입 정보는 placeOfBirth와 dateOfBirth의 관계가 정확하게 표현되어 있지 않다. 이런 경우에는 아래와 같이 타입의 구조를 변경하여 <strong>두 개의 속성을 하나의 객체로 모으는 것이 더 나은 설계이다. 이는 null 값을 경계로 두는 아이템 31의 방법과 비슷하다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  birth?: &#123;</span><br><span class="line">    place: <span class="built_in">string</span>;</span><br><span class="line">    date: <span class="built_in">Date</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>하지만 타입의 구조를 손 댈 수 없는 경우라면(e.g.API response) 아래와 같이 <strong>인터페이스의 유니온을 사용해서 속성 사이의 관계를 모델링한다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  birth?: &#123;</span><br><span class="line">    place: <span class="built_in">string</span>;</span><br><span class="line">    date: <span class="built_in">Date</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PersonWithBirth <span class="keyword">extends</span> Name &#123;</span><br><span class="line">  placeOfBirth: <span class="built_in">string</span>;</span><br><span class="line">  dateOfBirth: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person = Name | PersonWithBirth;</span><br></pre></td></tr></table></figure>
<p>TL;DR</p>
<ul>
<li>유니온 타입의 속성을 여러 개 가지는 인터페이스에서는 속성 간의 관계가 분명하지 않기 때문에 실수가 자주 발생하므로 주의하도록 한다.</li>
<li>유니온의 인터페이스보다 인터페이스의 유니온이 더 정확하고 타입스크립트가 이해하기 좋다.</li>
<li>타입스크립트가 제어된 흐름을 분석할 수 있도록 타입에 태그를 넣는 것을 고려하도록 한다. 태그된 유니온은 타입스트립트와 매우 잘 맞아서 자주 볼 수 있는 패턴이다.</li>
</ul>
<hr>
<h2 id="아이템-33-string-타입보다-더-구체적인-타입-사용하기"><a href="#아이템-33-string-타입보다-더-구체적인-타입-사용하기" class="headerlink" title="아이템 33 string 타입보다 더 구체적인 타입 사용하기"></a>아이템 33 string 타입보다 더 구체적인 타입 사용하기</h2><p>string 타입의 범위는 매우 넓어서 ‘x’와 같은 한 글자와 , ‘call me ishmael….’로 시작하는 모비딕의 전체 내용과 같이 긴 텍스트도 string 타입이다. <strong>그러므로 타입으로 변수를 선언 할 때, 더 좁은 타입이 적절하지 않을 지 검토해보아야 한다.</strong> string은 any와 비슷한 문제를 가지고 있어서 잘못 사용하면 무효한 값을 허용하고, 타입 간의 관계를 감추어 버리기 때문이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Album &#123;</span><br><span class="line">  artist: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  releaseDate: <span class="built_in">string</span>; <span class="comment">// YYYY-MM-DD</span></span><br><span class="line">  recordingType: <span class="built_in">string</span>; <span class="comment">// E.g., "live" or "studio"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> kindOfBlue: Album = &#123;</span><br><span class="line">  artist: <span class="string">'Miles Davis'</span>,</span><br><span class="line">  title: <span class="string">'Kind of Blue'</span>,</span><br><span class="line">  releaseDate: <span class="string">'August 17th, 1959'</span>, <span class="comment">// Oops!</span></span><br><span class="line">  recordingType: <span class="string">'Studio'</span>, <span class="comment">// Oops!</span></span><br><span class="line">&#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>위의 Album은 string이 남발되어 타입이 모델링 되었다.(stringly typed) 이 경우 releaseDate, recordinType이 Album에 정의된 주석과 다른 형태로 모델링되었지만 string이기 때문에 타입 체커를 통과한다. 아래와 같이 함수 호출시 매개변수의 순서가 바뀐 경우에도 둘 다 문자열이기 때문에 타입 체커를 통과한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recordRelease</span>(<span class="params">title: <span class="built_in">string</span>, date: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line">recordRelease(kindOfBlue.releaseDate, kindOfBlue.title); <span class="comment">// OK, should be error</span></span><br></pre></td></tr></table></figure>
<p>이런 경우 아래와 같이 타입을 좁히는 방식으로 개선할 수 있다. releaseDate는 날짜형식으로 제한하고, recordingType은 두 개의 값을 가진 유니온 타입으로 정의할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RecordingType = <span class="string">'studio'</span> | <span class="string">'live'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Album &#123;</span><br><span class="line">  artist: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  releaseDate: <span class="built_in">Date</span>;</span><br><span class="line">  recordingType: RecordingType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이렇게 작성하면 앞서 오류가 발생할 상황에서도 타입체커를 통과했던 것과 다르게 타입스크립트가 타입 체커를 세밀하게 체크할 수 있어서 타입 오류를 잘 검사하게 된다.</p>
<h3 id="string-타입-좁히기의-장점"><a href="#string-타입-좁히기의-장점" class="headerlink" title="string 타입 좁히기의 장점"></a>string 타입 좁히기의 장점</h3><ul>
<li>타입을 명시적으로 정의하여 다른 곳으로 값이 전달되어도 타입 정보가 유지된다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//recordingType 매개변수에 대한 타입을 RecordingType과 같이 사용하면 편집기에서 자동완성을 통해 타입에 대한 설명을 확인할 수 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAlbumsOfType</span>(<span class="params">recordingType: RecordingType</span>): <span class="title">Album</span>[] </span>&#123;</span><br><span class="line">  <span class="comment">// COMPRESS</span></span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">  <span class="comment">// END</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>타입을 명시적으로 정의히고, 해당 타입의 의미를 설명하는 주석을 함께 쓸 수 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** What type of environment was this recording made in?  */</span></span><br><span class="line"><span class="keyword">type</span> RecordingType = <span class="string">'live'</span> | <span class="string">'studio'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>keyof 연산자로 더욱 세밀하게 객체의 속성 체크가 가능하다.<ul>
<li><ol>
<li>underscore 라이브러리의 pluck함수의 시그니처를 작성한다.</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>(<span class="params">record: <span class="built_in">any</span>[], key: <span class="built_in">string</span></span>): <span class="title">any</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> record.map(<span class="function">(<span class="params">r</span>) =&gt;</span> r[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.타입 체크가 되지만 정밀하지 못하다. 반환값에 any를 쓰는 것도 바람직 하지 않다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//제너릭 타입을 도입하여 개선한다.하지만 매개변수가 string이므로 오류를 발생시킨다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>&gt;(<span class="params">record: T[], key: <span class="built_in">string</span></span>): <span class="title">any</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> record.map(<span class="function">(<span class="params">r</span>) =&gt;</span> r[key]);</span><br><span class="line">  <span class="comment">// ~~~~~~ Element implicitly has an 'any' type</span></span><br><span class="line">  <span class="comment">//        because type '&#123;&#125;' has no index signature</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.매개변수로 Album의 배열을 전달했기 때문에 string이었던 타입이 type k와 같이 좁혀졌다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RecordingType = <span class="string">'studio'</span> | <span class="string">'live'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Album &#123;</span><br><span class="line">  artist: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  releaseDate: <span class="built_in">Date</span>;</span><br><span class="line">  recordingType: RecordingType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> K = keyof Album;</span><br><span class="line"><span class="comment">// Type is "artist" | "title" | "releaseDate" | "recordingType"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>&gt;(<span class="params">record: T[], key: keyof T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> record.map(<span class="function">(<span class="params">r</span>) =&gt;</span> r[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>keyof T의 부분 집합(아마도 단일값)으로 두 번째 제너릭 매개변수를 도입한다.</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T[key of]T는 T 객체 내에 가능한 모든 값의 타입이라서 string보다는 범위가 좁지만 여전히 넓다.</span></span><br><span class="line"><span class="comment">//또 key에 문자열 하나를 넣게 되면 그에 비해 범위는 너무 넓어서 적절하지 않다.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> albums: Album[];</span><br><span class="line"><span class="keyword">const</span> releaseDates = pluck(albums, <span class="string">'releaseDate'</span>); <span class="comment">// Type is (string | Date)[]</span></span><br></pre></td></tr></table></figure>
<p>아래와 같이 두 번째 제너릭 매개변수를 도입한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">record: T[], key: K</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> record.map(<span class="function">(<span class="params">r</span>) =&gt;</span> r[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-34-부정확한-타입보다는-미완성-타입을-사용하기"><a href="#아이템-34-부정확한-타입보다는-미완성-타입을-사용하기" class="headerlink" title="아이템 34 부정확한 타입보다는 미완성 타입을 사용하기"></a>아이템 34 부정확한 타입보다는 미완성 타입을 사용하기</h2><p>타입이 구체적일수록 버그를 더 잘 잡고, 타입스크립트가 제공하는 도구를 활용할 수 있는데, <em>잘못된 타입은 차라리 타입이 없는 것만 못하기 때문에 주의를 기울여야 한다.</em></p>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/09/220210_item21to27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/09/220210_item21to27/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 21 - 아이템 27</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-10 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-10T00:00:00+09:00">2022-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 13:09:35" itemprop="dateModified" datetime="2022-05-18T13:09:35+09:00">2022-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-21-타입-넓히기"><a href="#아이템-21-타입-넓히기" class="headerlink" title="아이템 21 타입 넓히기"></a>아이템 21 타입 넓히기</h2><p>런타임에 모든 변수는 유일한 <code>값</code>을 가지고, 타입스크립트가 코드를 체크하는 정적 분석 시점에 변수는 가능한 값들의 집합인 <code>타입</code>을 가진다. 그래서 상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커가 타입을 결정해야 한다. <em>즉 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다.</em>는 뜻이다. 그리고 이를 <code>넓히기(widening)</code>라고 부른다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixed = [<span class="string">'x'</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//추론 가능한 타입</span></span><br><span class="line">(<span class="string">'x'</span> | <span class="number">1</span>)[]</span><br><span class="line">[<span class="string">'x'</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line">(<span class="built_in">string</span>|<span class="built_in">number</span>)[]</span><br><span class="line"></span><br><span class="line"><span class="comment">//생략</span></span><br></pre></td></tr></table></figure>
<p>위 예제에서 mixed는 추론 가능한 타입이 여러개이다. 만약 mixed에 대한 타입이 충분하지 않다면 어떤 타입으로 추론되어야 하는지 할 수 없어서 타입스크립트는 작성자의 의도를 추측한다.</p>
<h3 id="넓히기-과정을-제어하는-방법"><a href="#넓히기-과정을-제어하는-방법" class="headerlink" title="넓히기 과정을 제어하는 방법"></a>넓히기 과정을 제어하는 방법</h3><ul>
<li>const의 사용 : let 대신 const로 변수를 선언한다. const는 재할당이 불가하기 때문에 타입스크립트가 추론 가능한 타입이 여러개여서 모호한 과정에 빠지지 않는다. 다만 객체와 배열의 경우 const를 써도 문제가 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v = &#123;</span><br><span class="line">  x: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">v.x = <span class="number">3</span> <span class="comment">// OK</span></span><br><span class="line">v.x = <span class="string">'3'</span></span><br><span class="line"><span class="comment">// ~ Type '"3"' is not assignable to type 'number'</span></span><br><span class="line">v.y = <span class="number">4</span></span><br><span class="line"><span class="comment">// ~ Property 'y' does not exist on type '&#123; x: number; &#125;'</span></span><br><span class="line">v.name = <span class="string">'Pythagoras'</span></span><br><span class="line"><span class="comment">// ~~~~ Property 'name' does not exist on type '&#123; x: number; &#125;'</span></span><br></pre></td></tr></table></figure>
<p><strong>타입스크립트는 명확성과 유연성 사이의 균형을 유지하려고 한다.</strong> 그래서 구체적으로 타입을 추론해야 하지만, 잘못된 추론을 할 정도로 구체적으로 수행하진 않는다. 만약 타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의한다.</p>
<h3 id="타입스크립트의-기본-동작-제어방법"><a href="#타입스크립트의-기본-동작-제어방법" class="headerlink" title="타입스크립트의 기본 동작 제어방법"></a>타입스크립트의 기본 동작 제어방법</h3><ul>
<li>명시적 타입 구문 제공</li>
<li>타입 체커에 추가적인 문맥 제공</li>
<li>const 단언만 사용<ul>
<li>이 const는 변수 선언에 쓰이는 const와 가른 것이므로 헷갈려서는 안된다. <em>const 단언문은 온전히 타입 공간의 기법이다.</em></li>
<li>아래 예제에서 값 뒤에 <code>as const</code>를 작성하면 최대한 좁은 타입으로 추론하기 때문에 v3에서 넓히기가 동작하지 않는다.</li>
<li>배열을 튜플로 추론할 때도 <code>as const</code>를 쓸 수 있다.</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Vector3 &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">  z: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params">vector: Vector3, axis: 'x' | 'y' | 'z'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> vector[axis]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span></span><br><span class="line">&#125; <span class="comment">// Type is &#123; x: number; y: number; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">  x: <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">const</span>,</span><br><span class="line">  y: <span class="number">2</span></span><br><span class="line">&#125; <span class="comment">// Type is &#123; x: 1; y: number; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v3 = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span> <span class="comment">// Type is &#123; readonly x: 1; readonly y: 2; &#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-22-타입-좁히기"><a href="#아이템-22-타입-좁히기" class="headerlink" title="아이템 22 타입 좁히기"></a>아이템 22 타입 좁히기</h2><p><code>타입 넓히기의 반대개념이다.</code> 타입스크립트가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말한다.</p>
<ul>
<li>null 체크</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>) <span class="comment">// Type is HTMLElement | null</span></span><br><span class="line"><span class="keyword">if</span> (el) &#123;</span><br><span class="line">  el <span class="comment">// Type is HTMLElement</span></span><br><span class="line">  el.innerHTML = <span class="string">'Party Time'</span>.blink()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  el <span class="comment">// Type is null</span></span><br><span class="line">  alert(<span class="string">'No element #foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>) <span class="comment">// Type is HTMLElement | null</span></span><br><span class="line"><span class="keyword">if</span> (!el) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unable to find #foo'</span>)</span><br><span class="line">el <span class="comment">// Now type is HTMLElement</span></span><br><span class="line">el.innerHTML = <span class="string">'Party Time'</span>.blink()</span><br></pre></td></tr></table></figure>
<p>위 예시에서 1️⃣의 el이 null이면 첫번 째 블록의 <em>const el = document.getElementById(‘foo’); // Type is HTMLElement | null</em> 을 실행하지 않기 때문에 <em>Type is HTMLElement | null</em>에서 null을 제외하므로 더 좁은 타입이 된다. 2️⃣와 같이 분기문에서 예외를 던지거나 함수를 반환해서 블록의 나머지 부분에서 변수의 타입을 좁힐 수도 있다.</p>
<ul>
<li>instanceof사용</li>
<li>속성 체크</li>
<li>Array.isArray 사용</li>
<li>조건문 사용</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>) <span class="comment">// type is HTMLElement | null</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> el === <span class="string">'object'</span>) &#123;</span><br><span class="line">  el <span class="comment">// Type is HTMLElement | null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>조건문이 가장 타입을 좁히는 데 능숙한 방법이지만 위와 같은 예제처럼 실수를 일으키기 쉽다. 위 예제에서 <code>typeof null은 object</code>이기 때문에 if문에서 null이 제외되지 않는다. 다음과 같은 기본형에서도 기본형 값이 잘못되어도 제대로 좁혀지지 않는다. 빈 문자열 ‘’와 0 모두 false가 되기 때문에 좁혀지지 않는다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x?: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">    x <span class="comment">// Type is string | number | null | undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>명시적 태그를 붙이기 (태그된 유니온 또는 구별된 유니온</li>
<li>사용자 정의 타입 가드 사용: 타입스크립트가 타입을 식별하지 못할 때 커스텀 함수를 도입할 수 있다.</li>
<li>타입 가드 사용</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jackson5 = [<span class="string">'Jackie'</span>, <span class="string">'Tito'</span>, <span class="string">'Jermaine'</span>, <span class="string">'Marlon'</span>, <span class="string">'Michael'</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDefined</span>&lt;<span class="title">T</span>&gt;(<span class="params">x: T | <span class="literal">undefined</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> members = [<span class="string">'Janet'</span>, <span class="string">'Michael'</span>]</span><br><span class="line">  .map(<span class="function"><span class="params">who</span> =&gt;</span> jackson5.find(<span class="function"><span class="params">n</span> =&gt;</span> n === who))</span><br><span class="line">  .filter(isDefined) <span class="comment">// Type is string[]</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-23-한꺼번에-객체-생성하기"><a href="#아이템-23-한꺼번에-객체-생성하기" class="headerlink" title="아이템 23 한꺼번에 객체 생성하기"></a>아이템 23 한꺼번에 객체 생성하기</h2><blockquote>
<p>타입스크립트의 타입은 변경되지 않기 때문에 객체를 생성할 때는 속성을 하나씩 추가하는 것 보다 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//에러 발생</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123;&#125;</span><br><span class="line">pt.x = <span class="number">3</span></span><br><span class="line"><span class="comment">// ~ Property 'x' does not exist on type '&#123;&#125;'</span></span><br><span class="line">pt.y = <span class="number">4</span></span><br><span class="line"><span class="comment">// ~ Property 'y' does not exist on type '&#123;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//에러 발생</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pt: Point = &#123;&#125;</span><br><span class="line"><span class="comment">// ~~ Type '&#123;&#125;' is missing the following properties from type 'Point': x, y</span></span><br><span class="line">pt.x = <span class="number">3</span></span><br><span class="line">pt.y = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//통과 - 객체 한꺼번에 생성</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pt = &#123;</span><br><span class="line">  x: <span class="number">3</span>,</span><br><span class="line">  y: <span class="number">4</span></span><br><span class="line">&#125; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>객체를 반드시 제각각 나눠서 만들어야 한다면 <code>타입 단언문(as)</code>를 사용한다. 그러나 객체를 한꺼번에 만드는 것이 더욱 권장된다. 작은 객체들을 조합해서 큰 객체를 만들어야 할 때는 <code>전개 연산자</code>를 사용해서 객체를 한꺼번에 만든다. 이렇게 하면 타입 걱정 없이 필드 단위로 객체를 생성할 수 있는데 이때 중요한 점은 <strong>모든 업데이트마다 새 변수를 사용하여 새로운 타입을 얻도록 하는 것이다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//전개 연산자 사용</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pt = &#123; x: <span class="number">3</span>, y: <span class="number">4</span> &#125;</span><br><span class="line"><span class="keyword">const</span> id = &#123; name: <span class="string">'Pythagoras'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> namedPoint = &#123; ...pt, ...id &#125;</span><br><span class="line">namedPoint.name <span class="comment">// OK, type is string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//전개 연산자를 사용할 때 모든 업데이트 시</span></span><br><span class="line"><span class="comment">//새 변수를 사용하여 새로운 타입을 얻도록 한다.</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pt0 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> pt1 = &#123; ...pt0, x: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">const</span> pt: Point = &#123; ...pt1, y: <span class="number">4</span> &#125; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>타입에 안전한 방식으로 조건부 속성을 추가하려면 속성을 추가하지 않는 null 또는 {}로 객체 전개를 사용한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ 조건부 속성의 추가 - &#123;&#125;</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> hasMiddle: <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">const</span> firstLast = &#123; first: <span class="string">'Harry'</span>, last: <span class="string">'Truman'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> president = &#123; ...firstLast, ...(hasMiddle ? &#123; middle: <span class="string">'S'</span> &#125; : &#123;&#125;) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣전개 연산자로 한꺼번에 여러 속성을 추가한다.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> hasDates: <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">const</span> nameTitle = &#123; first: <span class="string">'Harry'</span>, last: <span class="string">'Truman'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> pharaoh = &#123;</span><br><span class="line">  ...nameTitle,</span><br><span class="line">  ...(hasDates ? &#123; start: <span class="number">-289</span>, end: <span class="number">-22</span> &#125; : &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2️⃣의 타입은 <code>유니온</code>으로 추론된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pharaoh:</span><br><span class="line">   &#123;</span><br><span class="line">      start: number;</span><br><span class="line">      end: number;</span><br><span class="line">      name: string;</span><br><span class="line">      title: string;</span><br><span class="line">    &#125;</span><br><span class="line">  | &#123; <span class="attr">name</span>: string; title: string &#125;;</span><br></pre></td></tr></table></figure>
<p>이 경우 pharaoh.start로 접근하면 start와 end는 항상 함께 정의되기 때문에 속성이 없다는 에러가 표시된다. <strong>따라서 유니온을 사용하는 것이 가능한 값의 집합을 더 정확히 표현하는 것이다.</strong> 다만 유니온보다 선택적 필드가 다루기에 더 쉬울 수 있다. 아래와 같이 헬퍼 함수를 사용해서 표현한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> hasMiddle: <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">const</span> firstLast = &#123; first: <span class="string">'Harry'</span>, last: <span class="string">'Truman'</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOptional</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">U</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  a: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  b: U | <span class="literal">null</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">T</span> &amp; <span class="title">Partial</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...a, ...b &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> president = addOptional(firstLast, hasMiddle ? &#123; middle: <span class="string">'S'</span> &#125; : <span class="literal">null</span>)</span><br><span class="line">president.middle <span class="comment">// OK, type is string | undefined</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-24-일관성-있는-별칭-사용하기"><a href="#아이템-24-일관성-있는-별칭-사용하기" class="headerlink" title="아이템 24 일관성 있는 별칭 사용하기"></a>아이템 24 일관성 있는 별칭 사용하기</h2><p>별칭의 값을 변경하면 원래 속성값에서도 변경된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> borough = &#123; name: <span class="string">'Brooklyn'</span>, location: [<span class="number">40.688</span>, <span class="number">-73.979</span>] &#125;</span><br><span class="line"><span class="keyword">const</span> loc = borough.location</span><br><span class="line"></span><br><span class="line">loc[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">borough.location <span class="comment">// [0, -73.979]</span></span><br></pre></td></tr></table></figure>
<p>이렇게 별칭을 사용할 때 남발해서 사용하면 제어 흐름을 분석하기 어렵다. 제어 흐름을 분석하기 어려워서 오류가 발생할 수 있는데, <code>별칭은 일관성있게 사용한다</code>는 기본 원칙을 지키면 오류를 방지할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Coordinate &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BoundingBox &#123;</span><br><span class="line">  x: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">  y: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Polygon &#123;</span><br><span class="line">  exterior: Coordinate[]</span><br><span class="line">  holes: Coordinate[][]</span><br><span class="line">  bbox?: BoundingBox</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//객체 비구조화 사용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPointInPolygon</span>(<span class="params">polygon: Polygon, pt: Coordinate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; bbox &#125; = polygon</span><br><span class="line">  <span class="keyword">if</span> (bbox) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = bbox</span><br><span class="line">    <span class="keyword">if</span> (pt.x &lt; x[<span class="number">0</span>] || pt.x &gt; x[<span class="number">1</span>] || pt.y &lt; x[<span class="number">0</span>] || pt.y &gt; y[<span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>위와 같이 별칭 대신 객체 비구조화를 사용해서 일관된 이름을 사용할 수 있는데,</strong> 배열과 중첩된 구조에서도 사용 가능하다. 다만 아래의 두 가지 문제를 주의한다.</p>
<ul>
<li>전체 bbox 속성이 아니라 x와 y가 선택적 속성일 경우 속성 체크가 더 필요하다. 따라서 타입의 경계에 null 값을 추가하는 것이 좋다.</li>
<li>bbox에는 선택적 속성이 적합했지만 holes에는 그렇지 않다. holes가 선택적이라면 값이 없거나 빈 배열이었을 것이다. 차이가 없는데 이름을 구별한 것이다. 빈 배열은 ‘holes없음’을 나타내는 좋은 방법이다.</li>
</ul>
<p>별칭은 타입 체커 뿐 아니라 런타임에도 혼동을 야기할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Coordinate &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BoundingBox &#123;</span><br><span class="line">  x: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">  y: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Polygon &#123;</span><br><span class="line">  exterior: Coordinate[]</span><br><span class="line">  holes: Coordinate[][]</span><br><span class="line">  bbox?: BoundingBox</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1️⃣ 런타임에 혼동을 야기한다.</span></span><br><span class="line"><span class="comment">// HIDE</span></span><br><span class="line"><span class="keyword">const</span> polygon: Polygon = &#123; exterior: [], holes: [] &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculatePolygonBbox</span>(<span class="params">polygon: Polygon</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// END</span></span><br><span class="line"><span class="keyword">const</span> &#123; bbox &#125; = polygon</span><br><span class="line"><span class="keyword">if</span> (!bbox) &#123;</span><br><span class="line">  calculatePolygonBbox(polygon) <span class="comment">// Fills in polygon.bbox</span></span><br><span class="line">  <span class="comment">// Now polygon.bbox and bbox refer to different values!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ 객체 속성에 대해 주의한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">p: Polygon</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">polygon.bbox <span class="comment">// Type is BoundingBox | undefined</span></span><br><span class="line"><span class="keyword">if</span> (polygon.bbox) &#123;</span><br><span class="line">  polygon.bbox <span class="comment">// Type is BoundingBox</span></span><br><span class="line">  fn(polygon)</span><br><span class="line">  polygon.bbox <span class="comment">// Type is still BoundingBox</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2️⃣의 경우 fn(polygon)을 호출하면 polygon.bbox를 제거할 가능성이 있다. 따라서 타입은 BoundingBox | undefined로 되돌리는 것이 안전하다. 그러나 함수를 호출할 때마나 속성 체크를 반복해야한다는 문제가 있다. <strong>그래서 타입스크립트는 함수가 타입 정제를 무효화하지 않는다고 가정하지만 실제로는 무효화될 가능성이 있다.</strong></p>
<h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h3><ul>
<li>별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때 일관되게 사용해야 한다.</li>
<li>비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.</li>
<li>함수 호출이 객체 속성의 타입 정제를 무효화하 수 있다는 점에 주의한다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.</li>
</ul>
<hr>
<h2 id="아이템-25-비동기-코드에는-콜백-대신-async-함수-사용하기"><a href="#아이템-25-비동기-코드에는-콜백-대신-async-함수-사용하기" class="headerlink" title="아이템 25 비동기 코드에는 콜백 대신 async 함수 사용하기"></a>아이템 25 비동기 코드에는 콜백 대신 async 함수 사용하기</h2><p>자바스크립트는 비동기 동작을 모델링하기 위해 <code>콜백 패턴</code>을 사용했는데, 필연적으로 콜백 지옥을 마주하여 직관적으로 코드를 이해하기 어려운 상황에 부딪히게 된다. 이를 극복하기 위해 프로미스, async await 키워드가 도입되어서 콜백 지옥을 간단하게 해결할 수 있게 되었다. ES5 또는 그 이전 버전을 대상으로 할 때 타입스크립트 컴파일러는 async와 await가 동작하도록 정교한 변환을 수행한다. <strong>즉 런타임에 관계없이 async/await를 사용할 수 있다.</strong> async 함수는 항상 프로미스를 반환하도록 강제된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _cache: &#123; [url: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchWithCache</span>(<span class="params">url: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (url <span class="keyword">in</span> _cache) &#123;</span><br><span class="line">    <span class="keyword">return</span> _cache[url]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url)</span><br><span class="line">  <span class="keyword">const</span> text = <span class="keyword">await</span> response.text()</span><br><span class="line">  _cache[url] = text</span><br><span class="line">  <span class="keyword">return</span> text</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> requestStatus: <span class="string">'loading'</span> | <span class="string">'success'</span> | <span class="string">'error'</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">userId: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  requestStatus = <span class="string">'loading'</span></span><br><span class="line">  <span class="keyword">const</span> profile = <span class="keyword">await</span> fetchWithCache(<span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span>)</span><br><span class="line">  requestStatus = <span class="string">'success'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드에서 async/await를 사용했기 때문에 requestStatus가 ‘success’로 끝나는 것이 명백해졌다. 콜백이나 프로미스를 사용하면 의도치한게 동기코드를 작성하게 되는 것처럼 실수로 반(half)동기 코드를 작성할 수 있지만 async를 사용하면 항상 비동기 코드를 작성하게 된다. 또한 async함수에서 프로미스를 반환하면 또 다른 프로미스로 래핑되지 않기 때문에 <code>Promise&lt;Promise&lt;T&gt;&gt;</code>가 아닌 <code>Promise&lt;T&gt;</code>가 된다.</p>
<h3 id="TL-DR-1"><a href="#TL-DR-1" class="headerlink" title="TL;DR"></a>TL;DR</h3><ul>
<li>콜백보다는 프로미스를 사용하는 게 코드 작성과 타입 추론 면에서 유리하다.</li>
<li>가능하면 프로미스를 생성하기보다 async와 await를 사용하는 것이 좋다. 간결하고 직관적인 코드를 작성할 수 있고 모든 종류의 오류를 제거할 수 있기 때문이다.</li>
<li>어떤 함수가 프로미스를 반환한다면 async로 선언하는 것이 좋다.</li>
</ul>
<hr>
<h2 id="아이템-26-타입-추론에-문맥이-어떻게-사용되는지-이해하기"><a href="#아이템-26-타입-추론에-문맥이-어떻게-사용되는지-이해하기" class="headerlink" title="아이템 26 타입 추론에 문맥이 어떻게 사용되는지 이해하기"></a>아이템 26 타입 추론에 문맥이 어떻게 사용되는지 이해하기</h2><p><strong>타입스크립트는 타입 추론 시 값만 고려하는 것이 아니라 그 값이 존재하는 곳의 문맥도 살핀다.</strong> 그렇기 때문에 가끔 이상한 결과가 나오기도 해서 타입 추론에 문맥이 어떻게 사용되는지 이해하는 것이 중요하다.</p>
<p>자바스크립트는 코드의 동작과 실행 순서를 바꾸지 않으면서 표현식을 상수로 분리해 낼 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLanguage</span>(<span class="params">language: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setLanguage(<span class="string">'JavaScript'</span>) <span class="comment">// OK, 인라인 형태</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> language = <span class="string">'JavaScript'</span></span><br><span class="line">setLanguage(language) <span class="comment">// OK, 참조 형태</span></span><br></pre></td></tr></table></figure>
<p>인라인 형태의 타입스크립트는 함수 선언을 통해 <em>매개변수가 language 타입</em>이어야 한다는 것을 알고 있다. 타입스크립트는 일반적으로 값이 처음 등장할 때 타입을 결정하기 때문이다. 그러나 이 값으르 변수로 분리해내면 타입스크립트는 할당 시점에 타입을 추론한다. 그래서 아래와 같이 string으로 추론하고, Language 타입에 할당이 불가능해서 오류가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Language = <span class="string">'JavaScript'</span> | <span class="string">'TypeScript'</span> | <span class="string">'Python'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLanguage</span>(<span class="params">language: Language</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setLanguage(<span class="string">'JavaScript'</span>) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> language = <span class="string">'JavaScript'</span></span><br><span class="line">setLanguage(language)</span><br><span class="line"><span class="comment">// ~~~~~~~~ Argument of type 'string' is not assignable</span></span><br><span class="line"><span class="comment">//          to parameter of type 'Language'</span></span><br></pre></td></tr></table></figure>
<h3 id="해결-방법"><a href="#해결-방법" class="headerlink" title="해결 방법"></a>해결 방법</h3><ul>
<li>타입 선언에서 language의 가능한 값을 제한한다.</li>
<li>language를 상수로 만든다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//타입 선언에서 language의 가능한 값을 제한한다.</span></span><br><span class="line"><span class="keyword">let</span> language: Language = <span class="string">'JavaScript'</span></span><br><span class="line">setLanguage(language) <span class="comment">//정상</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//language를 상수로 만든다.</span></span><br><span class="line"><span class="keyword">const</span> language = <span class="string">'JavaScript'</span></span><br><span class="line">setLanguage(language) <span class="comment">//정상</span></span><br></pre></td></tr></table></figure>
<h3 id="튜플-사용-시-주의점"><a href="#튜플-사용-시-주의점" class="headerlink" title="튜플 사용 시 주의점"></a>튜플 사용 시 주의점</h3><p>튜플은 요소의 타입과 개수가 고정된 배열을 표현할 수 있는 타입이다. 따라서 아래와 같이 사용하면 에러가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Language = <span class="string">'JavaScript'</span> | <span class="string">'TypeScript'</span> | <span class="string">'Python'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLanguage</span>(<span class="params">language: Language</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Parameter is a (latitude, longitude) pair.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panTo</span>(<span class="params">where: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">panTo([<span class="number">10</span>, <span class="number">20</span>]) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loc = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">panTo(loc)</span><br><span class="line"><span class="comment">//    ~~~ Argument of type 'number[]' is not assignable to</span></span><br><span class="line"><span class="comment">//        parameter of type '[number, number]'</span></span><br></pre></td></tr></table></figure>
<p>loc로 선언하여서 타입이 number[]로 추론된다. 이는 길이를 알 수 없는 숫자의 배열이어서 <code>[10,20]</code>과 맞지 않는 수의 요소이기 때문에 튜플에 할당할 수 없다. 이 에러를 해결하는 방법은 다음과 같다.</p>
<ul>
<li>타입스크립트가 의도를 정확히 파악할 수 있도록 타입 선언 제공</li>
<li>상수 문맥 제공: as const로 값이 가리키는 참조와 그 값이 내부까지 상수임을 알려준다. 단 as const는 타입 정의에 실수가 있을 때 타입 정의가 아니라 호출되는 곳에서 에러가 발생해서 근본적인 원인을 찾기 어렵게 한다.</li>
<li>readonly의 사용</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Language = <span class="string">'JavaScript'</span> | <span class="string">'TypeScript'</span> | <span class="string">'Python'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLanguage</span>(<span class="params">language: Language</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Parameter is a (latitude, longitude) pair.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panTo</span>(<span class="params">where: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1️⃣ 타입 선언</span></span><br><span class="line"><span class="keyword">const</span> loc: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">panTo(loc) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ as const로 상수 문맥 제공 - 이 케이스에서는 에러발생</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panTo</span>(<span class="params">where: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> loc = [<span class="number">10</span>, <span class="number">20</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line">panTo(loc)</span><br><span class="line"><span class="comment">// ~~~ Type 'readonly [10, 20]' is 'readonly'</span></span><br><span class="line"><span class="comment">//     and cannot be assigned to the mutable type '[number, number]'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3️⃣ 타입 시그니처에 readonly 사용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panTo</span>(<span class="params">where: readonly [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> loc = [<span class="number">10</span>, <span class="number">20</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line">panTo(loc) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h3 id="객체-사용-시-주의점"><a href="#객체-사용-시-주의점" class="headerlink" title="객체 사용 시 주의점"></a>객체 사용 시 주의점</h3><p>객체 사용 시에도 에러를 발생시키는 문제가 생기는데 아래와 같은 방법으로 해결한다.</p>
<ul>
<li>타입 선언 추가</li>
<li>상수 단언(as const)사용</li>
</ul>
<h3 id="콜백-사용-시-주의점"><a href="#콜백-사용-시-주의점" class="headerlink" title="콜백 사용 시 주의점"></a>콜백 사용 시 주의점</h3><p>콜백을 다른 함수로 전달할 때 콜백의 매개변수 타입을 추론하기 위해 문맥을 사용한다. 그런데 아래 예시에서 fn으로 콜백을 상수로 뽑아내면 문맥이 소실되어 noImplicitAny오류가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callWithRandomNumbers</span>(<span class="params">fn: (n1: <span class="built_in">number</span>, n2: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  fn(<span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ~    Parameter 'a' implicitly has an 'any' type</span></span><br><span class="line">  <span class="comment">//    ~ Parameter 'b' implicitly has an 'any' type</span></span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line">callWithRandomNumbers(fn)</span><br><span class="line"></span><br><span class="line"><span class="comment">//해결방법</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line">callWithRandomNumbers(fn)</span><br></pre></td></tr></table></figure>
<p>해결방법은 아래와 같다.</p>
<ul>
<li>매개변수에 타입 구문을 추가한다.</li>
<li>가능하다면 전체 함수 표현식에 타입 선언</li>
</ul>
<hr>
<h2 id="아이템-27-함수형-기법과-라이브러리로-타입-흐름-유지하기"><a href="#아이템-27-함수형-기법과-라이브러리로-타입-흐름-유지하기" class="headerlink" title="아이템 27 함수형 기법과 라이브러리로 타입 흐름 유지하기"></a>아이템 27 함수형 기법과 라이브러리로 타입 흐름 유지하기</h2><p>로대시(lodash)와 같은 라이브러리의 일부 기능은 순수 자바스크립트로 구현되어 있고, 루프를 대체할 수 있기 때문에 유용하게 사용되고, 타입스크립트와 조합했을 때 더욱 유용하게 사용된다. <strong>타입 정보는 유지하면서 타입 흐름이 계속 전달되도록 하기 때문이다.</strong> 하지만 서드파티 라이브러리 기반으로 코드를 짧게 줄이는데 시간이 많이 든다면 사용하지 않는게 낫다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rows = rawRows</span><br><span class="line">  .slice(<span class="number">1</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">rowStr</span> =&gt;</span></span><br><span class="line">    rowStr</span><br><span class="line">      .split(<span class="string">','</span>)</span><br><span class="line">      .reduce(<span class="function">(<span class="params">row, val, i</span>) =&gt;</span> ((row[headers[i]] = val), row), &#123;&#125;)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">//lodash zipObject사용</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"><span class="keyword">const</span> rows = rawRows</span><br><span class="line">  .slice(<span class="number">1</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">rowStr</span> =&gt;</span> _.zipObject(headers, rowStr.split(<span class="string">','</span>)))</span><br></pre></td></tr></table></figure>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/07/220208_tsitem19to20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/07/220208_tsitem19to20/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 19 - 아이템 20</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-08 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-08T00:00:00+09:00">2022-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 13:09:35" itemprop="dateModified" datetime="2022-05-18T13:09:35+09:00">2022-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-19-추론-가능한-타입을-사용해-장황한-코드-방지하기"><a href="#아이템-19-추론-가능한-타입을-사용해-장황한-코드-방지하기" class="headerlink" title="아이템 19 추론 가능한 타입을 사용해 장황한 코드 방지하기"></a>아이템 19 추론 가능한 타입을 사용해 장황한 코드 방지하기</h2><p>타입스크립트가 결국 타입을 위한 언어이기 때문에 변수를 선언할 때마다 타입을 명시해야 한다고 생각하기 쉽다. <em>하지만 코드의 모든 변수에 타입을 선언하는 것은 비생산적이다.</em> 타입스크립트는 타입 추론이 된다면 명시적 타입 구문은 필요하지 않다. <code>let x = 12;</code>와 같은 구문은 x가 number로 추론되기 때문에 굳이 <code>let x: number = 12;</code>로 작성하지 않아도 되고, 객체와 배열에 대해서도 동일하다. 아래 예시에서 1️⃣은 2️⃣로 작성해도 동일하다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="keyword">const</span> person: &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  born: &#123;</span><br><span class="line">    where: <span class="built_in">string</span>;</span><br><span class="line">    when: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  died: &#123;</span><br><span class="line">    where: <span class="built_in">string</span>;</span><br><span class="line">    when: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  name: <span class="string">'Sojourner Truth'</span>,</span><br><span class="line">  born: &#123;</span><br><span class="line">    where: <span class="string">'Swartekill, NY'</span>,</span><br><span class="line">    when: <span class="string">'c.1797'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  died: &#123;</span><br><span class="line">    where: <span class="string">'Battle Creek, MI'</span>,</span><br><span class="line">    when: <span class="string">'Nov. 26, 1883'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sojourner Truth'</span>,</span><br><span class="line">  born: &#123;</span><br><span class="line">    where: <span class="string">'Swartekill, NY'</span>,</span><br><span class="line">    when: <span class="string">'c.1797'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  died: &#123;</span><br><span class="line">    where: <span class="string">'Battle Creek, MI'</span>,</span><br><span class="line">    when: <span class="string">'Nov. 26, 1883'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>때로는 추론이 더 정확할 때가 있는데, 아래의 경우 명시적으로 string이라고 타입을 준 것 보다 추론된 ‘y’가 사실은 더 정확하다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axis1: <span class="built_in">string</span> = <span class="string">'x'</span>; <span class="comment">// Type is string</span></span><br><span class="line"><span class="keyword">const</span> axis2 = <span class="string">'y'</span>; <span class="comment">// Type is "y"</span></span><br></pre></td></tr></table></figure>
<p>아래 예시에서 Product의 id를 number라고 작성했다가 나중에 문자도 있을 수 있다는 것을 알게되어 string으로 작성했다고 가정해보자. 이 경우 선언된 타입과 함수 내의 타입이 일치하지 않아서 오류를 발생시킨다. 만약 여기서 명시적 타입 구문이 없었다면 문제없이 타입 체커를 통과했을 것이다. 그래서 이런 경우에는 비구조 할당문으로 구현하는 것이 더 나은 선택이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Product &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProduct</span>(<span class="params">product: Product</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id: <span class="built_in">number</span> = product.id;</span><br><span class="line">  <span class="comment">// ~~ Type 'string' is not assignable to type 'number'</span></span><br><span class="line">  <span class="keyword">const</span> name: <span class="built_in">string</span> = product.name;</span><br><span class="line">  <span class="keyword">const</span> price: <span class="built_in">number</span> = product.price;</span><br><span class="line">  <span class="built_in">console</span>.log(id, name, price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//비구조 할당 - 여기에 추가로 명시적 타입 구문을 넣는 것은 불필요하다.</span></span><br><span class="line"><span class="keyword">interface</span> Product &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProduct</span>(<span class="params">product: Product</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; id, name, price &#125; = product;</span><br><span class="line">  <span class="built_in">console</span>.log(id, name, price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>그러나 정보가 부족해서 타입스크립트가 스스로 판단하기 어려운 경우에는 명시적 타입 구문이 필요하다.</strong> 위 예제에서 logProduct 함수에서 매개밴수의 타입을 Product로 명시한 경우가 그 예이다. 이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역변수에는 타입 구문을 넣지 않는 것이다. 단, 기본값이 있는 경우에는 타입 구문을 생략하기도 한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseNumber</span>(<span class="params">str: <span class="built_in">string</span>, base = 10</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>타입이 추론될 수 있음에도 타입을 명시하고 싶은 경우가 있다. 객체 리터럴의 정의과 함수의 반환 타입을 명시할 때이다.</p>
<h3 id="객체-리터럴의-정의"><a href="#객체-리터럴의-정의" class="headerlink" title="객체 리터럴의 정의"></a>객체 리터럴의 정의</h3><p>객체 리터럴에서 타입을 명시하면 잉여 속성 체크가 동작해서 실제로 실수가 방생한 부분에 정확하게 오류를 표시해 줄 수 있다. 아래 예시에서 타입 구문을 제거하면 잉여 속성 체크가 동작하지 않아서 실제 오류가 발생한 id쪽이 아니라 객체가 사용되는 곳에서 오류가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Product &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProduct</span>(<span class="params">product: Product</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id: <span class="built_in">number</span> = product.id;</span><br><span class="line">  <span class="comment">// ~~ Type 'string' is not assignable to type 'number'</span></span><br><span class="line">  <span class="keyword">const</span> name: <span class="built_in">string</span> = product.name;</span><br><span class="line">  <span class="keyword">const</span> price: <span class="built_in">number</span> = product.price;</span><br><span class="line">  <span class="built_in">console</span>.log(id, name, price);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> furby: Product = &#123;</span><br><span class="line">  name: <span class="string">'Furby'</span>,</span><br><span class="line">  id: <span class="number">630509430963</span>,</span><br><span class="line">  <span class="comment">// ~~ Type 'number' is not assignable to type 'string'</span></span><br><span class="line">  price: <span class="number">35</span>,</span><br><span class="line">&#125;;</span><br><span class="line">logProduct(furby);</span><br></pre></td></tr></table></figure>
<h3 id="함수의-반환"><a href="#함수의-반환" class="headerlink" title="함수의 반환"></a>함수의 반환</h3><p>타입 추론이 가능한 경우에도 구현상의 오류가 함수를 호출한 곳까지 영향을 미치지 않도록 하기 위함이다. 반환 타입을 명시하면 구현상의 오류가 사용자 코드의 오류로 표시되지 않고, 오류의 위치를 제대로 표시해준다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache: &#123; [ticker: <span class="built_in">string</span>]: <span class="built_in">number</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQuote</span>(<span class="params">ticker: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//getQuote가 반환하는 것은 Promise.resolve(cache[ticker])이어야 한다.</span></span><br><span class="line">  <span class="comment">//따라서 여기에서 아래와 같은 오류가 발생해야 한다.</span></span><br><span class="line">  <span class="comment">//~~~~~~~~~~~~~ Type 'number' is not assignable to 'Promise&lt;number&gt;'</span></span><br><span class="line">  <span class="comment">//하지만 실제 오류는 가장 아래 getQuote를 호출한 코드에서 발생한다.</span></span><br><span class="line">  <span class="keyword">if</span> (ticker <span class="keyword">in</span> cache) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[ticker];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">`https://quotes.example.com/?q=<span class="subst">$&#123;ticker&#125;</span>`</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function">(<span class="params">quote</span>) =&gt;</span> &#123;</span><br><span class="line">      cache[ticker] = quote;</span><br><span class="line">      <span class="keyword">return</span> quote;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">considerBuying</span>(<span class="params">x: <span class="built_in">any</span></span>) </span>&#123;&#125;</span><br><span class="line">getQuote(<span class="string">'MSFT'</span>).then(considerBuying);</span><br><span class="line"><span class="comment">// ~~~~ Property 'then' does not exist on type</span></span><br><span class="line"><span class="comment">//        'number | Promise&lt;any&gt;'</span></span><br><span class="line"><span class="comment">//      Property 'then' does not exist on type 'number'</span></span><br></pre></td></tr></table></figure>
<p>그 외에도 반환타입을 명시하는 것은 아래 두 가지 장점이 있다.</p>
<ul>
<li><code>함수를 더욱 명확하게 알기 쉽다.</code> 반환 타입을 명시하려면 입력, 출력 타입에 대해 알아야 하고 미리 명시해야만 하기 때문에 타입을 미리 작성하여 구현이 맞추어 주먹구구식으로 타입이 작성되는 것이 아닌 테스트 주도 개발처럼 작성할 수 있게 된다.</li>
<li><code>명명된 타입을 사용할 수 있다.</code> 반환 타입을 명시하면 더욱 직관적인 표현이 되고, 반환 값을 별도의 타입으로 정의하면 타입에 대한 주석을 작설항 수 있어 함수에 대해 더 자세히 설명하게 된다.</li>
</ul>
<hr>
<h2 id="아이템-20-다른-타입에는-다른-변수-사용하기"><a href="#아이템-20-다른-타입에는-다른-변수-사용하기" class="headerlink" title="아이템 20 다른 타입에는 다른 변수 사용하기"></a>아이템 20 다른 타입에는 다른 변수 사용하기</h2><p>자바스크립트에서는 한 변수를 다른 목적을 가지는 다른 타입으로 재사용해도 되는데, 타입스크립트에서는 이렇게 사용하면 두 가지 오류가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//자바스크립트</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="string">'12-34-56'</span>;</span><br><span class="line">fetchProduct(id); <span class="comment">//string으로 사용</span></span><br><span class="line"></span><br><span class="line">id = <span class="number">123456</span>;</span><br><span class="line">fetchProductBySerialNumber(id); <span class="comment">//number로 사용</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//타입스크립트</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProduct</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProductBySerialNumber</span>(<span class="params">id: <span class="built_in">number</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> id = <span class="string">'12-34-56'</span>;</span><br><span class="line">fetchProduct(id);</span><br><span class="line"></span><br><span class="line">id = <span class="number">123456</span>;</span><br><span class="line"><span class="comment">// ~~ '123456' is not assignable to type 'string'.</span></span><br><span class="line">fetchProductBySerialNumber(id);</span><br><span class="line"><span class="comment">// ~~ Argument of type 'string' is not assignable to</span></span><br><span class="line"><span class="comment">//    parameter of type 'number'</span></span><br></pre></td></tr></table></figure>
<p>여기서 중요한 점은 <strong>변수의 값은 바뀔 수 있지만 타입은 바뀌지 않는다.</strong>는 점이다. 범위를 좁히는 방법으로 타입을 바꿀 수는 있지만 그것은 새로운 변수값을 포함하도록 확장하는 것이 아니라 타입을 더 작게 제한하는 것이다.</p>
<h3 id="유니온-타입을-이용한-타입의-확장"><a href="#유니온-타입을-이용한-타입의-확장" class="headerlink" title="유니온 타입을 이용한 타입의 확장"></a>유니온 타입을 이용한 타입의 확장</h3><p>id가 string, number를 모두 포함할 수 있도록 타입을 확장하는 유니온을 통해 아래와 같이 작성하면 에러는 해결된다. 하지만 이렇게 작성하면 매번 id값이 string인지 number인지 확인해야 하기 때문에 이런 경우에는 별도의 변수로 작성하는 것이 낫다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProduct</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProductBySerialNumber</span>(<span class="params">id: <span class="built_in">number</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> id: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">'12-34-56'</span>;</span><br><span class="line">fetchProduct(id);</span><br><span class="line"></span><br><span class="line">id = <span class="number">123456</span>; <span class="comment">// OK</span></span><br><span class="line">fetchProductBySerialNumber(id); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//유니온 타입 대신 별도의 변수로 작성</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProduct</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProductBySerialNumber</span>(<span class="params">id: <span class="built_in">number</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> id = <span class="string">'12-34-56'</span>;</span><br><span class="line">fetchProduct(id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serial = <span class="number">123456</span>; <span class="comment">// OK</span></span><br><span class="line">fetchProductBySerialNumber(serial); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>무엇보다 변수를 재사용하는 방식은 타입 체커는 물론 사람에게도 혼란을 주기 때문에 지양해야 한다. 타입이 다른 경우 별도의 변수를 사용하는 것이 바람직한 이유는 다음과 같다.</p>
<ul>
<li>서로 관련이 없는 두 개의 값을 분리한다.</li>
<li>변수명을 더 구체적으로 지을 수 있다.</li>
<li>타입 추론을 향상시키며, 타입 구문이 불필요해진다.</li>
<li>타입이 간결해진다.</li>
<li>let 대신 const로 변수를 선언하게 된다. 이렇게 하면 코드가 간결하고, 타입 체커의 타입 추론이 용이하다.</li>
</ul>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/06/220207_userAgent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/06/220207_userAgent/" class="post-title-link" itemprop="url">사용자 에이전트 (User Agent)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-07T00:00:00+09:00">2022-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 13:09:35" itemprop="dateModified" datetime="2022-05-18T13:09:35+09:00">2022-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>사용자를 대표하는 컴퓨터 프로그램, 웹에서는 <code>브라우저</code>를 의미하고, 웹 페이지를 긁어가는 봇, 다운로드 관리자, 웹에 접근하는 다른앱 등이 있다.</p>
</blockquote>
<ul>
<li>브라우저는 서버에 보내는 모든 요청에 <code>User-Agent HTTP(사용자 에이전트 문자열) 헤더</code>를 보낸다.</li>
<li>여기에는 브라우저 종류, 버전 번호, 호스트 운영체제를 포함하는 브라우저 정보가 담겨있다.</li>
<li>클라이언트에서 JS의 <code>navigator.userAgent</code> 속성으로 사용자 에이전트 문자열에 접근할 수 있다.</li>
</ul>
<hr>
<h2 id="user-agent를-이용한-브라우저-감지"><a href="#user-agent를-이용한-브라우저-감지" class="headerlink" title="user agent를 이용한 브라우저 감지"></a>user agent를 이용한 브라우저 감지</h2><p><em>웹은 유저가 어떤 브라우저, 어떤 디바이스를 사용하고 있는지와 관계없이 모두에게 접근성이 용이해야 한다.</em> 하지만 브라우저와 웹 표준이 완벽하지 않기 때문에 몇 가지 edge case가 존재하여 브라우저 감지를 필요로 한다. <strong>user agent를 사용하여 브라우저를 감지하는 것은 간단하지만 그것을 잘하기는 매우 어려운 문제이다.</strong></p>
<h2 id="브라우저-감지-전에-고려해야할-점"><a href="#브라우저-감지-전에-고려해야할-점" class="headerlink" title="브라우저 감지 전에 고려해야할 점"></a>브라우저 감지 전에 고려해야할 점</h2><blockquote>
<p>웬만하면 user agent를 사용한 브라우저 감지를 하지 않는 것이 우선이다. 하지만 그럼에도 불구하고 필요하다고 판단된다면 아래 질문에 근거하여 <em>정말로 내가 왜 그 기능을 필요로 하는가를 고려해보도록 한다.</em></p>
</blockquote>
<ul>
<li>특정 브라우저 버전에 있는 버그를 고치려고 하는가?<ul>
<li>포럼에서 버그를 찾아보고, 처음 발견한 버그라면 질문해보도록 한다. 만약 정상적이지 않은 문제로 보인다면 브라우저 제공자의 버그 추척 시스템(<a href="https://bugzilla.mozilla.org/" target="_blank" rel="noopener">Mozilla</a>, <a href="https://bugs.webkit.org/" target="_blank" rel="noopener">WebKit</a>, <a href="https://www.chromium.org/issue-tracking/" target="_blank" rel="noopener">Blink</a>, <a href="https://bugs.opera.com/login.jsp" target="_blank" rel="noopener">Opera</a>)에 보고된 버그인지 확인해본다.</li>
</ul>
</li>
<li>특정 기능의 존재 여부를 체크하려고 하는가?<ul>
<li>몇몇 브라우저에서 지원하지 않는 기능을 사이트에서 사용하고자 할 때, 그 유저들을 기능은 더 적지만 작동할 것임이 분명한 옛 버전의 웹 사이트로 보내고 싶을텐데, 결국에는 언젠가 해당 브라우저에서 그 기능이 동작할 것임을 알고 있는 상황이다. 이런 상황이 user agent를 이용한 브라우저 감지를 사용하는 가장 나쁜 케이스인데, 몇몇 브라우저에서 지원하지 않는 기능들도 결국에는 지원하는 방향이 될 것이기 때문이다. 또한 비교적 인기가 덜한 브라우저의 웹 기능까지 모두 테스트하는 것은 실용적이지 않다. 이런 경우에는 user agent를 사용한 탐지를 절대 피해야 한다. 언제나 기능을 탐지할 수 있는 대안이 존재하기 때문이다.</li>
</ul>
</li>
<li>사용하는 브라우저에 따라 다른 HTML을 제공해야 하는가?<ul>
<li>보통 이런 것은 나쁜 방법이지만 필요한 경우가 있다. 필요에 의해 사용해야 한다면 <em>먼저 정말로 이렇게 해야하는지 당신이 처한 상황에 대해 분석해보아야 한다.</em> non-semantic 요소인 <code>&lt;div&gt;, &lt;span&gt;</code> 등을 추가하여 피할 수 있는 방법이 있을까? user Agent 감지를 성공적으로 하는 것의 어려움은 HTML의 순수성을 혼란스럽게 할 수 있다. 또한 디자인에 대해 다시 생각해보아야 한다. 브라우저별로 다른 HTML을 사용할 필요성을 없애기 위해 점진적 향상을 고려하거나 가변 레이아웃(fluid layouts)를 사용할 수 있는가?</li>
</ul>
</li>
</ul>
<h2 id="user-agent-사용을-대신할-방법"><a href="#user-agent-사용을-대신할-방법" class="headerlink" title="user agent 사용을 대신할 방법"></a>user agent 사용을 대신할 방법</h2><h3 id="모바일-장치-감지"><a href="#모바일-장치-감지" class="headerlink" title="모바일 장치 감지"></a>모바일 장치 감지</h3><p>틀림없이 user agent의 가장 흔한 사용 및 오용은 디바이스가 모바일 디바이스인지 여부를 감지하는 것이다. 그러나 사람들은 정말로 해야하는 것이 무엇인지 간과하기 쉽다. 사람들은 user agent를 사용해서 유저의 디바이스가 터치 친화적(touch-friendly)인지 작은 스크린에서도 그에 따라 웹사이트를 최적화할 수 있는지 여부를 감지한다. user agent가 때때로 이런 것을 감지할 수 있지만 모든 디바이스에 대해 동일한 것은 아니다. 일부 모바일 장치는 큰 스크린을 가진 경우가 있고, 일부 데스크톱은 작은 터치스크린을 가진 경우가 있다. 어떤 사람은 smart TV를 쓰기도 하고, 또 어떤 사람들은 태블릿을 옆으로 움직여서 화면의 높이와 너비를 동적으로 변경할 수도 있다. 그러므로 user agent의 사용은 확실히 올바른 방법은 아니다. 그리고 더 좋은 대안이 있다.<br><code>Navigator.maxTouchPoints</code>을 사용해서 유저가 터치스크린을 가졌는지 여부를 감지한다. 그런 다음 <code>if (!(&quot;maxTouchPoints&quot; in Navigator)) { /*Code here*/}.</code>한 경우에만 기본적으로(default) user agent 화면을 확인한다. 이 정보를 통해 어떤 디바이스가 터치스크린을 가졌는지 여부를 확인하고, 이를 사용해서 전체 레이아웃을 변경하지 않고 오직 터치 스크린일 경우에 대해서만 특정 작업을 더 만들거나 유지 관리를 할 수 있다. 예를 들어, 좀 더 크고, 클릭하기 쉬운 버튼과 같은 touch 편의성(convenience)을 추가한다. 이를 위해서 스크린 사이즈에 따라 단순하게 <code>window.innerWidth</code>와 <code>window.addEventListener(&quot;resize&quot;, function(){ /_refresh screen size dependent things_/ }).</code>를 사용하면 된다. 스크린 사이즈를 위해 해야하는 일은 작은 화면에서 보여줘야할 정보를 줄이는 것이 아니다. 이런 방법은 사람들에게 데스크톱 버전을 사용하도록 강제하는 것이기 때문에 짜증만 날 뿐이다. 이보다는 작은 스크린의 긴 페이지에서는 더 적은 열(columns)의 정보를 갖도록 하고, 더 큰 스크린의 짧은 페이지에서는 더 많은 열(cloumns)를 갖도록 한다. 이러한 효과는 CSS flexbox를 이용해서 쉽게 얻을 수 있다. 그리고 항상 코드를 동적으로 만들어야 한다. 유저는 모바일 디바이스를 옆으로 움직여서 페이지의 너비와 높이를 바꿀 수 있다. 그렇기 때문에 웹 페이지가 부드럽고 유동적이며 동적으로 크카가 조정되는 동안 개발자 도구를 열어서 화면 크기를 조정할 수 있을 때까지 웹 페이지에 만족하지 않도록 한다.</p>
<hr>
<p><em>References</em><br><a href="https://developer.mozilla.org/en-US/docs/Glossary/User_agent" target="_blank" rel="noopener">User agent</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent" target="_blank" rel="noopener">Browser detection using the user agent</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/01/220202_tsitem10to18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/01/220202_tsitem10to18/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 10 - 아이템 18</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-02T00:00:00+09:00">2022-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 13:09:35" itemprop="dateModified" datetime="2022-05-18T13:09:35+09:00">2022-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-10-객체-래퍼-타입-피하기"><a href="#아이템-10-객체-래퍼-타입-피하기" class="headerlink" title="아이템 10 객체 래퍼 타입 피하기"></a>아이템 10 객체 래퍼 타입 피하기</h2><h3 id="자바스크립트의-타입"><a href="#자바스크립트의-타입" class="headerlink" title="자바스크립트의 타입"></a>자바스크립트의 타입</h3><blockquote>
<p>기본형 값들에 대한 일곱가지 타입 (string, number, boolean, null, undefined, symbol(ES2015에서 추가), bigint(최종 확정 단계))<br>객체</p>
</blockquote>
<p><strong>기본형은 불변이며, 메서드를 가지지 않는다.</strong> 그런데 기본형인 string이 메서드를 가진 것처럼 보이는 이유는 자바스크립트에 메서드를 가지는 <code>String 객체 타입</code>이 정의되어 있기 때문이다. 만약 charAt과 같은 메서드를 기본형에 사용한다면 기본형을 String 객체로 래핑하여 메서드를 호출한 후 마지막에 래핑한 객체를 버리는 방식으로 작동된다. null과 undefined를 제외한 모든 기본형에 이와 같은 객체 래퍼 타입이 존재한다. 이러한 래퍼 객체는 직접 생성할 필요가 없고, 기본형을 사용해야하는데 래퍼 객체를 사용하지 않도록 주의하여야 한다. <strong>타입스크립트가 제공하는 타입 선언은 전부 기본형 타입이다.</strong> 다만 기본형 타입은 객체 래퍼에 할당할 수 있기 때문에 타입스크립트는 기본형 타입을 객체 래퍼에 할당하는 것을 허용한다. 그러나 이런 방법은 오해하기 쉽고 이렇게 쓰지 않는 것이 좋다.</p>
<hr>
<h2 id="아이템-11-잉여-속성-체크의-한계-인지하기"><a href="#아이템-11-잉여-속성-체크의-한계-인지하기" class="headerlink" title="아이템 11 잉여 속성 체크의 한계 인지하기"></a>아이템 11 잉여 속성 체크의 한계 인지하기</h2><p>타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지, <strong>그 외의 속성은 없는지</strong> 확인한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ 잉여 속성 체크</span></span><br><span class="line"><span class="keyword">interface</span> Room &#123;</span><br><span class="line">  numDoors: <span class="built_in">number</span>;</span><br><span class="line">  ceilingHeightFt: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> r: Room = &#123;</span><br><span class="line">  numDoors: <span class="number">1</span>,</span><br><span class="line">  ceilingHeightFt: <span class="number">10</span>,</span><br><span class="line">  elephant: <span class="string">'present'</span>,</span><br><span class="line">  <span class="comment">// ~~~~~~~~~~~~~~~~~~ Object literal may only specify known properties,</span></span><br><span class="line">  <span class="comment">//                    and 'elephant' does not exist in type 'Room'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">interface</span> Room &#123;</span><br><span class="line">  numDoors: <span class="built_in">number</span>;</span><br><span class="line">  ceilingHeightFt: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  numDoors: <span class="number">1</span>,</span><br><span class="line">  ceilingHeightFt: <span class="number">10</span>,</span><br><span class="line">  elephant: <span class="string">'present'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> r: Room = obj; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>1️⃣ 의 샘플코드는 <code>잉여 속성 체크</code>가 수행되었다. 구조적 타입 시스템에서 발생할 수 있는 중요한 오류를 잡을 수 있도록 한다. 1️⃣ 의 샘플코드는 <em>구조적 타입</em>의 관점에서 생각해보면 elephant 속성이 있어도 오류가 발생하지 않아야 하지만, 오류가 발생했다. 이처럼 잉여 속성 체크를 사용하면 타입 시스템의 구조적 본질을 해치치 않으면서도 객체 리터럴에 알 수 없는 속성을 허용하지 않음으로써 문제의 발생을 방지 할 수 있다. 단, 조건에 따라 동작하지 않을 수 있고, 통상적인 할당 가능 검사와 함께 쓰이면 구조적 타이핑이 무엇인지 혼란스러워 진다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Room &#123;</span><br><span class="line">  numDoors: <span class="built_in">number</span>;</span><br><span class="line">  ceilingHeightFt: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDarkMode</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  darkMode?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> intermediate = &#123; darkmode: <span class="literal">true</span>, title: <span class="string">'Ski Free'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> o: Options = intermediate; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o2 = &#123; darkmode: <span class="literal">true</span>, title: <span class="string">'Ski Free'</span> &#125; <span class="keyword">as</span> Options; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>위 예시에서 intermediate 변수의 오른쪽은 객체 리터럴이지만 o변수의 intermediate는 객체 리터럴이 아니다. 타입 구문이 없는 임시 변수이다. 이 경우 잉여 속성 체크가 적용되지 않아서 오류가 사라진다. 위의 예시에서 o2와 같이 타입 단언을 사용해도 잉여 속성 체크는 적용되지 않는다. 아래 예시처럼 선택적 속성만 가지는 약한 타입에도 비슷한 체크가 동작한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> LineChartOptions &#123;</span><br><span class="line">  logscale?: <span class="built_in">boolean</span>;</span><br><span class="line">  invertedYAxis?: <span class="built_in">boolean</span>;</span><br><span class="line">  areaChart?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; logScale: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> o: LineChartOptions = opts;</span><br><span class="line"><span class="comment">// ~ Type '&#123; logScale: boolean; &#125;' has no properties in common</span></span><br><span class="line"><span class="comment">//   with type 'LineChartOptions'</span></span><br></pre></td></tr></table></figure>
<p>위 예시에서 LineChartOptions 타입은 모든 속성이 선택적이므로 모든 객체를 포함할 수 있는 약한 타입이다. 이 경우 타입스크립트가 값 타입과 선언 타입에 공통된 속성이 있는지 확인하는 별도의 체크를 수행한다. 오타를 잡는데 효과적이며 구조적으로 엄격하지 않지만 잉여 속성 체크와 다른 점은 약한 타입과 관련된 할당문마다 수행된다는 점이다. 따라서 임시 변수를 제거하더라도 공통 속성 체크는 여전히 동작한다.</p>
<hr>
<h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL; DR"></a>TL; DR</h3><ul>
<li>객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 체크 속성이 수행된다.</li>
<li>잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이 다르다. 할당의 개념을 정확히 알아야 잉여 속성 체크와 일반적인 구조적 할당 가능성 체크를 구분할 수 있다.</li>
<li>잉여 속성 체크에는 한계가 있다. 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다.</li>
</ul>
<h2 id="아이템-12-함수-표현식에-타입-적용하기"><a href="#아이템-12-함수-표현식에-타입-적용하기" class="headerlink" title="아이템 12 함수 표현식에 타입 적용하기"></a>아이템 12 함수 표현식에 타입 적용하기</h2><p>자바스크립트에서는 함수 문장(statement)와 함수 표현식(expression)을 다르게 인식한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rollDice1</span>(<span class="params">sides: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* COMPRESS */</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* END */</span></span><br><span class="line">&#125; <span class="comment">// Statement</span></span><br><span class="line"><span class="keyword">const</span> rollDice2 = <span class="function"><span class="keyword">function</span> (<span class="params">sides: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* COMPRESS */</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* END */</span></span><br><span class="line">&#125;; <span class="comment">// Expression</span></span><br><span class="line"><span class="keyword">const</span> rollDice3 = (sides: number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* COMPRESS */</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* END */</span></span><br><span class="line">&#125;; <span class="comment">// Also expression</span></span><br></pre></td></tr></table></figure>
<p>타입스크립트에서는 <code>함수 표현식</code>을 사용하는 것이 좋다. 그 이유는 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있기 때문이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ 사칙연산을 하는 함수 - 함수의 매개변수에 타입 선언</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ 함수 시그니처를 하나의 함수 타입으로 통합 - 함수 표현식 전체 타입을 정의</span></span><br><span class="line"><span class="keyword">type</span> BinaryFn = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">const</span> add: BinaryFn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">const</span> sub: BinaryFn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b;</span><br><span class="line"><span class="keyword">const</span> mul: BinaryFn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * b;</span><br><span class="line"><span class="keyword">const</span> div: BinaryFn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a / b;</span><br></pre></td></tr></table></figure>
<p>1️⃣ 에 비해 2️⃣ 가 코드가 간결하고 안전하다.</p>
<hr>
<h2 id="아이템-13-타입과-인터페이스-차이점-알기"><a href="#아이템-13-타입과-인터페이스-차이점-알기" class="headerlink" title="아이템 13 타입과 인터페이스 차이점 알기"></a>아이템 13 타입과 인터페이스 차이점 알기</h2><p>타입스크립트에서 명명된 타입을 정의하는 방법은 아래와 같이 <code>type</code>, <code>interface</code>의 두 가지 방법이 있다. 대부분의 경우 둘 중 어떤 것을 사용해도 상관없지만 <strong>두 가지 타입이 가지는 차이점을 명확히 알고 사용해야 한다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TState = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type-interface의-비슷한-점"><a href="#type-interface의-비슷한-점" class="headerlink" title="type, interface의 비슷한 점"></a><code>type</code>, <code>interface</code>의 비슷한 점</h3><ul>
<li>명명된 타입은 <code>type</code>, <code>interface</code> 둘 중 어떤 것으로 정의하든 상태에 차이가 없지만, <strong>추가 속성과 함께 할당하려고 하면 오류가 발생한다.</strong></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//예제코드에서 type은 T, interface는 I를 접두사로 사용했는데,</span></span><br><span class="line"><span class="comment">//이해를 돕기 위함이며, 실제코드에서는 이렇게 사용하지 않도록 한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TState = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wyoming: TState = &#123;</span><br><span class="line">  name: <span class="string">'Wyoming'</span>,</span><br><span class="line">  capital: <span class="string">'Cheyenne'</span>,</span><br><span class="line">  population: <span class="number">500</span>_000,</span><br><span class="line">  <span class="comment">// ~~~~~~~~~~~~~~~~~~ Type ... is not assignable to type 'TState'</span></span><br><span class="line">  <span class="comment">//                    Object literal may only specify known properties, and</span></span><br><span class="line">  <span class="comment">//                    'population' does not exist in type 'TState'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>인덱스 시그니처의 사용이 가능하다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TDict = &#123; [key: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">interface</span> IDict &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>함수 타입도 정의할 수 있고, 제너릭이 가능하다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TFn = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">interface</span> IFn &#123;</span><br><span class="line">  (x: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//단순한 함수 타입에서는 타입 별칭이 더 나은 선택일 수 있다.</span></span><br><span class="line"><span class="keyword">const</span> toStrT: TFn = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="string">''</span> + x; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> toStrI: IFn = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="string">''</span> + x; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<ul>
<li>타입을 확장할 수 있다. 단 interface는 주의사항이 몇 가지 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TState = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IStateWithPop <span class="keyword">extends</span> TState &#123;</span><br><span class="line">  population: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface는 유니온 타입과 같은 복잡한 타입을 확장하지 못한다.</span></span><br><span class="line"><span class="comment">// 확장하려면 아래와 같이 타입과 &amp;을 사용해야 한다.</span></span><br><span class="line"><span class="keyword">type</span> TStateWithPop = IState &amp; &#123; population: <span class="built_in">number</span> &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>class를 사용하면 type, interface 모두 사용 가능.</li>
</ul>
<h3 id="type-interface의-다른-점"><a href="#type-interface의-다른-점" class="headerlink" title="type, interface의 다른 점"></a><code>type</code>, <code>interface</code>의 다른 점</h3><ul>
<li>interface는 타입을 확장할 수 있고, 유니온은 할 수 없다. 유니온 타입은 있지만 유니온 인터페이스라는 개념은 없다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Input = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> Output = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input 타입과 Output 타입은 별도의 타입인데, VariableMap interface를 만들 수 있다.</span></span><br><span class="line"><span class="keyword">interface</span> VariableMap &#123;</span><br><span class="line">  [name: <span class="built_in">string</span>]: Input | Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//아래와 같이 유니온 타입에 name 속성을 붙인 타입을 만들 수도 있다.</span></span><br><span class="line"><span class="comment">//이 타입은 interface로 표현할 수 없다.</span></span><br><span class="line"><span class="keyword">type</span> NamedVariable = (Input | Output) &amp; &#123; name: <span class="built_in">string</span> &#125;;</span><br></pre></td></tr></table></figure>
<p><code>type</code> 키워드는 interface보다 쓰임새가 많은데, 유니온이 될 수도 있고, 매핑된 타입 또는 조건부 타입 같은 고급 기능에도 활용된다. 튜플과 배열 타입을 표현하는 것도 용이하다. interface로 튜플과 비슷하게 구현할 수 있지만 concat과 같은 메서드를 사용할 수 없다.</p>
<ul>
<li>interface는 보강이 가능하고, type은 그렇지 않다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  population: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wyoming: IState = &#123;</span><br><span class="line">  name: <span class="string">'Wyoming'</span>,</span><br><span class="line">  capital: <span class="string">'Cheyenne'</span>,</span><br><span class="line">  population: <span class="number">500</span>_000,</span><br><span class="line">&#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>위 예제에서 속싱이 확장되었는데 이를 <code>선언 병합(declaration merging)</code>라고 한다. 선언 병합은 주로 타입 선언 파일에 사용횐다. <em>즉 타입 선언 파일을 작성할 때는 선언 병합을 지원하기 위해 반드시 interface를 사용해야 한다.</em></p>
<h3 id="type-interface를-언제-써야하는가"><a href="#type-interface를-언제-써야하는가" class="headerlink" title="type, interface를 언제 써야하는가?"></a><code>type</code>, <code>interface</code>를 언제 써야하는가?</h3><ul>
<li>타입 선언 파일 뿐 아니라 일반적인 코드에서도 병합이 지원된다. 따라서 보강이 있는 경우는 interface, 기존 타입에 추가 보강이 없는 경우는 type을 쓴다.</li>
<li>복잡한 타입은 타입 별칭을 사용한다.</li>
<li>type, interface 두 가지 모두로 표현할 수 있는 간단한 객체 타입이라면?<ul>
<li>일관성과 보강의 관점을 고려해 본다.</li>
<li>코드베이스에서 일관되게 type을 쓰고 있다면 type을, interface를 쓰고 있다면 interface를 쓴다.</li>
<li>API에 대한 타입 선언은 API가 변경될 때 사용자가 interface를 통해 새로운 필드를 병합할 수 있으니 interface를 쓴다. 단, 프로젝트 내부적으로 사용되는 타입에 선언 병합이 발생하는 것은 잘못된 설계이며, 이럴 때는 type을 쓴다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="아이템-14-타입-연산과-제너릭-사용으로-반복-줄이기"><a href="#아이템-14-타입-연산과-제너릭-사용으로-반복-줄이기" class="headerlink" title="아이템 14 타입 연산과 제너릭 사용으로 반복 줄이기"></a>아이템 14 타입 연산과 제너릭 사용으로 반복 줄이기</h2><p>코드를 작성할 때 코드를 반복하지 말라는 DRY(don’t repeat yourself)원칙에 따라 코드 중복을 제거하려고 노력하는 사람도 타입에 대해 간과하기 쉽다. 그 이유는 중복을 제거하는 매커니즘이 기존 코드에 대해 행하던 것에 비해 익숙치 않기 때문이다. 그러나 타입의 중복도 많은 문제를 일으키기 때문에 중복을 최소화해야 한다.</p>
<h3 id="반복을-줄이는-방법"><a href="#반복을-줄이는-방법" class="headerlink" title="반복을 줄이는 방법"></a>반복을 줄이는 방법</h3><ul>
<li><code>타입에 이름을 붙인다.</code> 아래 예시에서 파라미터 a, b에 반복되는 타입인 <code>{ x: number; y: number }</code>은 Point2D interface로 이름을 붙여서 중복을 제거하였다. 몇몇 함수가 같은 타입 시그니처를 공유한다고 할 때도 해당 시그니처를 명명된 타입으로 본리할 수 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">a: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;, b: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(a.x - b.x, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">a: Point2D, b: Point2D</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>interface를 사용할 경우, 한 interface가 다른 interface를 확장하게 해서 반복을 제거한다.</code></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  lastName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PersonWithBirthDate <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  birth: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>이미 존재하는 타입을 확장한다면 intersection 연산자(&amp;)을 쓴다.</code> 단, 일반적이지는 않다. 주로 확장할 수 없는 유니온 타입에 속성을 추가하려고 할 때 유용한 방법이다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  lastName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PersonWithBirthDate = Person &amp; &#123; birth: <span class="built_in">Date</span> &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>매핑된 타입</code>을 사용한다.<br>아래 예시에서 State는 전체 어플리케이션의 상태, TopNavState는 부분만 표현하는 상태라고 하고, 어떻게 매핑된 타입을 사용하는지 살펴보자. TopNavState를 확장해서 State를 구성할 수도 있지만, 의미상 State의 TopNavState를 정의하는 것이 바람직 할 것이다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">  userId: <span class="built_in">string</span>;</span><br><span class="line">  pageTitle: <span class="built_in">string</span>;</span><br><span class="line">  recentFiles: <span class="built_in">string</span>[];</span><br><span class="line">  pageContents: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> TopNavState &#123;</span><br><span class="line">  userId: <span class="built_in">string</span>;</span><br><span class="line">  pageTitle: <span class="built_in">string</span>;</span><br><span class="line">  recentFiles: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>아래 예시에서 1️⃣은 의미상 TopNavState를 State의 부분 집합이 되도록 작성하기 위해 State를 인덱싱해서 속성의 타입에 중복을 제거하였다. 이렇게 하면 State에 있는 속성의 타입이 바뀌더라도 잘 반영된다. 하지만 여전히 반복되는 코드가 있기 때문에 <strong>2️⃣와 같이 매핑된 타입을 사용한다.</strong> 매핑된 타입은 배열의 필드를 루프 도는 것과 같은 방식이다. 표준 라이브러리에서는 <code>Pick</code>이라 한다. Pick은 제너릭 타입이며, 3️⃣과 같이 사용한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ - 인덱싱하여 중복제거</span></span><br><span class="line"><span class="keyword">type</span> TopNavState = &#123;</span><br><span class="line">  userId: State[<span class="string">'userId'</span>];</span><br><span class="line">  pageTitle: State[<span class="string">'pageTitle'</span>];</span><br><span class="line">  recentFiles: State[<span class="string">'recentFiles'</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ - 매핑된 타입 사용</span></span><br><span class="line"><span class="keyword">type</span> TopNavState = &#123;</span><br><span class="line">  [k <span class="keyword">in</span> <span class="string">'userId'</span> | <span class="string">'pageTitle'</span> | <span class="string">'recentFiles'</span>]: State[k];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3️⃣ - Pick 사용</span></span><br><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123; [k <span class="keyword">in</span> K]: T[k] &#125;; <span class="comment">// Pick의 정의</span></span><br><span class="line"><span class="comment">//만약 Pick에 잘못된 키를 넣으면 오류가 발생한다.</span></span><br><span class="line"><span class="keyword">type</span> TopNavState = Pick&lt;State, <span class="string">'userId'</span> | <span class="string">'pageTitle'</span> | <span class="string">'recentFiles'</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>태그된 유니온에서 중복이 발생하면 어떻게 할 수 있을까? 아래 예시에서 ‘save’,’load’가 중복된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SaveAction &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'save'</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> LoadAction &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'load'</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Action = SaveAction | LoadAction;</span><br></pre></td></tr></table></figure>
<p>위와 같이 중복이 발생할 때는 Action 유니온을 인덱싱하여 ActionType을 정의한다. 이제 Action에 타입이 더 추가되더라도 ActionType은 자동으로 그 타입을 포함하게 된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ActionType = Action[<span class="string">'type'</span>]; <span class="comment">// Type is "save" | "load"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Pick을 사용하여 type 속성을 가지는 interface와 인덱싱을 사용하는 방법은 다르다.</span></span><br><span class="line"><span class="keyword">type</span> ActionRec = Pick&lt;Action, <span class="string">'type'</span>&gt;; <span class="comment">// &#123;type: "save" | "load"&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>매핑된 타입과 keyof를 사용한다.</code> 아래와 같이 생성한 후 업데이트가 되는 클래스를 정의할 때를 가정해본다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">  width: <span class="built_in">number</span>;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> OptionsUpdate &#123;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">  height?: <span class="built_in">number</span>;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  label?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> UIWidget &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">init: Options</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  update(options: OptionsUpdate) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이때 매핑된 타입과 keyof를 사용하여 OptionsUpdate를 만든다.</p>
<ul>
<li>keyof는 타입을 받아서 속성 타입의 유니온을 반환한다.</li>
<li>매핑된 타입[k in keyof Options]은 순회하며 Options 내 k 값에 해당하는 속성이 있는지 찾는다.</li>
<li><code>?</code>는 속성을 선택적으로 만드는데 표준 라이브러리에는 <code>Partial</code>이라는 이름으로 포함되어 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OptionsUpdate = &#123; [k <span class="keyword">in</span> keyof Options]?: Options[k] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OptionsKeys = keyof Options;</span><br><span class="line"><span class="comment">// Type is "width" | "height" | "color" | "label"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>typeof</code>를 사용한다. 값의 형태에 해당하는 타입을 정의하고 싶을 때 사용하는 방법이다. 자바스트립트의 typeof처럼 보이지만 실제로는 타입스크립트 단계에서 연산된다. 단, 값으로부터 타입을 만들어 낼 때 <em>선언의 순서에 주의한다.</em> 타입 정의 후 값이 그 타입에 할당 가능하다고 선언하는 것이 명확하고, 예상하기 어려운 타입 변동을 방지할 수 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> INIT_OPTIONS = &#123;</span><br><span class="line">  width: <span class="number">640</span>,</span><br><span class="line">  height: <span class="number">480</span>,</span><br><span class="line">  color: <span class="string">'#00FF00'</span>,</span><br><span class="line">  label: <span class="string">'VGA'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">  width: <span class="built_in">number</span>;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Options = <span class="keyword">typeof</span> INIT_OPTIONS;</span><br></pre></td></tr></table></figure>
<ul>
<li>함수나 메서드의 반환 값에 명명된 타입을 만들고 싶다면 <code>ReturnType</code>을 사용한다. <em>아래 예시에서 <code>ReturnType</code>은 함수의 <code>값</code>인 getUserInfo가 아닌 typeof getUserInfo에 적용되었다.</em></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> INIT_OPTIONS = &#123;</span><br><span class="line">  width: <span class="number">640</span>,</span><br><span class="line">  height: <span class="number">480</span>,</span><br><span class="line">  color: <span class="string">'#00FF00'</span>,</span><br><span class="line">  label: <span class="string">'VGA'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">userId: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// COMPRESS</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">'Bob'</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">const</span> height = <span class="number">48</span>;</span><br><span class="line">  <span class="keyword">const</span> weight = <span class="number">70</span>;</span><br><span class="line">  <span class="keyword">const</span> favoriteColor = <span class="string">'blue'</span>;</span><br><span class="line">  <span class="comment">// END</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    userId,</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    height,</span><br><span class="line">    weight,</span><br><span class="line">    favoriteColor,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Return type inferred as &#123; userId: string; name: string; age: number, ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo = ReturnType&lt;<span class="keyword">typeof</span> getUserInfo&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>제너릭 타입을 사용한다.</code> 제너릭 타입은 타입을 위한 함수와 같다. 다만 함수에서 매개변수로 매핑할 수 있는 값을 제한하기 위해 타입 시스템을 사용하는 것처럼 매개변수를 제한할 수 있는 방법이 필요하다. 제너릭 타입에서 그 방법은 <code>extends</code>를 사용하는 것이다. 이는 제너릭 매개변수가 특정 타입을 확장한다고 선언할 수 있게 한다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Name &#123;</span><br><span class="line">  first: <span class="built_in">string</span>;</span><br><span class="line">  last: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> DancingDuo&lt;T <span class="keyword">extends</span> Name&gt; = [T, T];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> couple1: DancingDuo&lt;Name&gt; = [</span><br><span class="line">  &#123; first: <span class="string">'Fred'</span>, last: <span class="string">'Astaire'</span> &#125;,</span><br><span class="line">  &#123; first: <span class="string">'Ginger'</span>, last: <span class="string">'Rogers'</span> &#125;,</span><br><span class="line">]; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;first:string&#125;은 Name을 확장하지 않기 때문에 오류 발생</span></span><br><span class="line"><span class="keyword">const</span> couple2: DancingDuo&lt;&#123; first: <span class="built_in">string</span> &#125;&gt; = [</span><br><span class="line">  <span class="comment">// ~~~~~~~~~~~~~~~</span></span><br><span class="line">  <span class="comment">// Property 'last' is missing in type</span></span><br><span class="line">  <span class="comment">// '&#123; first: string; &#125;' but required in type 'Name'</span></span><br><span class="line">  &#123; first: <span class="string">'Sonny'</span> &#125;,</span><br><span class="line">  &#123; first: <span class="string">'Cher'</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-15-동적-데이터에-인덱스-시그니처-사용하기"><a href="#아이템-15-동적-데이터에-인덱스-시그니처-사용하기" class="headerlink" title="아이템 15 동적 데이터에 인덱스 시그니처 사용하기"></a>아이템 15 동적 데이터에 인덱스 시그니처 사용하기</h2><p>자바스크립트는 객체를 생성하는 문법이 간단하고, 문자열 키를 타입의 값에 관계없이 매핑할 수 있다. <em>타입스크립트에서는 타입에 <code>인덱스 시그니처</code>를 명시하여 유연하게 매핑을 표현할 수 있다.</em></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ 인덱스 시그니처</span></span><br><span class="line"><span class="keyword">type</span> Rocket = &#123; [property: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> rocket: Rocket = &#123;</span><br><span class="line">  name: <span class="string">'Falcon 9'</span>,</span><br><span class="line">  variant: <span class="string">'v1.0'</span>,</span><br><span class="line">  thrust: <span class="string">'4,940 kN'</span>,</span><br><span class="line">&#125;; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ 인터페이스</span></span><br><span class="line"><span class="keyword">interface</span> Rocket &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  variant: <span class="built_in">string</span>;</span><br><span class="line">  thrust_kN: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> falconHeavy: Rocket = &#123;</span><br><span class="line">  name: <span class="string">'Falcon Heavy'</span>,</span><br><span class="line">  variant: <span class="string">'v1'</span>,</span><br><span class="line">  thrust_kN: <span class="number">15</span>_200,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>위 예제 1️⃣에서 <code>[property: string]: string</code>이 인덱스 시그니처이다.</p>
<ul>
<li>키의 이름: 키의 위치만 표시. 타입 체커에서는 사용하지 않는다.</li>
<li>키의 타입: string이나 number 또는 symbol의 조합이어야 하지만 보통 string을 사용한다.</li>
<li>값의 타입: 어떤 것이든 가능하다.</li>
</ul>
<p>그러나 인덱스 시그니처는 타입 체크 수행 시 아래와 같은 단점을 가진다.</p>
<ul>
<li>잘못된 키를 포함한 모든 키를 허용 (name이 아닌 Name도 유효한 Rocket의 타입)</li>
<li>특정 키가 필요하지 않아. ({}도 유효한 Rocket의 타입)</li>
<li>키마다 다른 타입을 가질 수 없다. (thrust만 number일 수도 있는데 그렇게 사용할 수 없다.)</li>
<li>키는 무엇이든 가능하기 때문에 언어서비스(자동 완성 기능)이 제대로 동작하지 않는다.</li>
</ul>
<p>이런 부정확한 부분을 개선하기 위해 2️⃣와 같이 <code>인터페이스</code>로 작성한다.</p>
<h3 id="그렇다면-인덱스-시그니처는-어떤-상황에서-사용해야-할까"><a href="#그렇다면-인덱스-시그니처는-어떤-상황에서-사용해야-할까" class="headerlink" title="그렇다면 인덱스 시그니처는 어떤 상황에서 사용해야 할까?"></a>그렇다면 인덱스 시그니처는 어떤 상황에서 사용해야 할까?</h3><blockquote>
<p>동적 데이터를 표현할 때, 런타임 때가지 객체의 속성을 알 수 없을 경우</p>
</blockquote>
<p>예를 들어 CSV 파일처럼 행, 열에 이름이 있고 데이터 행을 열 이름과 값으로 매핑하는 객체로 나타내고 싶다면 인덱스 시그니처를 사용할 수 있다.</p>
<ul>
<li>열 이름이 무엇인지 모른다 -&gt; 인덱스 시그니처 사용</li>
<li>열 이름을 알고 있다 -&gt; 미리 선언해 둔 타입 사용. 단, 런타임에 실제로 일치하지 않을 수도 있으므로 undefined를 추가해서 나타낼 수 있다.</li>
<li>어떤 타입에 가능한 필드가 제한되어 있다(e.g. 데이터 상에 키를 알고 있는데, 그것이 얼마나 있는지 알 수 없다.) -&gt; 선택적 필드 또는 유니온 타입을 사용</li>
</ul>
<h3 id="string-타입이-너무-광범위해서-인덱스-시그니처를-사용하는-데-문제가-있다면"><a href="#string-타입이-너무-광범위해서-인덱스-시그니처를-사용하는-데-문제가-있다면" class="headerlink" title="string 타입이 너무 광범위해서 인덱스 시그니처를 사용하는 데 문제가 있다면?"></a>string 타입이 너무 광범위해서 인덱스 시그니처를 사용하는 데 문제가 있다면?</h3><ul>
<li>Record를 사용한다. 키 타입에 유연성을 제공하는 제너릭 타입으로 string의 부분 집합을 사용할 수 있다.</li>
<li>매핑된 타입을 사용한다. 키마다 별도의 타입을 사용하게 해준다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Record 사용</span></span><br><span class="line"><span class="keyword">type</span> Vec3D = Record&lt;<span class="string">'x'</span> | <span class="string">'y'</span> | <span class="string">'z'</span>, <span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="comment">// Type Vec3D = &#123;</span></span><br><span class="line"><span class="comment">//   x: number;</span></span><br><span class="line"><span class="comment">//   y: number;</span></span><br><span class="line"><span class="comment">//   z: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//매핑된 타입 사용</span></span><br><span class="line"><span class="keyword">type</span> Vec3D = &#123; [k <span class="keyword">in</span> <span class="string">'x'</span> | <span class="string">'y'</span> | <span class="string">'z'</span>]: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">// Same as above</span></span><br><span class="line"><span class="keyword">type</span> ABC = &#123; [k <span class="keyword">in</span> <span class="string">'a'</span> | <span class="string">'b'</span> | <span class="string">'c'</span>]: k <span class="keyword">extends</span> <span class="string">'b'</span> ? <span class="built_in">string</span> : <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">// Type ABC = &#123;</span></span><br><span class="line"><span class="comment">//   a: number;</span></span><br><span class="line"><span class="comment">//   b: string;</span></span><br><span class="line"><span class="comment">//   c: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-16-number-인덱스-시그니처보다는-Array-튜플-ArrayLike를-사용하기"><a href="#아이템-16-number-인덱스-시그니처보다는-Array-튜플-ArrayLike를-사용하기" class="headerlink" title="아이템 16 number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기"></a>아이템 16 number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기</h2><p>자바스크립트의 객체는 키/값 쌍의 모음인데, 키는 보통 문자열, 값은 어떤 것이든 될 수 있다. <em>그래서 숫자는 키로 사용할 수 없다.</em> 배열의 경우, 분명히 객체인데 숫자 인덱스를 사용하는 것이 당연하다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x[<span class="number">0</span>]; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">x[<span class="string">'1'</span>]; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(x); <span class="comment">//['0','1','2']</span></span><br></pre></td></tr></table></figure>
<p>배열에서 인덱스는 숫자타입이더라도 문자열로 변환되어 사용한다. 따라서 문자열 키를 사용해도 배열의 요소에 접근할 수 있다. Object.keys를 이용하여 배열의 키를 나열해보면 문자열로 구성되어 있음을 알 수 있다. <strong>타입스크립트는 이러한 혼란을 바로 잡기 위해서 숫자 키를 허용하고, 문자열 키와 다른 것으로 인식한다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for ~ in - 배열을 순회하는 방법이지만 좋은 방법은 아니다.</span></span><br><span class="line"><span class="keyword">const</span> xs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(xs); <span class="comment">// Type is string[]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> xs) &#123;</span><br><span class="line">  key; <span class="comment">// Type is string</span></span><br><span class="line">  <span class="keyword">const</span> x = xs[key]; <span class="comment">// Type is number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for ~ of - 인덱스에 신경쓰지 않는 경우</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x of xs) &#123;</span><br><span class="line">  x; <span class="comment">// Type is number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Array.prototype.forEach - 인덱스의 타입이 중요한 경우</span></span><br><span class="line">xs.forEach(<span class="function">(<span class="params">x, i</span>) =&gt;</span> &#123;</span><br><span class="line">  i; <span class="comment">// Type is number</span></span><br><span class="line">  x; <span class="comment">// Type is number</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//for - 루프 중간에 멈춰야 하는 경우</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; xs.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> x = xs[i];</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>타입이 불확실하면, for ~ in 루프는 for ~ of 루프에 비해 몇 배 느리다.</em> 여기서 for ~ in, for ~ of는 둘 다 반복문인데, for ~ in은 반복가능한 객체를 순환하고, for ~ of는 배열 요소를 탐색한다. 두 가지가 다른점은 for ~ in의 대상이 되는 객체는 이터러블이 아니므로 객체에 대해서 for ~ of를 사용하면 에러가 발생한다는 것이고, for ~ in의 대상이 되는 배열의 경우 이터러블한 객체여서 for~of를 적용해도 에러가 발생하지 않는다. 다만 배열에 대해 for ~ in을 사용하면 객체의 키 값에 해당하는 인덱스가 나오고, for ~ of를 쓰면 해당요소가 나온다는 점이 다르다.</p>
<p>배열은 인덱스 시그니처가 number로 표현되어 있다면 입력한 값이 number여야 한다는 것을 의미하지만 실제 런타임에 사용되는 키는 string타입이다. 그러나 일반적으로 string 대신 number를 타입의 인덱스 시그니처로 사용할 이유는 많지 않다. <em>만약 숫자를 사용하여 인덱스할 항목을 지정한다면 Array 또는 튜플 타입을 사용한다.</em> number를 인덱스로 쓰면 어떤 특별한 의미를 지닌다는 오해를 불러 일으킬 수 있다. 그리고, 어떤 길이를 가지는 배열과 비슷한 형태의 튜플을 사용하고 싶다면 타입스크립트에 있는 ArrayLike 타입을 사용한다. 단, ArrayLike를 사용해도 키는 여전히 문자열이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkedAccess</span>&lt;<span class="title">T</span>&gt;(<span class="params">xs: ArrayLike&lt;T&gt;, i: <span class="built_in">number</span></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; xs.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> xs[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Attempt to access <span class="subst">$&#123;i&#125;</span> which is past end of array.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-17-변경-관련된-오류-방지를-위해-readonly-사용하기"><a href="#아이템-17-변경-관련된-오류-방지를-위해-readonly-사용하기" class="headerlink" title="아이템 17 변경 관련된 오류 방지를 위해 readonly 사용하기"></a>아이템 17 변경 관련된 오류 방지를 위해 readonly 사용하기</h2><p>아래 예제에서 1️⃣은 계산이 끝나면 원래 배열이 전부 비게 되는데도, 자바스크립트는 배열의 내용을 변경할 수 있기 때문에 타입스크립트에서 오류 없이 통과한다. 그래서 오류의 범위는 좁히기 위해 readonly 접근 제어자를 사용한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1️⃣</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraySum</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>,</span><br><span class="line">    num;</span><br><span class="line">  <span class="keyword">while</span> ((num = arr.pop()) !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    sum += num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraySum</span>(<span class="params">arr: readonly <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>,</span><br><span class="line">    num;</span><br><span class="line">  <span class="keyword">while</span> ((num = arr.pop()) !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// ~~~ 'pop' does not exist on type 'readonly number[]'</span></span><br><span class="line">    sum += num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 예제에서 2️⃣의 readonly number[]는 타입이다. 특징은 아래와 같다.</p>
<ul>
<li>배열의 요소를 읽을 수 있지만, 쓸 수는 없다.</li>
<li>length를 읽을 수 있지만, 바꿀 수 없다.</li>
<li>배열을 변경하는 pop을 비롯한 다른 메서드를 호출할 수 없다.</li>
<li>변경 가능한 배열을 readonly 배열에 할당할 수 있다. 하지만 그 반대는 불가하다.</li>
</ul>
<p>매개변수를 readonly로 선언하면 특징은 다음과 같다.</p>
<ul>
<li>타입스크립트는 매개변수가 함수 내에서 변경이 일어나는지 체크한다.</li>
<li>호출하는 쪽에서 함수가 매개변수를 변경하지 않는다는 보장을 받게 된다.</li>
<li>호출하는 쪽에서 함수에 readonly 배열을 매개변수에 넣을 수 있다.</li>
<li>함수가 매개변수를 변경하지 않는다면, readonly로 선언한다.</li>
<li>readonly는 <code>얕게(shallow)</code> 동작하므로 만약 객체의 readonly 배열이 있다면 객체 자체는 readonly가 아니다.</li>
</ul>
<hr>
<h2 id="아이템-18-매핑된-타입을-사용하여-값을-동기화하기"><a href="#아이템-18-매핑된-타입을-사용하여-값을-동기화하기" class="headerlink" title="아이템 18 매핑된 타입을 사용하여 값을 동기화하기"></a>아이템 18 매핑된 타입을 사용하여 값을 동기화하기</h2><p>다음은 타입 체커가 동작하도록 개선한 코드인데, <em>핵심은 매핑된 타입과 객체를 사용하는 것이다.</em> <code>[k in keyof ScatterProps]</code>는 타입 체커에게 REQUIRES_UPDATE가 ScatterProps와 동일한 속성을 가져야 한다는 정보를 제공한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ScatterProps &#123;</span><br><span class="line">  <span class="comment">// The data</span></span><br><span class="line">  xs: <span class="built_in">number</span>[];</span><br><span class="line">  ys: <span class="built_in">number</span>[];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Display</span></span><br><span class="line">  xRange: [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line">  yRange: [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Events</span></span><br><span class="line">  onClick: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span>, index: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> REQUIRES_UPDATE: &#123; [k <span class="keyword">in</span> keyof ScatterProps]: <span class="built_in">boolean</span> &#125; = &#123;</span><br><span class="line">  xs: <span class="literal">true</span>,</span><br><span class="line">  ys: <span class="literal">true</span>,</span><br><span class="line">  xRange: <span class="literal">true</span>,</span><br><span class="line">  yRange: <span class="literal">true</span>,</span><br><span class="line">  color: <span class="literal">true</span>,</span><br><span class="line">  onClick: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldUpdate</span>(<span class="params">oldProps: ScatterProps, newProps: ScatterProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> k: keyof ScatterProps;</span><br><span class="line">  <span class="keyword">for</span> (k <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldProps[k] !== newProps[k] &amp;&amp; REQUIRES_UPDATE[k]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Heejin Lee</p>
  <div class="site-description" itemprop="description">Today I Learned</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heejin Lee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
