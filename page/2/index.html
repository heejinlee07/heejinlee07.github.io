<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heejinlee07.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Today I Learned">
<meta property="og:type" content="website">
<meta property="og:title" content="Heejin">
<meta property="og:url" content="https://heejinlee07.github.io/page/2/index.html">
<meta property="og:site_name" content="Heejin">
<meta property="og:description" content="Today I Learned">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Heejin Lee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://heejinlee07.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Heejin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heejin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Front-end Developer</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/05/09/220510_promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/09/220510_promise/" class="post-title-link" itemprop="url">자바스크립트의 프로미스</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-10 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-10T00:00:00+09:00">2022-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-06 23:40:24" itemprop="dateModified" datetime="2022-12-06T23:40:24+09:00">2022-12-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>자바스크립트의 비동기성을 표현하는 기본 단위로써 콜백이 있는데, 콜백은 순차성과 믿음성이 결여되는 문제점이 있었다. 특히 콜백이 가진 제어의 역전은 실행 흐름을 서드 파티에 의존해야 하기 때문에 요청을 보내면 그 요청이 잘되기를 바라는 방법이 최선이었다. 이런 문제점을 보완하고 좀 더 나은 방법으로 비동기 처리를 할 수 있는 방법으로 <code>프로미스</code>가 등장하게 되는데, <code>제어의 되역전</code>을 아이디어로 삼는다. <strong>즉 실행 흐름을 서드 파티와 같은 다른 파트에 넘겨주지 않고도 개발자가 작업의 실행 결과와 다음 task에 대해 제어할 수 있는 것이다.</strong></p>
<h2 id="프로미스의-미랫값-지금값-나중값"><a href="#프로미스의-미랫값-지금값-나중값" class="headerlink" title="프로미스의 미랫값, 지금값, 나중값"></a>프로미스의 미랫값, 지금값, 나중값</h2><p><strong><code>미랫값</code>은 <code>시간 독립적인 값(Time Independent)</code>이다.</strong> 시간의 흐름과 상관없이 미래에 성공 또는 실패로 귀결되는 값이다. 이 미랫값은 원래 내가 가지고 있던 값 자체와 교환된다. 미랫값이 성공이면 나는 언제가 되었든 반드시 원래 가지고 있던 값을 받게 되고, 실패이면 값을 받지 못한다. 그리고 이러한 미랫값을 다루는 방법이 콜백이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">getX, getY, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x, y;</span><br><span class="line"></span><br><span class="line">  getX(<span class="function"><span class="keyword">function</span> (<span class="params">xVal</span>) </span>&#123;</span><br><span class="line">    x = xVal;</span><br><span class="line">    <span class="comment">//둘 다 준비됐나?</span></span><br><span class="line">    <span class="keyword">if</span> (y != <span class="literal">undefined</span>) &#123;</span><br><span class="line">      cb(x + y); <span class="comment">//더해서 보내</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  getY(<span class="function"><span class="keyword">function</span> (<span class="params">yVal</span>) </span>&#123;</span><br><span class="line">    y = yVal;</span><br><span class="line">    <span class="comment">//둘 다 준비됐나?</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">undefined</span>) &#123;</span><br><span class="line">      cb(x + y); <span class="comment">//더해서 보내</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fetchX()와 fetchY()는 동기/비동기 함수</span></span><br><span class="line">add(fetchX, fetchY, <span class="function"><span class="keyword">function</span> (<span class="params">sum</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sum); <span class="comment">//너무 쉽지?</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>위의 코드가 비동기 패턴이 아니라 일반 함수라고 가정해보자면, x,y의 값은 <code>지금</code>존재하는 구체적인 값이라는 가정 하에 연산이 진행될 것이다. 아래 예시를 통해 지금값에 대해 보충해 보겠다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">var</span> x,</span><br><span class="line">  y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x + y); <span class="comment">//NaN &lt;- x는 아직 세팅 전이다.</span></span><br></pre></td></tr></table></figure>
<p>이 2️⃣번 예시는 비동기 패턴이 아닌 일반적인 계산 로직을 담고 있는 코드이다. 이 로직에서 x + y 가 연산되는 시점에서 코드는 x, y가 <code>지금</code> 존재하고 있는, 귀결(Resolved)된 값이라고 생각하고 연산이 이루어진다. 그렇기 때문에 x는 아직 할당 전이어서 실질적인 값은 undefined인데 지금 값이 존재한다고 가정되어 undefined + 2로 계산이 되어 NaN이라는 결과를 얻은 것이다.</p>
<p>만약 이 함수에서 x, y의 값을 연산할 때 <code>지금</code> 둘 중 하나라도 준비가 덜 됐으면 될 때까지 기다렸다가 <code>나중</code>에 값을 얻었을 때 연산을 진행한다고 가정해보자. 즉 코드에서 x, y를 <code>지금</code> 존재하는 귀결된 값이라고 가정하는 것이 아니라 <strong>미래에 실패 또는 성공할 값이라고 가정하고 연산을 진행하는 것이다.</strong> 그렇다면 결과값은 두 가지 값 모두 순조롭게 할당이 완료되어 성공적으로 정상적인 값을 출력하거나, <code>나중</code>까지 기다렸는데도 정상적인 값이 할당되지 않아 undefined + 2로 계산된 것처럼 정상적인 결과를 출력하는데 실패하게 될 것이다. 그래서 x, y의 구체적인 연산 결과는 당장 예측할 수 없지만 그 값이 미래에 반드시 성공 또는 실패될 것이라는 사실을 예측할 수 있게 된다.</p>
<p>다시 돌아와서 1️⃣번 예제의 비동기 패턴을 살펴보자. <em>비동기 프로그래밍의 핵심은 <code>지금</code>에 해당하는 부분과 <code>나중</code>에 해당하는 부분 사이의 관계라고 하였다.</em> 1️⃣번 예제에서 <code>지금</code>부터 <code>나중</code>까지 기다리는 최적의 방법으로 <code>콜백 함수</code>를 사용한다. 위에 설명했던 것처럼 지금 값이 귀결되어 있는지와 상관없이 일단 add() 함수를 호출하여 작성된 로직을 수행한다. add() 함수 내부의 x, y는 add()입장에서 실행되는 지금 시점에서 값이 준비되어 있는지 아닌지는 관심 밖이다. 여기서 <strong>x,y는 미랫값으로 취급된다.</strong> 따라서 그 값이 어떤 것인지와 상관없이 add()의 결과는 성공 또는 실패 일 것이라고 예측할 수 있게 된다.즉 x,y의 값이 <code>지금</code> 존재하는 값일 수도 있고, 나중에 값을 얻게 될 수도 있는데, 여기서는 <code>지금</code>과 <code>나중</code>의 어떤 때라도 결과론적으로 똑같이 일관적으로 동작할 수 있게 하기 위해서 이 두 가지 모두를 <code>나중</code>으로 만들어서 모든 작업을 나중에 얻게 될 성공 또는 실패의 값으로 비동기화시킨 것이다.</p>
<p><em>정리하자면 어떤 로직을 수행할 때, 값이 지금 존재하는지를 알기 여려운 경우, 해당 값을 지금 값이 존재하는지, 미래에 어느 시점에 존재하는 값으로 바뀌는지는 알 수 없지만 값 자체를 <code>나중</code>에 언젠가는 존재할 값이라는 가정 하에 로직을 수행하고, <code>나중</code>에 그 값을 얻게 되면, 그 값은 구체적으로 로직의 연산 결과를 반환하는 값은 아니지만 반드시 성공 또는 실패한 값이다.</em></p>
<p>이 개념을 기억하며 프로미스 함수를 좀 더 자세히 살펴보자. 위 예제의 x + y를 프로미스 함수로 나타낸 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">xPromise, yPromise</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([xPromise, yPromise]).then(<span class="function"><span class="keyword">function</span> (<span class="params">values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> values[<span class="number">0</span>] + values[<span class="number">1</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(fetchX(), fetchY()).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">sum</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>Promise.all([])은 프로미스 배열을 인자로 받아서 프로미스가 모두 귀결될 때까지 기다렸다가 새 프로미스를 만들어 반환한다. 그리고 프로미스가 귀결되면 X와 Y 값을 받아 더하고, then에서 파라미터로 전달받은 values는 앞에서 귀결된 프로미스가 전달해 준 메시지 배열이다. 그리고 fetchX()와 fetchY()는 제각기 값을 가진 프로미스를 반환하는데, 지금 또는 나중에 준비된다. add()의 결과로 두 숫자의 합이 담긴 프로미스를 받으면 이제 반환된 프로미스가 귀결될 때까지 대기하기 위해 then()을 연쇄 호출한다.</p>
<p>위 예제에는 두 개의 프로미스 계층이 있다. 먼저 두 프로미스 fetchX()와 fetchY()를 호출하여 반환된 값은 add()에 전달된다. 프로미스 속의 원래 값은 지금 또는 나중에 준비되는데 그 시점과는 상관없이 각 프로미스가 같은 결과를 내게끔 정규화하고, <strong>미랫값 X,Y는 시간 독립적으로 추론이 가능하다.</strong> 그리고 그 다음 프로미스 계층은 add()가 Promise.all을 거쳐 반환한 프로미스인데, then()을 호출하고 대기한다. add()가 끝나면 덧셈을 마친 미랫값이 콘솔에 출력된다.</p>
<p><strong>이렇게 프로미스는 <code>Fulfillment</code> 또는 <code>Rejection</code>으로 귀결될 수 있다.</strong> 여기서 Fulfillment는 항상 프로그램이 귀결값을 결정짓고, Rejection은 프로그램 로직에 따라 직접 세팅되거나 런타임 예외에 의해 암시적으로 생겨난다.</p>
<p>그리고 프로미스 then() 함수는 Fulfillment 함수를 첫 번째 인자로, Rejection 함수를 두 번째 인자로 넘겨받는다. 그렇기 때문에 X나 Y의 조회 시 문제가 있거나 연산에 실패하면 add()가 반환하는 프로미스는 버려지고, then()의 두 번째 에러 처리 콜백이 이 프로미스에서 Rejection을 받는다.</p>
<p>요약해보자면 프로미스는 시간 의존적인 상태를 외부로부터 캡슐화하기 때문에 타이밍 또는 내부 결과값에 상관없이 예측 가능한 방향으로 조합할 수 있다. 또 프로미스는 일단 귀결되면 그 상태가 그대로 유지되는 불변값이다.</p>
<h2 id="프로미스"><a href="#프로미스" class="headerlink" title="프로미스"></a>프로미스</h2><blockquote>
<p>프로미스 객체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값이다.</p>
</blockquote>
<p>위에서 보았던 여러 예제를 통해 프로미스의 성격에 대해 알아보았다. 프로미스에서는 미랫값이라는 개념이 중요했다. 미랫값은 지금 당장은 값은 알 수 없고, 어느 시점에 그 값이 확정되는지 알 수 없지만 성공 또는 실패일 것으로 추론할 수 있는 값이었다. 프로미스는 이처럼 지금 당장 실행하는 시점에서 아직 알려지지 않을 수도 있는 값을 위한 대리자이고, 미랫값 개념을 콜백으로 다루는데, 비동기 연산이 종료된 이후에 결과 값과 실패 사유를 처리하기 위한 처리기를 연결할 수 있다. 그래서 프로미스를 사용하면 비동기 메서드에서 마치 동기 메서드처럼 값을 반환할 수 있다. 다만 최종 결과를 반환하는 것이 아니고, <code>미래의 어떤 시점에 결과를 제공하겠다는 &#39;약속&#39;(프로미스)을 반환한다.</code></p>
<p>그래서 프로미스는 다음 중 하나의 상태를 가진다.</p>
<ul>
<li>대기(pending): 이행하지도, 거부하지도 않은 초기 상태.</li>
<li>이행(Fulfillment): 연산이 성공적으로 완료됨.</li>
<li>거부(Rejection): 연산이 실패함.</li>
</ul>
<p>Promise가 생성된 시점에 대기 중인 프로미스 값은 성공적으로 이행(Fulfillment)이 되어서 위 예제에서 처럼 X + Y의 값을 얻을 수도 있고, 오류와 같은 이유로 인해 이행이 불가하여 거부(Rejection)될 수도 있다. 그리고 프로미스가 이행이나 거부로 귀결되면 then 메서드에 의해서 처리기들이 호출된다. 이 프로미스는 시간 의존적인 상태를 외부로부터 캡슐화하기 때문에 <strong>프로미스 자체는 시간 독립적이고,</strong> 따라서 언젠가 이행(Fulfillment)되거나 거부(Rejection)될 것을 예측하여 로직을 구성할 수 있다.</p>
<h2 id="프로미스의-완료-이벤트"><a href="#프로미스의-완료-이벤트" class="headerlink" title="프로미스의 완료 이벤트"></a>프로미스의 완료 이벤트</h2><blockquote>
<p>프로미스는 각각 미래값으로서 작동하지만 <em>프로미스의 귀결은 비동기 작업의 여러 단계를 흐름 제어하기 위한 체계이다.</em></p>
</blockquote>
<p>어떤 일을 하는 foo()라는 함수를 호출한다고 했을 때,</p>
<ul>
<li>전통적인 자바스크립트 사고 방식 :알림 자체를 하나의 이벤트로 보고 리스닝하고, foo()의 완료 이벤트를 리스닝함으로써 알림 요건을 재구성한다.</li>
<li>콜백에 : foo()에서 넘겨준 콜백을 호출하면 성립된다.</li>
<li>프로미스에서 : foo()에서 이벤트를 리스닝하고 있다가 알림을 받게 되면 다음으로 진행한다.</li>
</ul>
<p>아래는 프로미스의 예제이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo(x) &#123;</span><br><span class="line">  <span class="comment">//뭔가 시간이 제법 걸리는 일을 한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">on(foo <span class="string">"완료"</span>) &#123;</span><br><span class="line">  <span class="comment">// 이제 다음 단계로 갈 수 있다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">on(foo <span class="string">"에러"</span>) &#123;</span><br><span class="line">  <span class="comment">//어랏, foo()에서 뭔가 잘못됐다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foo()를 호출한 뒤에 완료, 에러 이벤트를 각각 리스닝하는 이벤트 리스너를 설정했다. foo()를 호출하면 foo()에서 이벤트를 받아 어떻게 처리하는지를 신경쓰지 않아도 되고, foo()의 결과는 완료 아니면 에러인 <code>관심사의 분리</code>가 된다.</p>
<p>이러한 코드는 사실상 일반적으로 콜백이 지향하는 코드와 정반대이다. 아래 예제를 보면 foo()에 콜백 함수를 넘겨주는 대신 <em>foo()가 이벤트 구독기를 반환하고 여기에 콜백 함수를 넣는다.</em> 이처럼 콜백 패턴을 뒤집는다는 것은 사실상 <code>제어의 되역전</code>으로 서드파티와 같은 다른 파트에 주었던 실행 흐름의 제어권을 호출부에 되돌려 둔 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//뭔가 시간이 제법 걸리는 일을 시작한다.</span></span><br><span class="line">  <span class="comment">//이벤트 구독기를 생성하여 반환한다.</span></span><br><span class="line">  <span class="keyword">return</span> listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> evt = foo(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">evt.on(<span class="string">'completion'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//이제 다음 단계로 갈 수 있다.</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">evt.on(<span class="string">'failure'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//어랏, foo()에서 뭔가 잘못됐다.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>이 <code>제어의 되역전</code>으로 인해 이제 관심사를 분리할 수 있게 된다. 아래와 같은 코드가 있으면 bar()나 baz()는 foo()가 호출되어 처리되는 것에 신경 쓸 필요 없고, foo()도 마찬가지로 누군가 자신을 기다리고 있다는 사실을 몰라도 된다. 이렇게 분리된 관심사 간에 중재자 역할을 evt가 하는 것이고, 이것이 프로미스와 매우 유사하다. 프로미스식으로 아래 코드를 다시 작성한다면 foo()는 프로미스 인스턴스를 생성해서 반환하고, 이 프로미스를 bar()와 baz()에 전달할 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = foo(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//bar()는 foo()의 완료 이벤트를 리스닝한다.</span></span><br><span class="line">bar(evt);</span><br><span class="line"><span class="comment">//baz()는 foo()의 완료 이벤트를 리스닝한다.</span></span><br><span class="line">baz(evt;)</span><br></pre></td></tr></table></figure>
<hr>
<p><em>References</em><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a><br>[YOU DON’T KNOW JS] 카일 심슨 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/05/08/220509_asynchronous/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/08/220509_asynchronous/" class="post-title-link" itemprop="url">자바스크립트의 비동기성</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-09 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-09T00:00:00+09:00">2022-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-06 23:40:24" itemprop="dateModified" datetime="2022-12-06T23:40:24+09:00">2022-12-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>자바스립트는 동기적이다. <strong>동기적이라는 말은 자바스크립트가 싱글 스레드이기 때문에 한 번에 한 가지 task만 수행할 수 있다는 의미이다.</strong> 즉, 어떤 task1이 실행되면 이 task의 처리가 끝나기 전까지 다음 task인 task2는 실행되지 못하고, task1이 끝날 때까지 기다려야 한다. 그런데 브라우저 환경에서 task가 동기적으로 차리되면 예를 들어 서버에 요청한 후 어떤 결과값을 받아서 화면에 렌더링하는 task가 있다고 했을 때, 서버에서 요청이 언제 돌아올지 모르는 상태로 마냥 기다려야 하는데, 이 사이에 사용자가 보는 웹 브라우저 화면은 빈 화면인 상태 또는 task가 수행되기 이전의 상태에 머물러 있게 된다. 이런 문제 때문에 <strong>브라우저 환경에서 자바스크립트는 비동기적으로 실행된다.</strong> 정확히 말하자면 자바스크립트가 비동기적인 것이 아니라 브라우저가 비동기 처리를 이용하여 task를 마치 동시에 처리되는 것처럼 처리하고, <strong>이러한 비동기 처리를 돕는 것은 이벤트 루프이다.</strong></p>
<p><em>그렇다면 자바스크립트에서 말하는 비동기 프로그래밍의 개념에 대해 조금 더 상세히 살펴보겠다.</em></p>
<blockquote>
<p>비동기 프로그래밍의 핵심은 <code>지금</code>에 해당하는 부분, <code>나중</code>에 해당하는 부분 사이의 관계 또는 간극이다.</p>
</blockquote>
<h2 id="비동기성을-이해하기-위한-배경-지식"><a href="#비동기성을-이해하기-위한-배경-지식" class="headerlink" title="비동기성을 이해하기 위한 배경 지식"></a>비동기성을 이해하기 위한 배경 지식</h2><p>자바스크립트에서 프로그램은 여러 개의 chunk로 구성된다.</p>
<ol>
<li><code>지금</code> 실행 중인 프로그램 chunk</li>
<li><code>나중에</code> 실행 할 프로그램 chunk</li>
</ol>
<p>여기서 <code>나중</code>은 <code>지금</code>의 직후가 아니며, <code>지금</code> 끝낼 수 없는 작업은 비동기적으로 처리되기 때문에 프로그램을 중단하지 않는다. AJAX를 예로 들자면 이 함수는 비동기적으로 어떠한 task를 <code>지금</code> 요청하고 <code>나중</code>에 결과를 받고, <code>지금</code>부터 <code>나중</code>까지 기다리는 최적의 방법은 <code>콜백 함수</code>를 이용하는 것이다.</p>
<h3 id="이벤트-루프"><a href="#이벤트-루프" class="headerlink" title="이벤트 루프"></a>이벤트 루프</h3><p><strong>앞서 말했지만 자바스크립트는 동기적이라서 주어진 요청(task)가 주어지면 주어진대로 순서대로 처리할 뿐이다.</strong> 자바스크립트 엔진은 웹 브라우저와 같은 호스팅 환경에서 실행되는데, 이벤트 루프가 여러 프로그램 chunk를 시간에 따라 매 순간 한 번씩 엔진을 실행시키도록 한다. 즉 자바스크립트 엔진이 동기적으로 코드를 실행할 때 AJAX, 콜백함수와 같이 비동기 처리 함수가 있다면 브라우저 환경이 이벤트 루프를 통해 실행을 스케줄링 하는 것이다. 이 스케줄링이 비동기적으로 처리되기 때문에 자바스크립트 자체는 동기적이지만 브라우저 환경에서의 실행 스케줄링은 비동기적이라고 할 수 있다. 구현방식을 단순화해서 구현하면 다음과 같다.</p>
<p><strong>while문의 무한 루프에서 매 순회를 틱이라 하는데, 한 번 틱이 발생할 때, 큐에 있는 이벤트(콜백 함수)를 선입 선출하여 실행한다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eventLoop는 큐(선입, 선출) 역할을 하는 배열</span></span><br><span class="line"><span class="keyword">var</span> eventLoop = [];</span><br><span class="line"><span class="keyword">var</span> event;</span><br><span class="line"></span><br><span class="line"><span class="comment">//'무한'실행</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">//'틱' 발생 (틱: 이벤트 루프를 한 차례 순회하는 것)</span></span><br><span class="line">  <span class="keyword">if</span> (eventLoop.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//큐에 있는 다음 이벤트 조회</span></span><br><span class="line">    event = eventLoop.shift();</span><br><span class="line">    <span class="comment">//이제 다음 이벤트 실행</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      event();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reportError(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="싱글-스레드-vs-병렬-스레드"><a href="#싱글-스레드-vs-병렬-스레드" class="headerlink" title="싱글 스레드 vs 병렬 스레드"></a>싱글 스레드 vs 병렬 스레드</h3><p>자바스크립트의 비동기 처리에 대해서 설명할 때 종종 병렬과 혼용하여 사용하는데, 둘은 완전히 다른 개념이다.</p>
<ul>
<li>비동기 : <code>지금</code>과 <code>나중</code> 사이의 간극에 관함</li>
<li>병렬: <code>동시</code>에 일어나는 일에 관함</li>
</ul>
<p>자바스크립트는 하나의 프로그램에서 여러 스레드를 처리하는 병렬 시스템이 아니라 <strong>절대로 스레드 간에 데이터를 공유하지 않는 단일 스레드 환경이다.</strong> 그리고 단일 스레드이기 때문에 완전-실행(Run-to-Completion)된다. 즉 함수가 2개 있다면 첫 번째 함수의 전체 코드가 다 실행된 후, 다음 함수가 실행된다. 그리고 두 함수가 있다면 이 함수는 순서에 따른 비결정성을 가진다. 이를 경합 조건(Race Condition)이라 한다.</p>
<h3 id="동시성"><a href="#동시성" class="headerlink" title="동시성"></a>동시성</h3><p>복수의 프로세스가 같은 시간 동안 동시에 실행된다. 앞서 말했듯이 자바스크립트는 병렬 스레드가 아니므로 여기서 말하는 동시성은 <strong>각 프로세스 작업(개별 프로세스의 스레드)이 병렬로 처리되는지와 관계된 것이 아닌, 프로세스 수준(작업 수준)의 병행성을 말한다.</strong> 단 프로세스 1과 프로세스 2가 있다면 이들은 동시에 실행되지만 이들을 구성하는 이벤트들은 이벤트 루프 큐에서 차례대로 실행된다.</p>
<h3 id="상호작용-vs-비상호-작용"><a href="#상호작용-vs-비상호-작용" class="headerlink" title="상호작용 vs 비상호 작용"></a>상호작용 vs 비상호 작용</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">  res.foo = results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">  res.bar = results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ajax()는 라이브러리에 있는 임의의 AJAX 함수</span></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, foo);</span><br><span class="line">ajax(<span class="string">'http://some.url.2'</span>, bar);</span><br></pre></td></tr></table></figure>
<p>위 코드에서 복수의 프로세스 foo(), bar()가 동시에 실행될 때, 누가 먼저 실행될 지는 알 수 없지만 이들 프로세스 사이에 연관된 작업이 없기 때문에 프로세스간 상호작용이 일어나지 않는다. 이런 경우에 실행 순서가 문제되지 않는다. <em>즉 경합 조건이 문제시 되지 않는다.</em> 하지만 상호 작용하는 상황이라면 이야기는 달라진다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  res.push(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ajax()는 라이브러리에 있는 임의의 AJAX 함수</span></span><br><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, response);</span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.2'</span>, response);</span><br></pre></td></tr></table></figure>
<p>위의 코드는 상호 작용이 발생하는 프로세스이다. 1️⃣과 2️⃣의 프로세스는 모두 AJAX 응답에 대한 처리를 하는 response() 함수를 호출하기 때문에 선발 순으로 처리된다. 이 코드가 프로그램 개발자가 ‘<a href="http://some.url.1&#39;의" target="_blank" rel="noopener">http://some.url.1&#39;의</a> 결과를 res[0]에, ‘<a href="http://some.url.2&#39;,의" target="_blank" rel="noopener">http://some.url.2&#39;,의</a> 결과를 res[1]에 넣고자 의도한 코드라고 했을 때, 의도한 대로 동작할 수 있지만 어느쪽 URL의 응답이 먼저 도착할지 보장되지 않기 때문에 만약 예측한 대로 응답이 도착하지 않을 경우 결과가 뒤집힐 수 있다. 이런 경합 조건을 해결하려면 상호 작용의 순서를 잘 조정해야 한다. <em>특히 동시 프로세스들이 스코프나 DOM을 통해 간접적으로 상호작용하기 때문에 순서 조정이 아주 중요하다. DOM을 조작하는 코드의 경우 순서 조정이 제대로 이루어지지 않으면 처리가 덜 된 DOM 요소를 화면에 보여주게 될 수도 있다.</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data.url == <span class="string">'http://some.url.1'</span>) &#123;</span><br><span class="line">    res[<span class="number">0</span>] = data;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.url == <span class="string">'http://some.url.2'</span>) &#123;</span><br><span class="line">    res[<span class="number">1</span>] = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ajax()는 라이브러리에 있는 임의의 AJAX 함수</span></span><br><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, response);</span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.2'</span>, response);</span><br></pre></td></tr></table></figure>
<p>위와 같이 작성하게 되면 어느 쪽에 응답이 먼저 오더라도 data.url을 보고 해당하는 결과를 res[0] 또는 res[1]에 담을 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  a = x * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">    baz();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  b = y * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">    baz();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ajax()는 라이브러리에 있는 임의의 AJAX 함수</span></span><br><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, foo);</span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.2'</span>, bar);</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 <code>if (a &amp;&amp; b) { baz() }</code>의 조건은 관문(Gate)라 부른다. <em>a와 b 둘 중 누가 먼저 도착할지 알 수 없지만 반드시 둘 다 도착한 다음에 baz()함수가 호출이 되는, 즉 관문이 열리기 때문이다.</em> 이 코드가 존재하지 않다면 baz() 함수가 초기에는 a,b가 undefined인 상태에서도 호출이 되어 제대로 작동하지 않는다. 이와 다르게 둘 다 도착했을 때가 아닌, 둘 중 하나만 도착했을 때 상호 작용하도록 하는 코드도 있다. 이는 관문(Gate)보다 <em>걸쇠(Latch)로 불리고, 선착순 한 명만 이기는 형태이다.</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">    a = x * <span class="number">2</span>;</span><br><span class="line">    baz();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">for</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">    a = x / <span class="number">2</span>;</span><br><span class="line">    baz();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ajax()는 라이브러리에 있는 임의의 AJAX 함수</span></span><br><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, foo);</span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line">ajax(<span class="string">'http://some.url.2'</span>, bar);</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 <code>if (!a) {}</code>와 같은 코드를 걸쇠(Latch)라 부른다. foo()나 bar() 둘 중 첫 번째 실행된 함수만이 이 조건을 통과하고 늦게 실행된 함수 호출은 무시되기 때문이다.</p>
<hr>
<h2 id="콜백"><a href="#콜백" class="headerlink" title="콜백"></a>콜백</h2><p>콜백은 백그라운드에서 코드 실행을 시작할 함수를 호출할 때 인수로 지정된 함수이다. 백그라운드 코드 실행이 끝나면 콜백 함수를 호출해서 작업이 완료되었음을 아리거나 다음 작업을 실행하게 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  alert(<span class="string">'You clicked me!'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pElem = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">  pElem.textContent = <span class="string">'This is a newly-added paragraph.'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(pElem);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>위의 함수에서 콜백은 addEventListener()의 click 옆의 두 번째 매개변수이다. 이벤트가 실행 될 때 이 콜백 함수가 호출된다. callback 함수를 다른 함수의 인수로 전달할 때, 함수의 참조를 인수로 전달할 뿐이지 즉시 실행되지 않고, 함수의 body에서 “called back”된다. 즉 정의된 함수는 때가 되면 callback 함수를 실행하는 역할을 한다. 또한 콜백은 <strong>자바스크립트에서 비동기성을 표현하고 관리하는 가장 일반적인 기법이자 가장 기본적인 <code>비동기 패턴</code>이다.</strong></p>
<h3 id="콜백의-실체"><a href="#콜백의-실체" class="headerlink" title="콜백의 실체"></a>콜백의 실체</h3><h4 id="연속성"><a href="#연속성" class="headerlink" title="연속성"></a>연속성</h4><p>비동기 코드 작성의 어려움은 콜백 함수의 연속성과 인간 두뇌의 연속성의 개념이 다르기 때문이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line">ajax(<span class="string">"..."</span>, <span class="function"><span class="keyword">function</span>(<span class="params">..</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//c</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure>
<p>위와 같은 코드가 있다고 했을 때, <code>지금</code>에 해당하는 전반부 코드(A,B)가 실행되면 비결정적(indeterminate) 시간 동안 중지되고 언젠가 AJAX 호출이 끝날 때 중지되기 이전 위치로 다시 돌아와서 나머지 후반부(C)프로그램이 이어진다. 즉 콜백 함수는 프로그램의 연속성을 감싼(캡슐화)한 장치이다. 그런데 이러한 코드는 순차적으로 task를 처리하는 두뇌의 처리방식과 다른 순서를 같기 때문에 추론이 어렵다. 즉 위와 같은 코드를 보면 두뇌는 A -&gt; C -&gt; B의 순서대로 작성된 코드를 읽어내려가며 추론하려 할 것이다. 하지만 실질적인 코드는 A -&gt; B -&gt; C의 순서대로 실행하기 때문에 이러한 괴리감 때문에 비동기 처리를 이해하기 어렵게 만든다.</p>
<h4 id="콜백지옥"><a href="#콜백지옥" class="headerlink" title="콜백지옥"></a>콜백지옥</h4><p>비동기 처리를 위해 콜백을 중첩 또는 연속해서 사용되면 아래와 같은 콜백 지옥이 발생한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">listen(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ajax(<span class="string">'http://some.url.1'</span>, <span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (text == <span class="string">'hello'</span>) &#123;</span><br><span class="line">        handler();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">'world'</span>) &#123;</span><br><span class="line">        request();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>이러한 콜백 지옥으로 거론되는 첫 번째 문제는 콜백을 연속해서 쓰다보니 점점 들여쓰기가 되면서 가독성이 떨어져서 유지 보수를 어렵게 하는 것이다. 하지만 들여쓰기로 인한 가독성 저하보다 코드를 너무 복잡하게 만든다는 점이 더 큰 문제이다. 중접된 콜백으로 인한 가독성 저하를 막기 위해 콜백 작성시 조건을 작성해서 좀 더 가독성을 높일 수 있는데, <em>이러한 하드 코딩은 사실 코드를 더 복잡하게 만들고, 코드가 복잡해지는 것이야말로 유지보수를 어렵게 만든다.</em> 즉 콜백의 단계별 맞닥뜨릴 수 있는 경우의 수를 분기처리해 줄 수 있는데, 분기처리를 해야하는 가능한 경우의 수를 나열하다보면 코드가 방대해지고, 작성된 구문이 모든 경우의 수를 커버하라는 보장도 없다.</p>
<h4 id="믿음성-문제"><a href="#믿음성-문제" class="headerlink" title="믿음성 문제"></a>믿음성 문제</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line">ajax(<span class="string">"..."</span>, <span class="function"><span class="keyword">function</span>(<span class="params">..</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//c</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure>
<p>위와 같은 함수는 <code>제어권을 주고받는 행위</code>가 발생한다. A,B가 자바스크립트 메인 프로그램의 제어를 받으며 <code>지금</code> 실행된다면 C는 다른 프로그램(ajax() 함수)의 제어하에 <code>나중에</code> 실행된다. <em>이 제어권 교환이야말로 콜백 중심적 설계의 가장 큰 문제점이다.</em> 위 코드에서 쓰인 ajax()처럼 콜백을 넘겨주는 코드는 개발자가 직접 제어할 수 있는 함수가 아니라 서드 파티가 제공한 유틸리티인 경우가 대부분이다. 이렇게 내가 작성하는 프로그램인데도 실행 흐름은 서드 파티에 의존해야 하는 상황을 <code>제어의 역전</code>이라 한다. 그래서 비동기 콜백 함수를 작성한 경우, 콜백 자체에 대해 개발자가 직접 제어할 수 없기 때문에, 콜백 호출 시 오류가 날 수 있는 상황에 대한 여러가지 보완 로직을 구현하기 마련이다. 예를 들어 콜백을 너무 일찍 부르거나 너무 늦게 부른다거나, 너무 많이 부른다거나 하는 등의 잘못 될 가능성이 있는 상황에 대한 보완 로직을 작성해 두는 것이다. 하지만 보완 로직을 작성했다고 해도 서드 파티의 처리에서 무언가 문제가 생기면 완전히 잘못 틀어질 수도 있다. 그래서 이런 믿음성의 문제를 해결하기 위해 몇 가지 콜백 체계가 존재한다.</p>
<ul>
<li>분할 콜백</li>
<li>에러 우선 스타일</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//분할 콜백 - 한쪽은 성공, 한쪽은 실패</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">failure</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, succes, failure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//에러 우선 - 성공 시 빈/falsy 객체, 실패 시 truthy/에러 객체로 세팅됨.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//에러인가?</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//아니면 성공한 것</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(<span class="string">'http://some.url.1'</span>, response);</span><br></pre></td></tr></table></figure>
<p>언뜻 보면 믿음성에 대한 문제가 해결된 것 같지만 원하지 않는 반복적인 호출을 방지하거나 걸러내는 콜백 기능은 전혀 없다. 오히려 성공/에러를 동시에 받거나 전혀 받지 못하는 상황에 대해서도 고려해야 하고, 이렇게 표준적인 형태로 작성되었어도 재사용이 불가하거나 장황한 관용 코드라서 콜백을 쓸 때마다 매번 새로 타이핑을 해주어야 할 수 있다.</p>
<p><em>정리하자면 콜백이 자바스크립트의 비동기성을 표현하는 기본 단위로써 충분히 그 역할을 다 해왔지만, 점점 진화하는 비동기 프로그래밍 환경에 대응하기에는 충분하지 않다.</em><br>첫 번째 이유는 연속성의 문제로 사람의 두뇌는 순차적이고, 단일-스레드 방식으로 계획하는데 익숙하지만 콜백은 비동기 흐름을 비선형적, 비순차적으로 나타내기 때문에 그 괴리감으로 인해 구현된 코드를 사람이 이해하기가 쉽지 않다. 이렇게 추론하기 어려운 코드는 악성 버그를 품을 가능성을 내재한 코드가 된다. 두 번째, 콜백이 프로그램을 진행하기 위해 제어권을 다른 파트(e.g. 서드파티 유틸리티)로 넘겨줘야 하는데, 이렇게 제어권이 넘어가면 믿음성의 문제에 봉착해서 콜백이 잘못될 가능성에 대해 구구절절한 보완 로직을 작성하게 된다. 이렇게 작성하면 믿음성의 문제는 해결할 수 있을지라도 거칠과 유지보수가 어려운 방대하고 복잡한 코드가 되고, 실제로 100% 믿음성의 문제를 해결했다고 보기도 어렵다. 모든 케이스에 대해 보완 로직을 작성했다고 해도, 제어권이 넘어간 상태에서 발생한 일까지 대응할 수는 없기 때문이다.</p>
<p>결국 이렇게 제기된 문제들을 해결하려면 콜백을 능가하는 조금 더 나은 해결법이 필요하고, 그런 배경 아래 등장한 것이 <code>프로미스</code>이다.</p>
<hr>
<p><em>References</em><br><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Introducing#async_callbacks" target="_blank" rel="noopener">callback</a><br>[YOU DON’T KNOW JS] 카일 심슨 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/21/220322_blockchain_22to23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/21/220322_blockchain_22to23/" class="post-title-link" itemprop="url">블록체인 무엇인가? 4장 블록체인은 한계는 무엇이고 어떻게 극복할 것인가? 22 ~ 23단계</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-22 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-22T00:00:00+09:00">2022-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-06 23:40:24" itemprop="dateModified" datetime="2022-12-06T23:40:24+09:00">2022-12-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="22-냉정하게-한계점-바라보기"><a href="#22-냉정하게-한계점-바라보기" class="headerlink" title="22. 냉정하게 한계점 바라보기"></a>22. 냉정하게 한계점 바라보기</h2><h3 id="블록체인-시스템이-가진-기술적-제약사항"><a href="#블록체인-시스템이-가진-기술적-제약사항" class="headerlink" title="블록체인 시스템이 가진 기술적 제약사항"></a>블록체인 시스템이 가진 기술적 제약사항</h3><blockquote>
<ol>
<li>개인정보 보호의 부재</li>
<li>보안 모델</li>
<li>제한적 확장성</li>
<li>고비용</li>
<li>숨겨진 중앙 통제</li>
<li>유연성의 부재</li>
<li>임계 크기</li>
</ol>
</blockquote>
<h4 id="1-개인정보-보호의-부재"><a href="#1-개인정보-보호의-부재" class="headerlink" title="1. 개인정보 보호의 부재"></a>1. 개인정보 보호의 부재</h4><p>블록체인에서 발생하는 모든 트랜잭션에 대한 정보는 상세히 기록되고 누구나 읽을 수 있다. 이렇게 정보는 보호되지 않지만 개인정보는 철저히 보호된다. 하지만 개인정보가 누구의 것인지 상세하게 알 수 없기 때문에 개인정보 보호의 부재라기보다 개인정보의 부재라고 볼 수 있고, 이런 것을 중요시하는 응용 분야에서는 이로부터 비롯되는 제약사항이 있을 수 있다.</p>
<h4 id="2-보안-모델"><a href="#2-보안-모델" class="headerlink" title="2. 보안 모델"></a>2. 보안 모델</h4><p>블록체인에서 트랜잭션 승인을 위해 <code>비대칭 암호화 기법</code>을 사용하는데 이는 가장 강력한 기법이기 때문에 강력한 보안이 가능하다. 하지만 블록체인 사용자가 개인 키를 분실하거나 개인 키가 타인의 손으로 넘어간 경우 계정 주인을 보호할 수 있는 추가 안전 장치가 없다. 비트코인은 개인 키의 해킹 등에 대비하는 몇 가지 안전장치를 제시하고 있다. 하지만 기본적으로 개인 키를 분실한 순간 보안은 무너졌다고 볼 수 있다.</p>
<h4 id="3-제한적-확장성"><a href="#3-제한적-확장성" class="headerlink" title="3. 제한적 확장성"></a>3. 제한적 확장성</h4><p>블록체인은 누구나 새로운 트랜잭션 데이터를 추가할 수 있도록 개방되어 있는 한편, 트랜잭션 데이터가 조작되거나 위조되지 않도록 보장해야 한다. 이를 위해 새로운 블록이 추가될 때마다 해시 퍼즐을 풀어야 하는데, 이 퍼즐을 풀 때 상당히 많은 계산량이 소모되도록 설계되어 있다. 이는 트랜잭션의 조작을 막는 것에 좋은 방법이지만 <em>빠른 처리속도와 높은 확장성, 대용량 처리가 필요한 응용분야에서는 오히려 걸림돌이될 수 있다.</em></p>
<h4 id="4-고비용"><a href="#4-고비용" class="headerlink" title="4. 고비용"></a>4. 고비용</h4><p>제한된 확장성과 관련 있는데, 해시 퍼즐을 풀 때 많은 계산량을 소모한다는 것은 그만큼 많은 비용(필요 계산 사이클, 물리적 시간, 소모 전력량 등)을 유발한다는 것이고, 전체 비용은 해시 퍼즐의 난이도에 달려있다.</p>
<h4 id="5-숨겨진-중앙-통제"><a href="#5-숨겨진-중앙-통제" class="headerlink" title="5. 숨겨진 중앙 통제"></a>5. 숨겨진 중앙 통제</h4><p>해시 퍼즐을 해결하기 위해 특화된 하드웨어에 투자하여 더 많은 보상을 받아서 이윤을 창출하는 사람들이 있는데, 이와 반대로 특화된 하드웨어가 없는 사람은 전자에 비해 밀릴 수 밖에 없어 시스템을 떠나게 된다. 따라서 특화된 하드웨어로 강력한 계산 능력을 갖춘 소수만 남아 시스템을 장악하는 상황을 초래할 수 있고, 이 소수가 시스템의 무결성을 유지하는 책임을 나눠가지게 된다. 이렇게 되면 사실상 보이지 않는 중앙 통제 집단을 형성하여 피어 그룹이 집단적으로 무결성을 유지하도록 하는 분산 시스템의 근본을 위협한다. <em>즉 기술적으로는 분산 시스템이지만 시스템의 무결성은 소수의 개체에 의해서만 유지되는 것이다.</em></p>
<h4 id="6-유연성의-부재"><a href="#6-유연성의-부재" class="headerlink" title="6. 유연성의 부재"></a>6. 유연성의 부재</h4><p>블록체인을 일단 가동하고 나면 변경, 업그레이드와 관련된 체계적 절차가 따로 없다. 이런 불변성은 블록체인 개발자가 체인 프로토콜의 버그를 고치거나 수정하기 어렵게 하고, 전체 블록체인-기술-모음을 유연성이 떨어지게 만든다.</p>
<h4 id="7-임계-크기"><a href="#7-임계-크기" class="headerlink" title="7. 임계 크기"></a>7. 임계 크기</h4><p><em>트랜잭션 데이터를 조작으로부터 보호하여 신뢰성을 확보하는 장치는 대다수의 시스템 계산 자원이 <code>정직한 노드에 의해 통제</code>된다는 가정에 기반한다.</em> 그래서 모든 블록체인이 엄청난 계산력을 갖춘 공격자로부터 시스템을 보호하기 위해 <code>최소한의 정직한 노드</code>가 필요하다.</p>
<h3 id="비기술적-문제-2가지"><a href="#비기술적-문제-2가지" class="headerlink" title="비기술적 문제 2가지"></a>비기술적 문제 2가지</h3><blockquote>
<ol>
<li>법적 수용성 부재</li>
<li>사용자 수용성 부재</li>
</ol>
</blockquote>
<h4 id="1-법적-수용성-부재"><a href="#1-법적-수용성-부재" class="headerlink" title="1. 법적 수용성 부재"></a>1. 법적 수용성 부재</h4><p>블록체인으로 분산 합의를 통해 소유권 이전 및 관리를 하는 것은 법적 효력에 대한 해석 문제를 야기하고, 이는 법적 제도 장치의 결여를 의미한다.</p>
<h4 id="2-사용자-수용성-부재"><a href="#2-사용자-수용성-부재" class="headerlink" title="2. 사용자 수용성 부재"></a>2. 사용자 수용성 부재</h4><p>법적 수용성 부재와 같은 요소가 사용자들의 블록체인에 대한 불확실성을 가지게 하고, 사용 결정에 대한 관심을 감소시킨다. 또 지식과 교육의 부재로 기본 작동 원리에 대해 모르기 때문에 블록체인에 대해 신뢰하기도 어렵다.</p>
<h3 id="어떻게-극복할-것인가"><a href="#어떻게-극복할-것인가" class="headerlink" title="어떻게 극복할 것인가?"></a>어떻게 극복할 것인가?</h3><h4 id="기술적-문제"><a href="#기술적-문제" class="headerlink" title="기술적 문제"></a>기술적 문제</h4><p>➡️ 모든 구성요소와 기술 수준을 조정한다. 블록체인의 기술적 제약사항을 극복하는 데 있어 주요 걸림돌은 기술을 개선하는 것과 기본 기술을 변경하는 것에 대한 구분이다.</p>
<h4 id="비기술적-문제"><a href="#비기술적-문제" class="headerlink" title="비기술적 문제"></a>비기술적 문제</h4><p>➡️ 교육과 법제도의 개선이 적절한 수단이 될 수 있다.</p>
<hr>
<h2 id="23-다시-태어난-블록체인"><a href="#23-다시-태어난-블록체인" class="headerlink" title="23. 다시 태어난 블록체인"></a>23. 다시 태어난 블록체인</h2><h3 id="블록체인의-서로-상충되는-목표"><a href="#블록체인의-서로-상충되는-목표" class="headerlink" title="블록체인의 서로 상충되는 목표"></a>블록체인의 서로 상충되는 목표</h3><blockquote>
<ol>
<li>투명성 vs 개인정보 보호</li>
<li>보안 vs 속도</li>
</ol>
</blockquote>
<h4 id="1-투명성-vs-개인정보-보호"><a href="#1-투명성-vs-개인정보-보호" class="headerlink" title="1. 투명성 vs 개인정보 보호"></a>1. 투명성 vs 개인정보 보호</h4><p>블록체인이 소유권을 검증하는 핵심 개념이 개방성과 투명성이다. 개인정보 보호는 트랜잭션에 연계된 계좌번호나 이체금액 등의 세부 사항이 공개되지 않도록 하는 것인데, 소유권 명확화를 위해 모든 트랜잭션이 투명하게 관리되는 것과 서로 충돌한다.</p>
<h4 id="2-보안-vs-속도"><a href="#2-보안-vs-속도" class="headerlink" title="2. 보안 vs 속도"></a>2. 보안 vs 속도</h4><p>블록체인은 트랜잭션 데이터를 보호하기 위해 해시 퍼즐을 풀 때 많은 계산량을 요구로 하는데, 이런 성질 때문에 속도와 확장성에 정면으로 반한다.</p>
<h3 id="갈등의-근본-원인은-읽기와-쓰기-권한에-있다"><a href="#갈등의-근본-원인은-읽기와-쓰기-권한에-있다" class="headerlink" title="갈등의 근본 원인은 읽기와 쓰기 권한에 있다"></a>갈등의 근본 원인은 읽기와 쓰기 권한에 있다</h3><div class="table-container">
<table>
<thead>
<tr>
<th>기술적 제약사항</th>
<th>갈등 요소</th>
<th>기본 기능</th>
</tr>
</thead>
<tbody>
<tr>
<td>개인정보 보호 부재</td>
<td>투명성 vs 개인정보 보호</td>
<td>트랜잭션 데이터 이력 읽기</td>
</tr>
<tr>
<td>확장성 부재</td>
<td>보안 vs 속도</td>
<td>트랜잭션 데이터 쓰기</td>
</tr>
</tbody>
</table>
</div>
<h3 id="갈등-해결-4가지-버전의-블록체인을-등장시키다"><a href="#갈등-해결-4가지-버전의-블록체인을-등장시키다" class="headerlink" title="갈등 해결, 4가지 버전의 블록체인을 등장시키다"></a>갈등 해결, 4가지 버전의 블록체인을 등장시키다</h3><p>갈등은 절충점을 찾거나 한쪽의 희생을 감수하고 다른 한쪽을 선택하면 해결된다.</p>
<h4 id="투명성과-개인정보-중-선택"><a href="#투명성과-개인정보-중-선택" class="headerlink" title="투명성과 개인정보 중 선택"></a>투명성과 개인정보 중 선택</h4><p>데이터를 읽을 권한을 누구에게 줄 것인가를 정하는 문제이다.</p>
<ul>
<li>공개 블록체인: 모든 사용자와 노드에게 트랜잭션 데이터를 읽을 수 있는 권한을 부여한다. (모두에게 읽기 권한 부여)</li>
<li>비밀 블록체인: 사전에 선택된 사용자와 노드에게만 트랜잭션 데이터를 읽을 수 있는 권한을 부여한다. (제한된 사용자와 노드 그룹에게만 읽기 권한 부여)</li>
</ul>
<h4 id="보안과-속도-중-선택"><a href="#보안과-속도-중-선택" class="headerlink" title="보안과 속도 중 선택"></a>보안과 속도 중 선택</h4><ul>
<li>무승인형 블록체인: 모두에게 쓰기 권한을 부여한다. 즉 누구나 트랜잭션을 검증하고 새 블록을 추가할 수 있다.</li>
<li>승인형 블록체인: 온-보딩 프로세스를 거쳐 신뢰성이 확인된 소수의 노드와 사용자 그룹에게만 쓰기 권한을 허용한다. 쓰기 권한을 받은 소수마 트랜잭션의 검증과 분산 동의에 참가할 수 있다.</li>
</ul>
<h3 id="블록체인의-네-가지-버전-어떤-점이-다를까"><a href="#블록체인의-네-가지-버전-어떤-점이-다를까" class="headerlink" title="블록체인의 네 가지 버전, 어떤 점이 다를까?"></a>블록체인의 네 가지 버전, 어떤 점이 다를까?</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th style="text-align:center">읽기와 트랜잭션 생성 권한</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td style="text-align:center">모두 허용</td>
<td>허가된 사용자만 허용</td>
</tr>
<tr>
<td>쓰기권한</td>
<td>모두 허용</td>
<td style="text-align:center">공개&amp;무승인</td>
<td>비밀&amp;무승인</td>
</tr>
<tr>
<td></td>
<td>허가된 사용자만 허용</td>
<td style="text-align:center">공개&amp;승인</td>
<td>비밀&amp;승인</td>
</tr>
</tbody>
</table>
</div>
<p>위의 조합괸 버전들은 블록체인의 다음 세 가지 측면에 영향을 미친다.</p>
<blockquote>
<ol>
<li>P2P 아키텍처</li>
<li>분산 속성</li>
<li>목적</li>
</ol>
</blockquote>
<h4 id="1-P2P-아키텍처"><a href="#1-P2P-아키텍처" class="headerlink" title="1. P2P 아키텍처"></a>1. P2P 아키텍처</h4><p>시스템에 참여한 모든 컴퓨터에게 동등한 권리와 역할을 부여해야 하는데, 위에서 설명된 버전 중 일부는 <em>시스템을 구성하는 노드별로 읽기와 쓰기 권한에 차별을 둔다.</em> 따라서 동등한 권리와 역할을 부여한다는 P2P 시스템의 중요한 특성에 위배된다.</p>
<h4 id="2-분산-속성"><a href="#2-분산-속성" class="headerlink" title="2. 분산 속성"></a>2. 분산 속성</h4><p>분산 시스템에서 중앙 통제나 조정장치가 없어야 한다. 그러나 위에서 설명된 버전 중 일부는 읽기와 쓰기 권한을 사전에 승인한 노드나 사용자 그룹으로 제한하고 있다. 그리고 이런 승인과 권한에 관한 규칙이 순수 분산 시스템에 의해 유지되고 관리되지 않는다면 중앙 통제 요소가 있다는 것이어서 분산 속성에 위배된다. 또 숨은 중앙 통제 요소가 있거나 내부적으로 분산 시스템을 활용하지만 모든 노드에게 접근제한이 있는 중앙 통제 시스템을 볼 수 있는데 이 경우 모두 분산과 중앙 통제 요소로 구성된 혼합시스템에 가깝다.</p>
<h4 id="3-목적"><a href="#3-목적" class="headerlink" title="3. 목적"></a>3. 목적</h4><p>읽기와 쓰기 권한에 제한을 두는 것은 분산 P2P 시스템의 기본 성질을 변형시킬 뿐 아니라 노드의 신뢰성도 변화시킨다. 하지만 안정성과 신뢰성을 알 수 있는 특정된 개수의 노드로 구성된 환경에서도 블록체인의 역할이 존재한다.</p>
<ul>
<li>기술적 결함이나 컴퓨터 고장으로 작동하는 노드의 개수가 변경될 수 있다.</li>
<li>모든 분산 시스템은 네트워크 장애로 인해 개별 메시지단위의 통신이 안정적이지 못하다.</li>
<li>노드의 신뢰성을 100% 수준으로 보장할 수 없다.</li>
</ul>
<h3 id="블록채인의-목적-다시-정의하기"><a href="#블록채인의-목적-다시-정의하기" class="headerlink" title="블록채인의 목적 다시 정의하기"></a>블록채인의 목적 다시 정의하기</h3><p>노드별로 읽기와 쓰기 권한에 제약을 두면 블록체인의 주요 측면과 상충하는데 제약이 가장 많은 비밀-승인형 블록체인에서도 여전히 무결성 유지에 아주 중요하다.</p>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/20/220321_blockchain19_21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/20/220321_blockchain19_21/" class="post-title-link" itemprop="url">블록체인 무엇인가? 3장 블록체인은 어떻게 작동하는가? 19 ~ 21단계</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-21 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-21T00:00:00+09:00">2022-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-06 23:40:24" itemprop="dateModified" datetime="2022-12-06T23:40:24+09:00">2022-12-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="19-컴퓨터들도-라인을-잘-타야-살아남는다"><a href="#19-컴퓨터들도-라인을-잘-타야-살아남는다" class="headerlink" title="19. 컴퓨터들도 라인을 잘 타야 살아남는다"></a>19. 컴퓨터들도 라인을 잘 타야 살아남는다</h2><p>시스템의 개별 노드가 유지하고 있는 트랜잭션 이력이 서로 달라 충돌이 생길때 문제를 어떻게 해결할지 알아본다.</p>
<h3 id="목표"><a href="#목표" class="headerlink" title="목표"></a>목표</h3><p><em>네트워크 내 모든 노드가 명확한 단일 트랜잭션 이력만 유지하도록 하여</em> 어느 노드가 소유권 확인 요청을 처리하든 항상 동일한 결과가 산출되도록 한다.</p>
<h3 id="해결해야-할-과제"><a href="#해결해야-할-과제" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><p>블록체인-알고리즘에는 중앙 통제 장치가 없기 때문에 개별 노드의 수신함에 도착한 새 블록이 그 노드가 무슨 일을 해야 할지 알려준다. 각 노드는 어떤 메시지가 도착했냐에 따라 작업을 전환하는데 같은 시간에 모든 노드의 작업 전환이 동시에 발생하는 것이 아니므로 개별 노드의 작업 상태에 중첩이 생길 수 있다. 이처럼 메시지 전달 과정에서 문제가 발생했을 때 <strong>명확한 단일 트랜잭션 이력을 식별하는 방법을 찾아야 한다.</strong></p>
<h3 id="아이디어"><a href="#아이디어" class="headerlink" title="아이디어"></a>아이디어</h3><blockquote>
<p>모든 노드가 단일 버전의 트랜잭션 이력을 선택한다.</p>
</blockquote>
<p>집단적 의사결정 문제에서 동의나 합의에 이르는 과정을 <code>분산 합의</code>라 부르는데 집단적 의사결정 상황은 다음의 네 가지를 충족한다.</p>
<ul>
<li>모든 노드는 네트워크, 블록체인-데이터-구조의 개별 복사본을 유지하는 노드들, 노드들의 행동을 통제하는 블록체인-알고리즘으로 구성된 <strong>동일한 환경에서 작동한다.</strong></li>
<li><strong>집단적 의사결정 문제는 단일 트랜잭션 이력을 선택하는 것이다.</strong></li>
<li>모든 노드는 수입을 최대화하기 위해 블록체인-데이터-구조에 <strong>유효한 새 블록을 추가하고 보상을 받으려 노력한다.</strong></li>
<li>모든 노드는 목표 달성을 위해 자신이 생성한 새 블록을 피어들에게 보내 검사받고 인정받으려 한다. 그 결과 각 노드는 집단적으로 유지되는 블록체인-데이터-구조 환경에 개별적인 흔적을 남기게 된다.</li>
<li>환경 변화에 기반한 동일한 기준을 사용해 의사결정 문제를 평가한다. <em>여기서 기준은 각 트랜잭션 이력을 생성하기 위해 사용한 계산 노력의 누적 총합이고, 둘 이상의 상충된 트랜잭션에서 조작된 데이터를 분별하기 위한 기준으로 활용된다.</em></li>
</ul>
<h3 id="작동원리"><a href="#작동원리" class="headerlink" title="작동원리"></a>작동원리</h3><h4 id="계산-노력을-판단하는-기준"><a href="#계산-노력을-판단하는-기준" class="headerlink" title="계산 노력을 판단하는 기준"></a>계산 노력을 판단하는 기준</h4><h3 id="가장-긴-체인-기준"><a href="#가장-긴-체인-기준" class="headerlink" title="가장-긴-체인 기준"></a>가장-긴-체인 기준</h3><p>새 블록을 만들어 기존 체인을 확장하려고 할 때, 어떤 노드는 해시 퍼즐을 해결하여 새 블록을 피어들에게 전송하여 블록-체인-데이터 구조를 형성할 것이다. 그리고 이렇게 가장 최근 추가된 새 블록을 이전 노드로 만드는 또다른 새 블록을 만들기 위해 노력하게 될텐데 이는 곧 <em>세 개의 블록으로 구성된 오직 한 가지 버전의 블록체인-데이터-구조만 존재한다는 것이다.</em> 단 네트워크 상의 문제로 인해 새 노드를 전달받지 못하는 상황에서 전달받지 못한 노드 중 하나가 해시 퍼즐을 해결하여 다른 피어들에게 해시값을 전송하게 되면 <strong>대다수의 피어들이 2개의 블록을 수신하게 된다.</strong> 이런 경우 상단에 두 개의 가지가 뻗어있는 블록체인-데이터-구조를 유지하게 되는데, 체인의 길이가 같다면 각 노드는 어느 쪽 가지를 확장할 지 임의로 정한다. 그런데 이때도 앞서 말한 두 개의 블록을 수신하게 되는 상황이 발생할 수 있다. 결국 가장-긴-체인 기준을 적용하면 대다수의 노드 그리고 궁극적으로 시스템의 모든 노드가 소유권의 명확화와 관련된 요청에 대해 이 체인을 사용하게 되고, <strong>블록체인-데이터-구조는 일직선으로 이어진 체인이 아니라 트리나 원주형 선인장처럼 생긴 구조를 가지게 된다.</strong></p>
<h3 id="가장-무거운-체인-기준"><a href="#가장-무거운-체인-기준" class="headerlink" title="가장-무거운-체인 기준"></a>가장-무거운-체인 기준</h3><p>가장 많은 블록을 가지고 있는 경로가 가장 많은 계산 노력을 소모한 것이라는 가정 하에 가장-긴-체인 기준에 대해 살펴보았다. <em>그런데 난이도가 블록마다 다를 때 가장 긴 경로가 반드시 가장 많은 계산 노력을 소모했다는 보장이 없다.</em> 각 경로별로 실제로 사용된 계산 노력을 측정하려면 각 블록 헤더의 난이도를 모두 더하면 된다. 이렇게 계산해보면 가장-긴-체인이 반드시 가장 많은 계산 노력을 소모한 것은 아니라는 사실을 알 수 있고, 이 때문에 동적으로 난이도를 결정하는 블록체인은 가장-무거운-체인 기준으로 가장 무거운 체인을 가진 트랜잭션 데이터 이력을 선택하다.</p>
<h3 id="선택받지-못한-체인은-어떻게-될까"><a href="#선택받지-못한-체인은-어떻게-될까" class="headerlink" title="선택받지 못한 체인은 어떻게 될까?"></a>선택받지 못한 체인은 어떻게 될까?</h3><p>특정 체인을 선택하면 다음의 결과가 나온다.</p>
<blockquote>
<p>고아 블록<br>보상 회수<br>소유권 명확화<br>트랜잭션 재처리<br>공통 몸통의 성장<br>궁극적 일관성<br>조작에 대한 견고성</p>
</blockquote>
<h4 id="1-고아-블록"><a href="#1-고아-블록" class="headerlink" title="1. 고아 블록"></a>1. 고아 블록</h4><p>권위 체인이 선정되면, 트리-모양 데이터 구조 내 권위 체인 경로에 속하지 않은 블록은 모두 버려진다.</p>
<h4 id="2-보상-회수"><a href="#2-보상-회수" class="headerlink" title="2. 보상 회수"></a>2. 보상 회수</h4><p>고아 블록은 권위 체인에 기여하지 않으므로 소유권 명확화에 아무 쓸모가 없고, 고아 블록을 생성하고 제출해서 보상을 받았던 노드들로부터 보상을 회수한다.</p>
<h4 id="3-소유권-명확화"><a href="#3-소유권-명확화" class="headerlink" title="3. 소유권 명확화"></a>3. 소유권 명확화</h4><p>권위 체인에 속한 트랜잭션들만 실제로 발생한 것으로 인정받아 소유권 명확화에 사용된다.</p>
<h4 id="4-트랜잭션-제자리"><a href="#4-트랜잭션-제자리" class="headerlink" title="4. 트랜잭션 제자리"></a>4. 트랜잭션 제자리</h4><p>고아 블록에 소속돼 버려진 트랜잭션 데이터는 노드의 수신함에 넣어져 재처리된 후 블록체인-데이터-구조에 다시 추가되어 선택된 트랜잭션 이력의 일부가 될 기회를 한 번 더 부여받는다.</p>
<h4 id="5-공통-몸통의-성장"><a href="#5-공통-몸통의-성장" class="headerlink" title="5. 공통 몸통의 성장"></a>5. 공통 몸통의 성장</h4><p>트랜잭션 이력의 상충되는 버전은 덜 모호한 공통 몸통으로부터 뻗어나온 것이므로 깊이 들여다볼수록 해당 블록이 가장 긴 체인의 일부인지 아닌지가 명확해진다.</p>
<h4 id="6-궁극적-일관성"><a href="#6-궁극적-일관성" class="headerlink" title="6. 궁극적 일관성"></a>6. 궁극적 일관성</h4><p>가장-긴-체인-기준이 모호할 때 추가된 다음 블록에 의해 어느 것이 가장 긴 체인의 일부가 될지 결정하는데, <em>이 다음 블록이 블록체인-데이터-구조의 어디에 붙어서 가지를 확장할지는 노드가 알아서 결정한다.</em> 트리-모양 블록체인-데이터-구조는 해시 퍼즐의 속도 경쟁과 네트워크를 통한 메시지 전달의 임의 변동성에 영향을 받으려 무작위로 성장하는데 선택된 가지들은 몸통에 그대로 붙어있다. 따라서 권위 체인의 정상이나 그 근처 블록들은 새 블록이 랜덤으로 도착하는 성질에 영향을 많이 받는다. <em>시간이 지나 더 많은 블록이 추가될수록 권위 체인에 포함될 가능성이 더 높아지는 현상을 궁긍적 일관성이라 부른다.</em></p>
<h4 id="7-조작에-대한-견고성"><a href="#7-조작에-대한-견고성" class="headerlink" title="7. 조작에 대한 견고성"></a>7. 조작에 대한 견고성</h4><p>트리-모양의 블록체인-데이터-구조 중 가장 계산 노력이 가장 많이 들어간 경로가 트랜잭션 이력의 권위 있는 버전이다. 블록체인-데이터-구조 내부의 특정 블록에서 시작하는 새로운 권위 경로를 만들려면 대다수가 유지하고 있는 경로를 따라잡고 앞질러야 하고, 이 점이 블록체인이 가진 견고성의 기초가 된다. 즉 공격자가 내부 블록을 조작하려한다면 작업 증명을 다시 하고, 모든 후속 블록의 해시 퍼즐을 다시 풀어서 정직한 노드들이 유지하고 있는 경로를 따라잡아야 하는데 사실상 불가하고, 결론적으로 시스템이 유지하는 트랜잭션 이력은 조작으로부터 견고하다.</p>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/19/220320_blockchain03_16to18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/19/220320_blockchain03_16to18/" class="post-title-link" itemprop="url">블록체인 무엇인가? 3장 블록체인은 어떻게 작동하는가? 16 ~ 18단계</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-20T00:00:00+09:00">2022-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-06 23:40:24" itemprop="dateModified" datetime="2022-12-06T23:40:24+09:00">2022-12-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="16-블록체인이-데이터를-보호하는-방법"><a href="#16-블록체인이-데이터를-보호하는-방법" class="headerlink" title="16. 블록체인이 데이터를 보호하는 방법"></a>16. 블록체인이 데이터를 보호하는 방법</h2><h3 id="목표"><a href="#목표" class="headerlink" title="목표"></a>목표</h3><p>블록체인이 유지하는 <strong>전체 트랜잭션 이력을 불변성 데이터로 만들어 위조나 조작이 없게 한다.</strong></p>
<h3 id="해결해야-할-과제"><a href="#해결해야-할-과제" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><p>누구에게나 개방된 순수 분산 P2P 시스템을 개방한 채 조작이나 위조의 위협으로부터 트랜잭션 데이터를 보호한다.</p>
<h3 id="아이디어"><a href="#아이디어" class="headerlink" title="아이디어"></a>아이디어</h3><p>처음부터 아무도 이력을 조작하지 못하게 막아놓는다.</p>
<h3 id="불변성은-읽기-전용의-다른-이름"><a href="#불변성은-읽기-전용의-다른-이름" class="headerlink" title="불변성은 읽기 전용의 다른 이름"></a>불변성은 읽기 전용의 다른 이름</h3><p>불변성 데이터는 한번 생성되면 절대로 변경될 수 없고, 이러한 데이터는 읽기 전용 데이터라고도 한다. 데이터를 변경과 조작으로부터 보호하는 효과적인 방법이다.</p>
<h2 id="작동원리"><a href="#작동원리" class="headerlink" title="작동원리"></a>작동원리</h2><blockquote>
<p>트랜잭션 이력을 변경하는 일이 감당 불가라서 누구라도 단념하게 만드는 방법으로 트랜잭션 이력을 불변성 데이터로 만든다.</p>
</blockquote>
<h3 id="트랜잭션-이력을-불변성-데이터로-만드는-데-필요한-세-가지"><a href="#트랜잭션-이력을-불변성-데이터로-만드는-데-필요한-세-가지" class="headerlink" title="트랜잭션 이력을 불변성 데이터로 만드는 데 필요한 세 가지"></a>트랜잭션 이력을 불변성 데이터로 만드는 데 필요한 세 가지</h3><ul>
<li>트랜잭션 이력을 저장할 때 아무리 사소한 조작이라도 바로 드러날 수 있게 한다.<ul>
<li>아무리 사소한 변경이라도 데이터를 가리키는 해시 참조를 무효화 시켜서 몰래 조작이 불가하다.</li>
</ul>
</li>
<li>변경된 데이터를 끼워넣으려면 엄청난 양을 다시 작성하도록 강제한다.<ul>
<li>변경하려면 변경된 부분부터 헤드까지 전체 체인을 완전히 변경하거나 내버려둬야 한다.</li>
</ul>
</li>
<li>트랜잭션 이력에 데이터를 추가, 변경, 재작성하는 작업에 엄청난 계산량이 필요하도록 한다.<ul>
<li>블록체인-기술-모음은 블록체인-데이터-구조의 모든 블록에 대해 작성, 재작성, 추가 작업에 엄청난 계산 비용이 필요하게끔 만든다.</li>
</ul>
</li>
</ul>
<h3 id="작동원리-세부-사항-살펴보기"><a href="#작동원리-세부-사항-살펴보기" class="headerlink" title="작동원리: 세부 사항 살펴보기"></a>작동원리: 세부 사항 살펴보기</h3><p>블록체인-데이터-구조의 새 블록 추가에는 많은 계산량이 들지 않지만 이것을 불변성으로 만들려면 새 목록을 추가하는 것이 많은 계산량을 필요로 하게끔 해야한다. 이를 위해서 아래와 같은 사항을 고려한다.</p>
<ul>
<li>필수 데이터</li>
<li>새 블록 헤더를 생성하는 프로세스</li>
<li>블록 헤더를 검증하는 규칙</li>
</ul>
<h4 id="필수-데이터"><a href="#필수-데이터" class="headerlink" title="필수 데이터"></a>필수 데이터</h4><p>블록체인-데이터-구조의 모든 블록 헤더는 최소한 다음의 데이터를 가진다.</p>
<ul>
<li>트랜잭션 데이터를 담고 있는 머클 트리의 루트</li>
<li>이전 블록 헤더를 가리키는 해시 참조</li>
<li>해시 퍼즐의 난이도</li>
<li>해시 퍼즐 풀이를 시작한 시각</li>
<li>해시 퍼즐을 해결할 수 있는 난스</li>
</ul>
<h4 id="새-블록을-생성하는-프로세스"><a href="#새-블록을-생성하는-프로세스" class="headerlink" title="새 블록을 생성하는 프로세스"></a>새 블록을 생성하는 프로세스</h4><ol>
<li>새로 추가되는 트랜잭션을 담고 있는 머클 트리의 루트 얻기</li>
<li>새 블록 헤더의 입장에서 이전 블록 헤더를 가리키는 해시 참조 생성하기</li>
<li>필요 난이도 획득하기</li>
<li>현재 시각 읽기</li>
<li>1~4번에 언급된 데이터를 포함하는 예비 블록 헤더 생성하기</li>
<li>예비 블록 헤더에 해당하는 해시 퍼즐 해결하기</li>
<li>해시 퍼즐을 해결할 난스를 예비 헤더에 포함시켜 새 블록 완결하기</li>
</ol>
<h4 id="검증-규칙"><a href="#검증-규칙" class="headerlink" title="검증 규칙"></a>검증 규칙</h4><p>다음의 규칙을 준수한다.</p>
<ol>
<li>직전 블록을 가리키는 유효한 해시 참조가 있다.</li>
<li>트랜잭션 데이터를 갖고 있는 머클 트리의 루트를 포함한다.</li>
<li>정확한 난이도를 가지고 있어야 한다.</li>
<li>타임 스탬프는 직전 블록 헤더의 타임 스탬프 이후여야 한다. (블록과 트랙잭션 데이터들이 추가 된 순서에 따라 정렬되어 있음을 보장)</li>
<li>난스를 포함해야 한다.</li>
<li>위 5개의 데이터 조각을 함친 해시값으로 난이도를 충족해야 한다.</li>
</ol>
<p>검증 규칙은 해시 퍼즐을 해결하고, 필요한 계산 비용을 지불한 블록만 추가되도록 보장한다. 이처럼 해시 퍼즐을 해결하여 블록체인-데이터-구조에 새 블록을 추가하는 행위를 마이닝 혹은 블록 마이닝이라 부른다.</p>
<h3 id="작동하는-이유"><a href="#작동하는-이유" class="headerlink" title="작동하는 이유"></a>작동하는 이유</h3><p><strong>해시 참조가 가리키는 데이터에 변경이 있으면 그 즉시 해시 참조 자체를 손상시키는 성질</strong>에서 비롯되어, 데이터 조작이 있을 경우 영향받은 모든 블록을 다시 작성하게 한다. <em>결국 블록체인-데이터-구조의 불변성은 해시 퍼즐의 난이도에 달려 있다.</em> 난이도가 너무 낮으면 계산비용도 낮아져 조작의 가능성이 높아지고, 난이도가 너무 높으면 새 데이터를 추가하는 계산 비용도 높아져 새 데이터 추가에 대한 의욕이 상실될 수 있다. 따라서 블록체인 디자인 시 해시 퍼즐의 적절한 난이도를 결정하는 것이 매우 중요하다. 실제로는 새 블록이 추가되는 속도에 기초한 동적 난이도를 활용하는데, 새 블록의 추가 속도가 빨라지면 난이도를 높이고, 그 반대면 난이도를 낮추는 방식으로 적정 수준의 난이도를 유지한다.</p>
<hr>
<h2 id="17-컴퓨터들이-정보를-배분하는-방법"><a href="#17-컴퓨터들이-정보를-배분하는-방법" class="headerlink" title="17. 컴퓨터들이 정보를 배분하는 방법"></a>17. 컴퓨터들이 정보를 배분하는 방법</h2><h3 id="목표-1"><a href="#목표-1" class="headerlink" title="목표"></a>목표</h3><p>P2P 시스템을 구성하는 개별 컴퓨터들이 트랜잭션이 발생할 때마다 적절히 통보받아 자신의 트랜잭션 데이터 이력을 관리할 수 있도록 보장한다.</p>
<h3 id="해결해야-할-과제-1"><a href="#해결해야-할-과제-1" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><p>순수 분산 P2P 시스템에는 중앙 통제와 조정 장치가 없기 때문에 시스템의 모든 노드가 이러한 장치에 의지하지 않고 모든 트랜잭션 정보를 수신하도록 해주는 것이다.</p>
<h3 id="아이디어-1"><a href="#아이디어-1" class="headerlink" title="아이디어"></a>아이디어</h3><p>P2P 시스템을 구성하는 컴퓨터들이 정보를 공유하고 교환하도록 하는 것인데, 노드 하나가 피어 노드에게 정보를 전달받으면 다른 피어에게 그 정보를 전달하고, 그 피어가 또 다른 피어에게 전달하는 방식으로 시스템 내 모든 노드가 정보를 전달받도록 한다.</p>
<h2 id="작동원리-1"><a href="#작동원리-1" class="headerlink" title="작동원리"></a>작동원리</h2><p>분산 P2P 시스템의 컴퓨터는 디지털 네트워크를 통해 통신하기 때문에 노드들이 인터넷을 통해 서로 통신하도록 하는 방식으로 P2P 시스템을 구성할 수 있다. <em>단 노드가 네트워크를 통해 통신하고 언제든 단절과 재접속을 할 수 있다는 점이 메시지 전달에 영향을 미친다.</em> 네트워크에서 이루어지는 메시지 전달에는 아래와 같은 특성이 있다.</p>
<ul>
<li>손실될 가능성이 있다.</li>
<li>한 번 이상 도달할 수 있다.</li>
<li>전송한 순서와 다른 순서로 도착할 수 있다.</li>
</ul>
<p>이 특성때문에 통신에 장애가 발생할 수 있지만 아래의 방법으로 해결할 수 있다.</p>
<ul>
<li>새로운 정보를 받은 모든 노드는 자신이 통신하는 피어에게 전달하기 때문에 몇몇 메시지가 손실될 수 있어도 궁극적으로 모든 노드가 메시지를 수신하는 것을 보장한다.</li>
<li>메시지는 디지털 지문 또는 암호화 해시값으로 식별 가능하므로 노드가 중복된 메시지를 식별해서 무시할 수 있다.</li>
<li>트랜잭션 데이터와 블록 헤더에 타임 스탬프가 포함되어 있어서 노드들이 객관적인 시각 기준에 따라 메시지를 정렬할 수 있다.</li>
</ul>
<p><strong>P2P 시스템을 구성하는 노드 간 통신은 다음 세 가지 목적을 가진다.</strong></p>
<blockquote>
<ul>
<li>기존 연결 유지</li>
<li>새로운 연결</li>
<li>새로운 정보 배포</li>
</ul>
</blockquote>
<p>기존 연결 유지, 새로운 연결은 P2P 시스템 자체에 초점을 맞추고 있어서 피어 간 네트워크를 유지하고 약간의 디지털 관리 업무를 수행한다. 새로운 정보 배포는 블록체인-데이터-구조에 새로운 트랜잭션 데이터나 블록을 추가하는 것에 초점을 맞춘다.</p>
<ul>
<li>기존 연결 유지</li>
</ul>
<p>네트워크의 각 컴퓨터는 통신하는 피어 리스트를 독립적으로 유지하고, 피어 리스트는 시스템을 구성하는 전체 노드의 부분집합이다. 주기적으로 각 컴퓨터는 피어가 연결상태인지 확인하기 위해 핑(ping)하고 메시지를 보내고, 퐁(pong)으로 대답하도록 요청한다. 만약 이 메시지에 반복적으로 대답하지 않는 피어가 있다면 리스트에서 제거한다.</p>
<ul>
<li>새로운 연결</li>
</ul>
<p>P2P 시스템 내에 참여하고 싶은 컴퓨터는 시스템 내의 아무 노드에게나 시스템에 참여하고 싶다고 요청한다. 이렇게 요청을 받은 노드는 요청자인 피어의 주소를 피어 리스트에 추가하고 확인 응답을 보내고, 확인 응답을 받은 노드는 응답을 보낸 주소를 자신의 피어 리스트에 추가한다. 이렇게 되면 새로운 연결이 형성되어 시스템에 노드 하나가 더 증가한 것이다. 그리고 P2P 시스템에 참여할 때는 시스템의 일부인 다수의 노드와 연결을 형성한다. 특정 노드 하나의 연결이 끊어지더라도 시스템에 연결된 상태를 유지하기 위함이다.</p>
<ul>
<li>새로운 정보 배포</li>
</ul>
<p>새로 추가될 트랜잭션 데이터와 새 블록 정보를 통신을 통해 전달하는데, <em>소유권 관련 정보를 공유하는 일은 다음 3가지 경우에 발생한다.</em></p>
<ul>
<li>지속적인 방식<ul>
<li>새로운 정보는 발생과 동시에 배포되고, 시스템에 연결된 모든 노드가 정보를 받는다.</li>
</ul>
</li>
<li>갱신 방식<ul>
<li>연결이 끊겼다가 다시 시스템에 연결되었을 때, 그 사이 놓친 트랜잭션 데이터와 블록에 대한 정보를 모두 받는다.</li>
</ul>
</li>
<li>온보딩 절차의 일부로 갱신<ul>
<li>시스템에 새로 참여한 노드는 트랜잭션 이력을 구축할 기회가 없었기 때문에 시스템 참여 직전까지 발생한 모든 트랜잭션 이력을 얻어와야 한다. 따라서 새로운 참여자가 참여하자 마자 모든 정보를 갖추어 노드가 될 수 있도록 보장한다.</li>
</ul>
</li>
</ul>
<h2 id="작동하는-이유-1"><a href="#작동하는-이유-1" class="headerlink" title="작동하는 이유"></a>작동하는 이유</h2><p>앞서 살펴본 3가지 통신 방식이 새로운 컴퓨터가 시스템에 참여할 수 있도록 보장해주기 때문에 시스템이 확장되게 하면서 기존 연결 유지의 업무도 수행하게 한다. <strong>가장 중요한 점은 블록체인-데이터-구조 내 새로 추가되는 트랜잭션 데이터와 블록에 대한 모든 정보를 P2P 시스템의 전체 구성원이 궁극적으로 받아볼 수 있도록 보장한다는 것이다.</strong></p>
<hr>
<h2 id="18-블록체인-속-무한경쟁-사회"><a href="#18-블록체인-속-무한경쟁-사회" class="headerlink" title="18. 블록체인 속 무한경쟁 사회"></a>18. 블록체인 속 무한경쟁 사회</h2><h3 id="목표-2"><a href="#목표-2" class="headerlink" title="목표"></a>목표</h3><p>시스템의 무결성을 유지하면서 누구든지 트랜잭션 데이터 이력에 새로운 트랜잭션을 추가할 수 있도록 허용한다.</p>
<h3 id="해결해야-할-과제-2"><a href="#해결해야-할-과제-2" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><p>완전히 개방된 시스템에서 누구든 시스템에 참여하여 데이터를 전송할 수 있는데, 이 데이터들이 정확하다는 보장은 없다. <strong>따라서 시스템을 모두에게 개방하면서도 오직 유효한 트랜잭션만 추가될 수 있도록 보장하는 것이 필요하다.</strong></p>
<h3 id="아이디어-2"><a href="#아이디어-2" class="headerlink" title="아이디어"></a>아이디어</h3><p>시스템의 모든 노드가 다른 피어 노드를 감시하도록 하면서 동시에 유효하고 승인된 트랜잭션을 추가하거나 타인의 작업에 오류를 발생했을 때 적절한 보상을 해주어 동기를 부여한다.</p>
<h3 id="작동원리-구성요소들"><a href="#작동원리-구성요소들" class="headerlink" title="작동원리: 구성요소들"></a>작동원리: 구성요소들</h3><p>블록체인-알고리즘은 노드가 새 트랜잭션 데이터와 블록을 어떻게 처리할지 통제하는 일련의 명령어이다. 개별적 규칙과 절차는 다음과 같다.</p>
<blockquote>
<ol>
<li>검증 규칙</li>
<li>보상</li>
<li>처벌</li>
<li>경쟁</li>
<li>피어 통제</li>
</ol>
</blockquote>
<h4 id="1-검증-규칙"><a href="#1-검증-규칙" class="headerlink" title="1. 검증 규칙"></a>1. 검증 규칙</h4><p>블록체인-데이터-구조가 유효한 트랜잭션 데이터와 블록 헤더만으로 구성된 블록만을 가지도록 한다. 데이터 유효성의 검증에는 다음의 두 가지가 필요하다.</p>
<blockquote>
<ul>
<li>트랜잭션 데이터 검증 규칙</li>
<li>블록 헤더 검증 규칙</li>
</ul>
</blockquote>
<ul>
<li>트랜잭션 데이터 검증 규칙</li>
</ul>
<p>형식의 정확성, 의미상 정확성, 승인의 3요소이다. 이 규칙은 블록체인의 응용분야(블록체인이 어떤 산업분야에서 사용되는가)에 따라 서로 다른 검증 규칙을 가지게 된다.</p>
<ul>
<li>블록 헤더 검증 규칙</li>
</ul>
<p><em>형식과 의미의 정확성에 초점이 있고,</em> 트랜잭션 데이터의 내용과 무관한 블록체인-데이터-구조에 정보가 추가되는 방식과 관련 있다. 개별적 해시 퍼즐을 해결한 헤더를 가진 블록만 그 다음 단계로 넘어가고, 그렇지 못한 블록은 즉시 폐기된다.</p>
<h4 id="2-보상"><a href="#2-보상" class="headerlink" title="2. 보상"></a>2. 보상</h4><p>유효한 블록 생성을 위해 블록의 고유 해시 퍼즐을 풀어야만 한다. 이때 피어가 해시 퍼즐을 푸는 부담(에너지, 시간, 돈 등)을 짊어지도록 하는 방법은 비용에 상응하는 보상을 제공하는 것이다. 블록체인-알고리즘이 유효한 블록을 제출한 노드가 보상을 받는 방식을 정의한다.</p>
<h4 id="3-처벌"><a href="#3-처벌" class="headerlink" title="3. 처벌"></a>3. 처벌</h4><ul>
<li>생성 당시엔 인정되었지만 나중에 유효하지 않거나 무용한 것으로 판명된 블록에 대해 <em>이미 지급된 보상을 회수한다.</em></li>
<li>노드가 작업 증명을 했지만 블록이 중복되거나 너무 오래된 경우, 쓸모없는 경우에 <em>보상을 하지 않는다.</em></li>
</ul>
<h4 id="4-경쟁"><a href="#4-경쟁" class="headerlink" title="4. 경쟁"></a>4. 경쟁</h4><p>시스템을 유지하는데 드는 비용을 줄이면서 높은 작업 품질을 성취하는 최선의 방법으로 서로 경쟁하도록 만든다. 블록체인-알고리즘은 아래 두 가지 기준의 조합으로 지속적인 경쟁을 유발하며 적절히 보상한다.</p>
<ul>
<li>속도 경쟁</li>
</ul>
<p><strong>해시 퍼즐에 기초한다.</strong> 유효한 블록 생성의 핵심은 작업 증명을 생성하는 것이므로, 작업 증명은 곧 새 블록의 고유 해시 퍼즐을 해결했다는 의미이다. 모든 노드는 해시 퍼즐을 푸는 경쟁에 참여하게 되는데, 이 경쟁은 어떤 노드가 새 블록을 제출함과 동시에 끝난다. 새 블록을 제출한 노드는 품질 경쟁의 유일한 후보자가 된다.</p>
<ul>
<li>품질 경쟁</li>
</ul>
<p><strong>제출된 블록의 정확성에 초점을 맞춘다.</strong> 새 블록은 수신한 모든 모드는 트랜잭션 데이터와 블록 헤더의 검증 규칙에 기초하여 새 블록을 검증한다. <code>피어 통제</code>를 통해 매우 높은 정확성을 유지하도록 한다. 새 블록을 수령한 노드는 자신이 속도 경쟁에서 패했다는 사실을 깨달았으므로 꼼꼼한 심판관이 되고, 제출된 블록이 무효라면 또다시 속도 경쟁을 거쳐야 하므로 자신이 새 블록을 제출하여 승자가 될 수 있음을 알고 있다.</p>
<h4 id="5-피어-통제"><a href="#5-피어-통제" class="headerlink" title="5. 피어 통제"></a>5. 피어 통제</h4><p>시스템의 모든 노드는 다른 노드의 감시자인데, 새 블록을 생성하고 트랜잭션을 검사하면서도 다른 노드가 생성한 블록을 수신해서 검토하고 검증하는 역할을 한다. 즉 새 블록의 생성과 유효하지 않은 트랜잭션 데이터와 블록의 감지, 거절, 제거에 기여한다.</p>
<h3 id="작동원리-골격"><a href="#작동원리-골격" class="headerlink" title="작동원리: 골격"></a>작동원리: 골격</h3><p>시스템의 모든 노드는 다음 두 상태 중 하나에 속해 있다.</p>
<ol>
<li>피어에 의해 생성되고 제출된 새 블록을 평가 중</li>
<li>스스로 새 블록을 만들어 다른 피어에게 평가받으려 열심히 노력 중</li>
</ol>
<p>블록체인-알고리즘의 중요 역할은 모든 노드가 동일한 작업 상태를 가지도록 보장하는 것이고, 동일한 작업 상태는 모든 블록이 동일한 트랜잭션 데이터 이력을 유지하게 하는 핵심 개념이다. 상태를 결정하는 것은 개별 노드에게 도착하는 메시지인데, 각 노드가 새 블록을 담고 있는 메시지를 받자마자 평가 상태로 스위치되고, 평가 상태가 완료되자마자 새 트랜잭션을 검증하고 자체적으로 새 블록을 생성하기 위한 상태로 스위치된다.</p>
<h2 id="부정직한-노드는-어떻게-처리할까"><a href="#부정직한-노드는-어떻게-처리할까" class="headerlink" title="부정직한 노드는 어떻게 처리할까?"></a>부정직한 노드는 어떻게 처리할까?</h2><p>P2P 시스템에서 가장 두드러진 부정직한 행위는 다음과 같다.</p>
<ul>
<li>다른 사람으로 위장해 트랜잭션 제출</li>
<li>유효하지 않은 트랜잭션 데이터나 블록을 인정</li>
<li>노드를 다운시키기 위해 수많은 트랜잭션 데이터를 전송</li>
<li>특정 트랜잭션 데이터 처리를 거부</li>
<li>정보 전달을 거부</li>
</ul>
<p>이러한 부정직한 경우는 아래와 같이 처라힌다.</p>
<ul>
<li>해당 개인 키 소유자에게만 계정의 접근을 허용하는 트랜잭션의 보안 개념(비대칭 암호화 기법, 디지털 서명을 통한 식별, 인증, 승인)</li>
<li>모든 노드가 결국 모든 정보를 수신하는 것을 보장.</li>
<li>특정 노드가 잘못되거나 데이터 처리를 멈추어도 전체 시스템이 계속 작동하도록 보장하는 시스템 아키텍처</li>
<li>블록체인-알고리즘</li>
</ul>
<p><strong>블록체인이 부정직한 노드를 처리하는 가장 큰 무기는 정직한 다수의 힘과 보상 및 처벌의 효과이다.</strong></p>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/07/220308_blockchain03_12to15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/220308_blockchain03_12to15/" class="post-title-link" itemprop="url">블록체인 무엇인가? 3장 블록체인은 어떻게 작동하는가? 12 ~ 15단계</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-08 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-08T00:00:00+09:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-06 23:40:24" itemprop="dateModified" datetime="2022-12-06T23:40:24+09:00">2022-12-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="12-암호화-기법을-소개합니다"><a href="#12-암호화-기법을-소개합니다" class="headerlink" title="12. 암호화 기법을 소개합니다"></a>12. 암호화 기법을 소개합니다</h2><blockquote>
<p>블록체인에서 비대칭 암호화 기법은 사용자를 식별하고 자산을 보호하는 근간을 이룬다.</p>
</blockquote>
<h3 id="목표"><a href="#목표" class="headerlink" title="목표"></a>목표</h3><p>고유한 소유자와 자산을 식별하고, <em>법적으로 허가된 사람만 그 자산에 접근할 수 있도록 보장한다.</em></p>
<h3 id="해결해야-할-과제"><a href="#해결해야-할-과제" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><p>블록체인은 완전 개방된 P2P 시스템이고, 누구나 접속해서 계산 자원에 기여하고 새로운 트랜잭션을 시스템에 제출할 수 있다. <strong>단, 소유권을 다른 계정으로 이전할 권리는 오직 그 계정의 소유자에게 국한된다.</strong> 분산 시스템의 개방형 아키텍처를 해치지 않으면서 계정에 할당된 자산을 보호하는 것이 중요한 과제이다.</p>
<h3 id="아이디어"><a href="#아이디어" class="headerlink" title="아이디어"></a>아이디어</h3><p>누구나 자산을 보낼 수 있지만 모인 자산에는 계정의 소유자만 접근할 수 있다. 이를 <code>공개-개인-키 암호화</code>라고 하는데 <strong>소유권을 이전할 수 있는 계정을 식별할 때는 누구나 공개 키를 사용하고, 접근은 해당 개인 키를 가진 사람에게만 허용된다.</strong> 어디에나 있고 개방되어 있지만 열쇠가 있는 사람만이 열 수 있는 우편함의 성질과 같다.</p>
<h3 id="암호화-기법의-주요-아이디어"><a href="#암호화-기법의-주요-아이디어" class="headerlink" title="암호화 기법의 주요 아이디어"></a>암호화 기법의 주요 아이디어</h3><blockquote>
<p>허가받지 않은 사용자의 접근으로부터 데이터를 보호하고, 이를 위해 사용하는 것을 <code>키(key)</code>라 한다.</p>
</blockquote>
<ul>
<li><code>암호화</code>: 문을 잠그는 것의 디지털 구현</li>
<li><code>복호화</code>: 문을 여는 것의 디지털 구현</li>
<li><code>데이터 보호화 데이터 보호 해제</code>: 암호화와 복호화</li>
<li><code>암호문</code>: 암호화된 데이터</li>
<li><code>과정</code>: <code>암호화 키를 사용해 암호문 생성</code> -&gt; <code>암호문의 보관 또는 전송</code> -&gt; <code>암호화 키를 사용해 복호화</code> -&gt; <code>원시 데이터 복원</code></li>
</ul>
<h3 id="대칭-암호화-기법"><a href="#대칭-암호화-기법" class="headerlink" title="대칭 암호화 기법"></a>대칭 암호화 기법</h3><blockquote>
<p>데이터를 암호화하고 복호화할 때 <code>동일한 키</code>를 사용.</p>
</blockquote>
<p>동일한 키를 사용했기 때문에 암호화한 키가 있으면 동시에 복호화할 수 있는 키도 가지는 셈이다. 따라서 바람직하지 못하고 그래서 비대칭 암호화 기법이 발명되었다.</p>
<h3 id="비대칭-암호화-기법"><a href="#비대칭-암호화-기법" class="headerlink" title="비대칭 암호화 기법"></a>비대칭 암호화 기법</h3><blockquote>
<p><code>두 개의 상호보완적 키</code>를 사용.</p>
</blockquote>
<ul>
<li>두 키중 하나를 사용해 생성된 암호문은 오직 다른 하나의 키로만 복호화되고, 그 반대도 마찬가지이다.</li>
<li>암호문을 생성할 때 사용한 키로는 절대 암호를 복호화할 수 없다.</li>
<li>암호화 복호화를 할 때 <strong>항상 두 개의 키를 모두</strong> 가지고 있어야 한다. 둘 중 하나만 있으면 하는 일이 제한적이다.</li>
<li><em>암호문의 생성은 하나의 키만 있어도 언제든 가능하지만 상호보완적 쌍을 이루는 다른 키가 없다면 생성된 암호문을 복호화할 방법은 없다.</em></li>
<li>두 개의 키가 암호문을 생성할 수 있는 사람, 복호화할 수 있는 사람의 두 그룹으로 분리할 수 있게 해준다.</li>
<li>암호화 복호화의 역할은 서로 바뀔 수 있지만 <strong>개인 키와 공개 키의 역할은 절대 바뀔 수 없다. 공개 키는 비가역적 함수를 통해 개인 키로부터 생성된 것이다.</strong></li>
</ul>
<h3 id="실생활에서-비대칭-암호화-기법을-사용하는-방법"><a href="#실생활에서-비대칭-암호화-기법을-사용하는-방법" class="headerlink" title="실생활에서 비대칭 암호화 기법을 사용하는 방법"></a>실생활에서 비대칭 암호화 기법을 사용하는 방법</h3><h4 id="1-키의-생성과-배분"><a href="#1-키의-생성과-배분" class="headerlink" title="1. 키의 생성과 배분"></a>1. 키의 생성과 배분</h4><p>보통 두 개의 키 각각의 역할을 나타내는 특별한 이름을 붙인다. 그래서 비대칭 암호화 기법을 <code>공개-개인-키(공개-비밀-키)</code>라고 부른다. 공개 키는 신뢰 여부와 상관없이 누구에게나 주어지기 때문에 누구나 공개 키의 복사본을 가질 수 있고, <em>개인 키는 안전하게 사적으로 보관해야 한다.</em> 아래는 비대칭 암호화 기법 응용프로그램의 수행 단계이다.</p>
<ul>
<li>암호화 소프트웨어를 사용해서 개인 키를 생성한다.</li>
<li>상호보완적인 공개 키를 생성한다.</li>
<li>개인 키는 간직한다.</li>
<li>공개 키는 모두에게 배부한다.</li>
</ul>
<h4 id="2-키의-사용"><a href="#2-키의-사용" class="headerlink" title="2. 키의 사용"></a>2. 키의 사용</h4><h5 id="1-공개-gt-개인"><a href="#1-공개-gt-개인" class="headerlink" title="1. 공개 -&gt; 개인"></a>1. 공개 -&gt; 개인</h5><ul>
<li><code>공개 키</code>: 정보를 <code>암호화</code></li>
<li><code>개인 키</code>: 정보를 <code>복호화</code></li>
</ul>
<p>누구나 암호문을 생성할 수 있지만 개인 키를 가진 소유자만이 암호문을 복호화하고 메시지를 읽을 수 있다.</p>
<h5 id="2-개인-gt-공개"><a href="#2-개인-gt-공개" class="headerlink" title="2. 개인 -&gt; 공개"></a>2. 개인 -&gt; 공개</h5><ul>
<li><code>공개 키</code>: 정보를 <code>복호화</code></li>
<li><code>개인 키</code>: 정보를 <code>암호화</code></li>
</ul>
<p>공개 키의 복사본을 가진 사람은 누구나 메시지를 읽을 수 있지만 모두에게 공개할 메시지는 오직 개인 키를 가진 소유자만이 생성가능하다. 저작권 증명에 주로 사용하면 좋다.</p>
<h4 id="블록체인에서-비대칭-암호화-기법은-언제-쓸까"><a href="#블록체인에서-비대칭-암호화-기법은-언제-쓸까" class="headerlink" title="블록체인에서 비대칭 암호화 기법은 언제 쓸까?"></a>블록체인에서 비대칭 암호화 기법은 언제 쓸까?</h4><blockquote>
<ol>
<li>계정 식별</li>
<li>트랜잭션 승인</li>
</ol>
</blockquote>
<h5 id="1-계정-식별"><a href="#1-계정-식별" class="headerlink" title="1. 계정 식별"></a>1. 계정 식별</h5><ul>
<li>소유자와 자산의 매핑 유지를 위해 사용자와 사용자 계정을 모두 식별해야 한다.</li>
<li><code>공개 -&gt; 개인 접근 방식</code>을 사용해서 사용자 계정을 식별하고, 사용자가 소유권을 이전한다.</li>
<li>블록체인의 계정 번호는 공개 암호 키라서 공개된 주소를 통해 누구나 메시지를 전송할 수 있다.</li>
</ul>
<h5 id="2-트랜잭션-승인"><a href="#2-트랜잭션-승인" class="headerlink" title="2. 트랜잭션 승인"></a>2. 트랜잭션 승인</h5><ul>
<li>소유권 양도에 관한 내용에 그 소유권자가 동의했는지를 증명하는 데이터를 항상 포함한다.</li>
<li><code>개인 -&gt; 공개 접근 방식</code>과 유사하여, 소유자는 개인 키를 사용해 암호문을 생성하고, 다른 모든 사람은 공개 암호 키를 사용해 거래를 증명할 수 있다.</li>
<li>공개 암호 키는 소유권을 이전하려는 계정 번호와 같다.</li>
</ul>
<hr>
<h2 id="13-노드-여러분-트랜잭션을-승인합니까"><a href="#13-노드-여러분-트랜잭션을-승인합니까" class="headerlink" title="13. 노드 여러분, 트랜잭션을 승인합니까?"></a>13. 노드 여러분, 트랜잭션을 승인합니까?</h2><blockquote>
<p>디지털 서명 만들어 검증에 사용하기. 자필 서명과 유사하게 전자 원장에 트랜잭션에 동의한다고 표시한다. <code>개별 트랜잭션의 보안</code>을 위해 절대적으로 중요하다.</p>
</blockquote>
<h3 id="목표-1"><a href="#목표-1" class="headerlink" title="목표"></a>목표</h3><p><em>계정의 소유자 또는 합법적 소유자만</em> 계정 내 자산을 다른 계정으로 이전할 수 있도록 보장한다.</p>
<h3 id="해결해야-할-과제-1"><a href="#해결해야-할-과제-1" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><blockquote>
<p>합법적 소유자로만 이전 권한 제한 + 개방성 유지</p>
</blockquote>
<p>P2P 시스템은 누구에게나 개방되어 있어 모든 사람이 트랜잭션을 생성하고 시스템에 제출할 수 있지만 이전은 계정의 합법적 소유자만이 가능하다.</p>
<h3 id="아이디어-1"><a href="#아이디어-1" class="headerlink" title="아이디어"></a>아이디어</h3><p>자필 서명의 기능을 디지털 버전으로 만들어 계정을 식별, 인증, 허가를 가능하게 한다.</p>
<h3 id="디지털-서명의-주요-기능-알아보기"><a href="#디지털-서명의-주요-기능-알아보기" class="headerlink" title="디지털 서명의 주요 기능 알아보기"></a>디지털 서명의 주요 기능 알아보기</h3><p>개인 -&gt; 공개 방식의 정보 흐름을 활용한다.</p>
<h4 id="디지털-서명의-3대-주요-요소"><a href="#디지털-서명의-3대-주요-요소" class="headerlink" title="디지털 서명의 3대 주요 요소"></a>디지털 서명의 3대 주요 요소</h4><ol>
<li>서명의 생성</li>
</ol>
<ul>
<li>특정 데이터에 대한 프로세스가 시작되면 입력된 데이터에 해당하는 해시값을 생성하고, 개인 키를 사용해서 암호화한다. <strong>해시값의 암호문이 바로 디지털 서명이다.</strong></li>
<li>고유한 개인 키를 사용해 생성되었기 때문에 누가 생성했는지 특정할 수 있다.</li>
<li>특정 데이터의 디지털 지문(해시값)에 의해 생성되었기 때문에 고유한 데이터이다.</li>
</ul>
<ol>
<li>서명을 이용한 데이터 검증</li>
</ol>
<ul>
<li>모든 사람이 나의 공개 키를 활용하여 암호문으로부터 복호화된 값을 얻을 수 있다.</li>
<li>메시지 수신자는 받은 데이터의 해시값을 스스로 계산해본다.</li>
<li>수신자가 계산한 해시값과 복호화된 값이 일치하면 수신자는 아래의 두 가지 사실을 알 수 있다.</li>
<li>나의 공개 키를 사용해 서명을 복호화할 수 있었기 때문에 내가 서명한 것이다.</li>
<li>복호화된 암호문이 최초에 보내려고 했던 데이터의 해시값과 일치한다.</li>
</ul>
<ol>
<li>서명을 이용한 사기 판별</li>
</ol>
<ul>
<li>메시지 수신자가 받은 데이터의 해시값을 스스로 생성한다.</li>
<li>공개 키를 이용해 디지털 서명을 복호화하여 복호화된 원래 데이터 해시값을 얻는다.</li>
<li><em>수신자가 계산한 해시값과 복호화하여 얻은 해시값이 다르면 이는 문제가 있다.</em></li>
</ul>
<h3 id="작동원리"><a href="#작동원리" class="headerlink" title="작동원리"></a>작동원리</h3><ul>
<li>트랜잭션 데이터는 계정의 소유자가 소유권을 이전하는 데 동의했다는 사실을 알려준다</li>
<li>트랜잭션의 전체 내용은 고유하므로 서명한 사람의 동의 없이 다른 트랜잭션의 서명으로 사용할 수 없다. <em>트랜잭션 내용이 바뀌면 소유자가 새로 서명을 생성해야 한다.</em></li>
<li><strong>소유권을 이전하려는 계정의 소유자만이 서명을 생성할 수 있다.</strong></li>
<li>누구나 쉽게 검증할 수 있다.</li>
</ul>
<h4 id="블록체인에서-디지털-서명의-용도"><a href="#블록체인에서-디지털-서명의-용도" class="headerlink" title="블록체인에서 디지털 서명의 용도"></a>블록체인에서 디지털 서명의 용도</h4><ul>
<li><p>트랜잭션 서명</p>
<ul>
<li>트랜잭션에 필요한 모든 정보를 기술</li>
<li>트랜잭션 데이터의 암호화 해시값 생성</li>
<li>소유권을 이전하려는 계정의 <code>개인 키</code>를 사용해 트랜잭션의 해시값 암호화</li>
<li>암호문을 트랜잭션에 디지털 서명으로 첨부</li>
</ul>
</li>
<li><p>트랜잭션 검증</p>
<ul>
<li>서명을 제외하고 검증한 트랜잭션 데이터의 해시값 생성</li>
<li>검증하려는 트랜잭션의 디지털 서명 복호화</li>
<li><code>검증된 트랜잭션 데이터의 해시값</code>과 <code>검증하려는 트랜잭션의 디지털 서명을 복호화한 두 값</code>을 비교한다. 값이 동일하면 소유권을 이전하려는 계정에 해당하는 개인 키 소유자가 승인한 트랜잭션이고, 다르면 그렇지 않다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="14-블록체인-데이터-구조를-만들어봅시다"><a href="#14-블록체인-데이터-구조를-만들어봅시다" class="headerlink" title="14. 블록체인-데이터-구조를 만들어봅시다"></a>14. 블록체인-데이터-구조를 만들어봅시다</h2><blockquote>
<p>전체 트랜잭션 데이터 구축 및 유지하기</p>
</blockquote>
<h3 id="목표-2"><a href="#목표-2" class="headerlink" title="목표"></a>목표</h3><p>전체 트랜잭션 이력을 정렬 상태로 유지한다.</p>
<h3 id="해결해야-할-과제-2"><a href="#해결해야-할-과제-2" class="headerlink" title="해결해야 할 과제"></a>해결해야 할 과제</h3><p>모든 트랜잭션 데이터를 <em>발생 순서를 유지하면서</em> 어떠한 변경이 있을 경우 재빨리 감지할 수 있도록 저장한다.</p>
<h3 id="아이디어-2"><a href="#아이디어-2" class="headerlink" title="아이디어"></a>아이디어</h3><ul>
<li>트랜잭션이 추가된 순서대로 정렬괸다.</li>
<li>데이터는 해시 참조를 사용해 변경-감지 방식으로 저장된다.</li>
</ul>
<h3 id="책을-블록체인-데이터-구조로-변환하기"><a href="#책을-블록체인-데이터-구조로-변환하기" class="headerlink" title="책을 블록체인-데이터-구조로 변환하기"></a>책을 블록체인-데이터-구조로 변환하기</h3><ol>
<li>페이지 의존성을 분명히 드러내기<br>책에서 페이지는 번호가 연속되는지 검증하여 어떤 페이지가 없는지 바로 알 수 있다. 특히 각 페이지에 현재 번호와 직적 페이지 번호를 같이 표시하게 되면 현재 페이지와 직전 페이지 사이의 종속관계를 형성하여 어떤 방식으로 페이지 번호를 매기던 사라지 페이지를 탐색할 수 있다.</li>
<li>내용과 페이지 번호 분리하기<br>책의 한 페이지는 내용과 페이지의 번호로 구성된다. 여기서 페이지에 있는 내용을 덜어낸 후 그 내용이 어디있는지에 대한 참조값만을 남긴다.</li>
<li>페이지 번호를 참조값으로 대체하기<br>내용 뿐 아니라 페이지 번호도 참조값으로 대체한다.</li>
<li>참조값 생성하기<br>암호화 해시값을 사용해서 고유한 참조값을 생성한다. 책의 페이지 참조값은 페이지의 내용(내용 참조값과 앞 페이지 참조값)에 기반해 계산한다.</li>
<li>책등 없애기<br>책등을 없애서 페이지 정렬이 엉망이 되었다고 해도 각 페이지가 앞 페이지의 참조값을 가지고 있기 때문에 이를 이용해서 <em>페이지에서 페이지로 역으로 추적해 순서를 알아낼 수 있다.</em></li>
</ol>
<h3 id="목표-달성-결과-평가"><a href="#목표-달성-결과-평가" class="headerlink" title="목표 달성: 결과 평가"></a>목표 달성: 결과 평가</h3><ul>
<li>정보 저장으로부터 순서를 분리하고, 페이지의 물리적 위치로부터 논리적 위치(순서)를 분리해 냈다.</li>
<li>참조값으로 해시값을 사용했기 때문에 누구나 간단한 계산을 통해 정확성을 검증할 수 있다.</li>
<li>페이지들은 더 이상 책등에 붙어있지 않으므로 <strong>오직 직전 페이지 참조값을 이용해 페이지에서 페이지로 거꾸로 탐색할 수 밖에 없다.</strong></li>
</ul>
<h3 id="변환된-책으로-블록체인-데이터-구조-이해하기"><a href="#변환된-책으로-블록체인-데이터-구조-이해하기" class="headerlink" title="변환된 책으로 블록체인-데이터-구조 이해하기"></a>변환된 책으로 블록체인-데이터-구조 이해하기</h3><div class="table-container">
<table>
<thead>
<tr>
<th>변환된 책</th>
<th>블록체인-데이터-구조</th>
</tr>
</thead>
<tbody>
<tr>
<td>순서일람표의 페이지</td>
<td>블록 헤더</td>
</tr>
<tr>
<td>전체 순서일람표</td>
<td>블록 헤더의 체인</td>
</tr>
<tr>
<td>순서일람표의 페이지 참조값</td>
<td>블록 헤더의 암호화 해시값</td>
</tr>
<tr>
<td>내용</td>
<td>트랜잭션 데이터</td>
</tr>
<tr>
<td>내용 페이지</td>
<td>트랜잭션 데이터를 가진 머클 트리</td>
</tr>
<tr>
<td>내용 페이지를 가리키는 참조값</td>
<td>트랜잭션 데이터를 가진 머클 트리의 루트</td>
</tr>
<tr>
<td>순서일람표 페이지와 해당 내용 페이지로 구성된 가상의 단위</td>
<td>블록체인-데이터-구조의 한 블록</td>
</tr>
<tr>
<td>전체 순서일람표와 전체 내용 페이지</td>
<td>블록체인-데이터-구조</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>순서일람표 페이지와 해당 내용 페이지로 구성된 가상 단위<br>전자는 해시 참조를 통해 후자를 참조함으로써 가상의 한 단위를 형성한다. <strong>이것을 블록이라 하고, 블록들이 모두 모여 블록체인-데이터-구조를 형성한다.</strong></li>
<li>순서일람표라 불리는 페이지 더미<br>블록체인-데이터-구조 내 단일 블록 헤더와 동일하다. 참조를 통해 선형으로 연결되어 블록 헤더의 체인을 형성한다. <strong>트랜잭션 데이터를 직접 저장하지 않고 해당 트랜잭션 데이터에 대한 해시 참조만 저장한다.</strong></li>
<li>내용을 담고 있는 페이지 더미<br>변환된 책의 내용은 <strong>블록체인에 의해 유지되는 트랜잭션 데이터</strong>와 같다. 다만 이는 이해를 돕기 위한 개념이며, 실제 블록체인 응용은 내용 데이터(트랜잭션 데이터)를 머클 트리라 불리는 데이터베이스에 직접 저장하고, 머클 트리의 루트는 블록 헤더에 저장된다.</li>
<li>순서일람표 페이지를 식별하고 연결할 페이지 참조값<br>페이지 참조값은 <strong>블록체인-데이터-구조 내 개별 블록 헤더의 암호화 해시값과 같다.</strong> 블록 해시 또는 이전 블록의 해시라 불리고, 각 블록 헤더를 고유하게 식별하고 이전 블록 헤더를 참조하기 위해 사용된다.</li>
<li>내용 페이지를 식별하고 연결할 내용 참조값<br>연계된 트랜잭션 데이터를 가리키는 블록 헤더의 해시 참조와 같다. 블록 헤더에 저장된 내용 참조값은 데이터베이스에 저장된 트랜잭션 데이터의 머클 트리 루트이다.</li>
</ol>
<h3 id="블록체인-데이터-구조에서-트랜잭션-저장하는-방법"><a href="#블록체인-데이터-구조에서-트랜잭션-저장하는-방법" class="headerlink" title="블록체인-데이터-구조에서 트랜잭션 저장하는 방법"></a>블록체인-데이터-구조에서 트랜잭션 저장하는 방법</h3><p>각 블록은 블록 헤러를 가지고 있고, 이전 블록이 있으면 이전 블록 헤더를 가리키는 해시 참조를 가지고 있다. 다시 말하면 각기 다른 두 개의 머클 트리를 가리키는 해시 참조를 가지고 있다. 그리고 머클 트리 루트의 이름을 보며 이들이 가진 트랜잭션 데이터가 무엇인지 짐작할 수 있다. P2P 시스템을 생각해보면, <em>이 시스템에 참여했을 때 전체 트랜잭션 데이터, 모든 해시 참조값, 모든 블록헤더를 수신하게 된다.</em> <strong>즉 로컬 컴퓨터는 데이터를 모두 저장하고 저장된 데이터들을 가리키는 해시 참조를 가진 블록체인-데이터-구조를 생성한다.</strong> 여기서 주의할 점은 블록체인-데이터-구조에 각자의 헤더를 가진 수많은 블록이 존재하지만 전체 블록체인-데이터-구조는 오직 하나의 헤드만 가진다는 점이다.</p>
<hr>
<h2 id="15-잘-뜨개질된-블록체인-어떻게-변경할까"><a href="#15-잘-뜨개질된-블록체인-어떻게-변경할까" class="headerlink" title="15. 잘 뜨개질된 블록체인, 어떻게 변경할까?"></a>15. 잘 뜨개질된 블록체인, 어떻게 변경할까?</h2><h3 id="새로운-트랜잭션-추가하기"><a href="#새로운-트랜잭션-추가하기" class="headerlink" title="새로운 트랜잭션 추가하기"></a>새로운 트랜잭션 추가하기</h3><p>최초의 블록체인-데이터-구조는 단 두 개의 트랜잭션만 가지고 있는데, 새 트랜잭션 데이터를 추가하려면 다음의 세 단계를 수행한다.</p>
<ol>
<li>새로 추가하려는 모든 트랜잭션 데이터를 담고 있는 <code>새 머클 트리 생성</code></li>
<li>이전 블록 헤더를 가리키는 해시 참조와 새로운 트랜잭션 데이터를 담고 있는 머클 트리의 루트를 포함하는 <code>새 블록 헤더 생성</code></li>
<li><code>새 블록을 카리키는 해시 참조를 만들고 블록체인-데이터-구조의 헤드 갱신</code></li>
</ol>
<h3 id="변경-감지하기"><a href="#변경-감지하기" class="headerlink" title="변경 감지하기"></a>변경 감지하기</h3><p>블록체인-데이터-구조 내 변경이 발생하면 연쇄 반응을 일으켜 즉시 감지 가능하고, 변경 발생 유형은 아래와 같다.</p>
<ol>
<li>트랜잭션 데이터의 세부 사항 변경</li>
<li>머클 트리의 트랜잭션을 변경하고, 해시 참조를 변경</li>
<li>머클 트리의 트랜잭션과 그 해시 참조를 통째로 대체</li>
<li>머클 트리 루트를 변경</li>
<li>블록 헤더 참조를 변경</li>
</ol>
<p>위의 유형들처럼 트랜잭션이 하나 변경되면 부모 노드를 따라 연쇄반응을 일으켜 블록 헤더값이 변경된다. 이는 자신을 참조하는 블록의 헤더값에 영향을 끼치므로 모든 값에 영향을 미친다. 따라서 제대로 된 방법으로 데이터를 변경하려면 전체 해시 참조 연결고리를 모두 갱신해야하는데, <em>이는 변경된 데이터를 직접 가리키는 해시 참조로부터 시작하여 가장 최근 블록 헤더를 가리키는 해시 참조까지 모든 해시 참조를 갱신하여 변경 내용을 반영한다는 것이다.</em></p>
<h3 id="의도한-변경-vs-의도하지-않은-변경"><a href="#의도한-변경-vs-의도하지-않은-변경" class="headerlink" title="의도한 변경 vs 의도하지 않은 변경"></a>의도한 변경 vs 의도하지 않은 변경</h3><p>해시 참조의 성질에 의해 블록체인-데이터-구조의 해시 참조는 의도된 변경, 의도하지 않은 변경을 구분하지 않고 동일하게 인식한다. 그리고 의도와 상관없이 어느 해시 참조 중 하나라도 유효하지 않으면 전체 데이터 구조가 무효화된다.</p>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/06/220307_blockchain03_08to11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/06/220307_blockchain03_08to11/" class="post-title-link" itemprop="url">블록체인 무엇인가? 3장 블록체인은 어떻게 작동하는가? 08 ~ 11단계</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-07T00:00:00+09:00">2022-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-06 23:40:24" itemprop="dateModified" datetime="2022-12-06T23:40:24+09:00">2022-12-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="3-블록체인은-어떻게-작동하는가"><a href="#3-블록체인은-어떻게-작동하는가" class="headerlink" title="3. 블록체인은 어떻게 작동하는가?"></a>3. 블록체인은 어떻게 작동하는가?</h1><h2 id="8-블록체인의-청사진-그리기"><a href="#8-블록체인의-청사진-그리기" class="headerlink" title="8. 블록체인의 청사진 그리기"></a>8. 블록체인의 청사진 그리기</h2><blockquote>
<p>목표: 소유권을 관리하는 블록체인의 개발. <code>완전히 개방된 환경에서 작동하는 원장의 순수 분산 P2P 시스템에서 소유권을 관리하는 소프트웨어 디자인.</code></p>
</blockquote>
<h3 id="출발점-개발-환경-공유하기"><a href="#출발점-개발-환경-공유하기" class="headerlink" title="출발점: 개발 환경 공유하기"></a>출발점: 개발 환경 공유하기</h3><ul>
<li>시스템은 순수 분산 P2P 시스템이고, 각 사용자가 기여한 계산 자원으로 이루어진다.</li>
<li>인터넷을 사용해 개별 노드의 네트워크를 연결한다.</li>
<li>노드의 개수는 물론 노드의 안정성과 신뢰성도 전혀 알 수 없다.</li>
<li>목표는 <code>디지털 재화의 소유권을 관리하는 것.</code></li>
</ul>
<h3 id="진행경로-7가지-과제-해결하기"><a href="#진행경로-7가지-과제-해결하기" class="headerlink" title="진행경로: 7가지 과제 해결하기"></a>진행경로: 7가지 과제 해결하기</h3><ol>
<li>소유권 기술<ol>
<li>블록체인으로 <code>무엇</code>을 하고 싶은지, <code>소유권을 어떻게 기술할 것인지</code>를 결정한다.</li>
<li>트랜잭션은 소유권의 이전을 설명하는 좋은 방법이며, 트랜잭션 전체 이력은 현 소유자를 확인할 수 있는 핵심이 된다.</li>
</ol>
</li>
<li>소유권 보호<ol>
<li>타인이 다른 사람의 자산에 함부로 접근하지 못하도록 보호해줄 장치</li>
<li><code>암호화 기술</code>을 통해 개별적 트랜잭션을 보호한다.</li>
<li>소유권을 보호하는 과정: 소유주 <code>식별</code> -&gt; 소유주 <code>인증</code> -&gt; 소유주 본인에게만 자산 <code>접근 허가</code></li>
</ol>
</li>
<li>트랜잭션 데이터 저장<ol>
<li>트랜잭션 데이터는 소유권을 명확히 하는 핵심 요소이므로 안전한 방법으로 저장</li>
</ol>
</li>
<li>신뢰할 수 없는 환경에 배분할 원장 준비<ol>
<li>신뢰할 수 없는 환경에서 작동하는 원장의 분산 P2P 시스템을 디자인한다.</li>
<li>이 말은 신뢰를 알 수 없는 환경에 있는 각 노드가 신뢰할 수 있는 행동을 할 때 인센티브가 더 돌아가도록 설계해서 전체 환경을 확률적으로 신뢰할 수 있도록 만든다는 것.</li>
<li>신뢰할 수 없는 환경에서 원장의 복사본들이 신뢰할 수 없는 노드들 사이에 흩어져 있고, 원장을 통제하거나 조정하는 중앙 통제 노드가 존재하지 않아서 각 노드에게 원장의 제어를 맡긴다.</li>
<li>이 상황에서 <code>트랜잭션을 바꾸지 못하도록 막아두는 것</code>으로 원장의 위조나 조작을 막을 수 있다.</li>
<li><strong>원장과 트랜잭션 이력은 한번 기록되면 바꿀 수 없게 하는 것이다.</strong></li>
<li>단 블록체인-데이터-구조에서 변경을 못하게 하면서 새로운 트랜잭션을 추가할 수 없으니 <code>추가 전용 블록체인-데이터-구조</code>로 만들어서 새 트랜잭션을 추가할 수 있도록 승인해야 한다.</li>
</ol>
</li>
<li>원장 배분<ol>
<li>원장을 추가 전용으로 만들고 요청하는 <code>누구에게나 복사본을</code> 만들어주면 원장의 분산 P2P 시스템을 구성할 수 있다.</li>
</ol>
</li>
<li>원장에 새 트랜잭션 추가<ol>
<li>분산 P2P 시스템은 개별적으로 추가 전용 블록체인-데이터-구조를 유지하는 구성원들로 구성된다.</li>
<li><em>오직 유효하고 승인된 트랜잭션만 추가될 수 있도록 보장해야 한다.</em> 이를 위해 P2P 시스템의 구성원 모두에게 새로운 데이터를 추가할 수 있도록 허용하고, 각 구성원이 P2P 시스템의 각 피어를 감독하게 한다.</li>
</ol>
</li>
<li>어느 원장이 진실인지 판단<ol>
<li>P2P 시스템에서 개별 원장에 새로운 트랜잭션을 추가할 수 있도록 허용하면 모든 분산 P2P 시스템에서 발생하는 <code>각 피어들이 서로 다른 트랜잭션 데이터를 받을 가능성</code>이 생긴다.</li>
<li>트랜잭션 이력은 합법적 소유자를 찾기 위한 기초가 되므로 시스템 내 서로 다른 이력이 충돌해서는 안되고, <strong>따라서 진실을 담고 있는 트랜잭션을 가려낼 기준이 필요하다.</strong></li>
<li>순수 분산 P2P 시스템에는 어떤 트랜잭션 이력을 선택해야 할지 결정해 줄 중앙 통제 장치가 없기 때문에 <strong>모든 노드가 독립적인 다수 의견을 따라 진실된 트랜잭션 이력을 개별적으로 결정</strong>해서 문제를 해결하도록 한다.</li>
<li>블록체인이 새 트랜잭션을 추가 전용 블록체인-데이터-구조에 추가하도록 허용하여 문제를 해결할 수 있다.</li>
</ol>
</li>
</ol>
<hr>
<h2 id="9-소유권-기록에서-모든-것이-시작된다"><a href="#9-소유권-기록에서-모든-것이-시작된다" class="headerlink" title="9. 소유권 기록에서 모든 것이 시작된다"></a>9. 소유권 기록에서 모든 것이 시작된다</h2><h3 id="목표-누가-보더라도-명확히-알-수-있게-소유권-기록하기"><a href="#목표-누가-보더라도-명확히-알-수-있게-소유권-기록하기" class="headerlink" title="목표: 누가 보더라도 명확히 알 수 있게 소유권 기록하기"></a>목표: 누가 보더라도 명확히 알 수 있게 소유권 기록하기</h3><ul>
<li>해결해야 할 과제: 소유권에 대한 주장을 기록하고, <strong>소유권에 대한 증거까지 제공하여 소유권 자체를 증명하는 기록 방법을 찾아낸다.</strong></li>
<li>아이디어: 소유권의 현 상태를 재산 목록 데이터 형태로 단순 기술하지 않고, <strong>소유권이 이전된 이력까지 원장에 빠짐없이 기록 보관한다.</strong></li>
</ul>
<h3 id="목록과-트랜잭션-데이터는-어떻게-다른가"><a href="#목록과-트랜잭션-데이터는-어떻게-다른가" class="headerlink" title="목록과 트랜잭션 데이터는 어떻게 다른가?"></a>목록과 트랜잭션 데이터는 어떻게 다른가?</h3><p>소유권을 기술한다는 점에서는 같고, 아래와 같은 차이점이 있다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>소유권 목록</th>
<th>트랜잭션 데이터</th>
</tr>
</thead>
<tbody>
<tr>
<td>소유권 목록을 작성</td>
<td>트랜잭션 데이터를 작성</td>
</tr>
<tr>
<td>소유권의 <code>현 상태</code>를 기술</td>
<td>소유권의 <code>이전 이력</code>을 기술</td>
</tr>
<tr>
<td>e.g. 잔고증명서(은행 계좌의 현 잔고 표시)</td>
<td>e.g. 거래내역조회서(출금, 입금 등의 내역을 모두 표시하여 보여줌)</td>
</tr>
<tr>
<td><code>단순하게 소유권을 주장</code></td>
<td><code>소유권을 설명하고 증명</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="작동-원리"><a href="#작동-원리" class="headerlink" title="작동 원리"></a>작동 원리</h3><p>블록체인 소유권 기록에 필요한 두 가지</p>
<ol>
<li>소유권 이전을 기술</li>
<li>트랜잭션 이력을 유지</li>
</ol>
<h4 id="1-소유권-이전을-기술"><a href="#1-소유권-이전을-기술" class="headerlink" title="1. 소유권 이전을 기술"></a>1. 소유권 이전을 기술</h4><p>현 소유자의 소유권을 다른 사람에게 이전하는 행위를 트랜잭션이라 한다. 이때 데이터에 의도한 이전을 데이터에 기록하고, 이 데이터에는 소유권 이전에 필요한 모든 정보가 담긴다. 은행의 계좌이체 시 계좌이체 서식과 비슷하다. 단, 중앙 통제된 은행에서 동일한 수수료 체계를 사용하는 것과 달리 블록체인은 중앙 통제가 없는 분산 시스템이므로 통일된 수수료 체계가 없다. 블록체인은 트랜잭션을 기술하기 위해 다음의 정보를 이용한다.</p>
<ol>
<li>다른 계정으로 소유권을 이전하려는 계정의 식별자</li>
<li>소유권을 이전받으려는 계정의 식별자</li>
<li>이전하려는 재화의 총액</li>
<li>이전이 완료되는 시각</li>
<li>이전하기 위해 시스템에 지불해야 하는 수수료</li>
<li>이전에 동의한다는 원소유자의 증명</li>
</ol>
<h4 id="2-트랜잭션-이력의-유지"><a href="#2-트랜잭션-이력의-유지" class="headerlink" title="2. 트랜잭션 이력의 유지"></a>2. 트랜잭션 이력의 유지</h4><p>트랜잭션의 수행은 트랜잭션 데이터에 기록된 대로 소유권의 이전이 일어난다는 것이며 원장에 트랜잭션 데이터를 추가한다는 의미이다. <em>블록체인은 모든 트랜잭션을 일어난 순서대로(기록된 순서대로) 블록체인-데이터-구조에 저장하여 전체 이력을 유지한다.</em></p>
<ul>
<li>작동하는 이유: 트랜잭션 데이터는 소유권을 이전하려는 계정에 대한 모든 정보를 가지고 있어서 트랜잭션 전체 이력만 존재하면 소유권 관련 정보를 재구성할 수 있다.</li>
<li>트랜잭션 순서가 중요하다: 트랜잭션 데이터를 합치는 이유는 <em>소유권 이전 내역을 재구성해 현 소유권자를 찾아내고 소유권을 명확화하려는 목적에서다.</em> 따라서 데이터를 합칠 때마다 트랜잭션이 발생했던 순서 그대로 동일하게 재현되는 것이 매우 중요하다. 트랜잭션 순서가 달라지면 데이터가 합쳐진 결과도 달라지기 때문이다.</li>
<li>트랜잭션 이력의 무결성을 유지하기 위해 필요한 3요소<ul>
<li><code>트랜잭션 데이터의 이력이야말로 소유권을 관리하는 블록체인의 심장</code>이다. 전체 시스템의 무결성을 지키려면 이력 데이터를 안전하고 완전하며 정확하고 일관되게 유지해야 한다. 따라서 블록체인은 오직 유효한 트랜잭션 데이터만 블록체인-데이터-구조에 추가되도록 보장하는 보안 수단을 제공해야 한다.</li>
<li>트랜잭션 데이터 유효성 검사를 위한 3가지 요소<ul>
<li><code>형식적 정확성</code>: 트랜잭션 데이터가 필요한 모든 정보를 정확한 형식으로 기술한다.</li>
<li><code>의미상 정확성</code>: 트랜잭션 데이터의 의미와 의도한 결과, 즉 의미상 정확성을 검증하기 위해 해당 사업 영역에 대한 지식이 필요하다. 트랜잭션 <em>데이터의 의미상 정확성을 조사하기 위해서는 대개 업계 관행에 따른다.</em></li>
<li><code>승인</code>: 소유권을 이전하는 소유권자 본인만 자신을 대신해 트랜잭션을 실행해달라고 블록체인에 요청할 수 있어야 한다. <strong>스마트 컨트랙션으로 대변되는 블록체인 트랜잭션의 특징은 단순 기록이 아닌 계약의 실행에 있고,</strong> 계좌 소유자가 정말로 소유권 이전에 동의하는지 증명할 수 있는 정보를 반드시 가지고 있어야 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="10-데이터-해싱하기"><a href="#10-데이터-해싱하기" class="headerlink" title="10. 데이터 해싱하기"></a>10. 데이터 해싱하기</h2><blockquote>
<p>해시값: 블록체인의 가장 중요한 기반 기술, 지문의 디지털 버전, 암호화 해시값, <strong>블록체인에서 광범위하게 사용하기 때문에 암호화 해싱에 대해 알아여 블록체인에 대해 이해할 수 있다.</strong></p>
</blockquote>
<h3 id="목표-암호화-해싱으로-데이터-식별하기"><a href="#목표-암호화-해싱으로-데이터-식별하기" class="headerlink" title="목표: 암호화 해싱으로 데이터 식별하기"></a>목표: 암호화 해싱으로 데이터 식별하기</h3><p>분산 P2P 시스템에서는 엄청난 양의 트랜잭션 데이터를 다루기 때문에 고유한 트랜잭션을 식별해서 최대한 빨리 비교해야 한다. <strong>목표는 디지털 지문(암호화 해시값)으로 트랜잭션을 식별하고, 모든 종류의 데이터를 식별할 수 있도록 하는 것이다.</strong></p>
<h3 id="작동원리"><a href="#작동원리" class="headerlink" title="작동원리"></a>작동원리</h3><ul>
<li><code>해시함수</code>: 어떤 형태의 데이터든 입력 데이터의 길이와 상관없이 고정된 길이의 숫자로 변환하는 함수<ul>
<li>한 번에 하나의 데이터만 입력받아 그 데이터를 구성하는 비트와 바이트를 이용해서 해시값 생성</li>
<li>함수의 종류에 따라 서로 다른 길이로 생성되고, 길이를 채우기 위해 앞자리 수를 0으로 채울 때도 있다.</li>
</ul>
</li>
<li><code>암호화 해시 함수</code>: 중요한 해시 함수 그룹으로 어떤 데이터라도 고유의 디지털 지문을 생성해주는 해시 함수</li>
</ul>
<h3 id="암호화-해시-함수의-특징"><a href="#암호화-해시-함수의-특징" class="headerlink" title="암호화 해시 함수의 특징"></a>암호화 해시 함수의 특징</h3><blockquote>
<ol>
<li>어떤 종류의 데이터든 즉시 해시값 제공</li>
<li>확정적</li>
<li>의사 난수</li>
<li>일방 함수</li>
<li>충돌 회피</li>
</ol>
</blockquote>
<h4 id="1-어떤-종류의-데이터든-즉시-해시값-제공"><a href="#1-어떤-종류의-데이터든-즉시-해시값-제공" class="headerlink" title="1. 어떤 종류의 데이터든 즉시 해시값 제공"></a>1. 어떤 종류의 데이터든 즉시 해시값 제공</h4><ol>
<li>어떤 종류의 데이터든 해시값을 생성할 수 있다.</li>
<li>해시값 계산을 빠르게 할 수 있다.</li>
</ol>
<blockquote>
<p>이 두가지 성질을 조합하여 해시 함수가 오류 메시지 같은 쓸모없는 것을 생성하거나 결과를 반환하기 위해 긴 시간을 소비하지 않도록 해준다. 매우 중요한 특징이다.</p>
</blockquote>
<h4 id="2-확정적"><a href="#2-확정적" class="headerlink" title="2. 확정적"></a>2. 확정적</h4><p><strong>동일하게 입력했을 때 동일하게 출력해야 한다.</strong> 만약 해시값이 다르다면 입력 값이 다른 것이지 해시 함수 내부 작동에 의한 것이 아니다.</p>
<h4 id="3-의사-난수"><a href="#3-의사-난수" class="headerlink" title="3. 의사 난수"></a>3. 의사 난수</h4><p><strong>입력 데이터가 변하면 해시값이 예측 불가하게 변해야 한다.</strong> 적은 비트만 바꿔서 입력해도 해시값이 크게 변하여 입력 데이터를 보고 해시값을 예측할 수 없어야 한다.</p>
<h4 id="4-일방-함수-비가역-함수"><a href="#4-일방-함수-비가역-함수" class="headerlink" title="4. 일방 함수(비가역 함수)"></a>4. 일방 함수(비가역 함수)</h4><p><strong>출력으로 입력을 알 수 있는 방법이 존재하지 않는 함수.</strong> 해시값을 이용해 원래 입력 값을 복원하는 것이 불가능하다.</p>
<h4 id="5-충돌-회피"><a href="#5-충돌-회피" class="headerlink" title="5. 충돌 회피"></a>5. 충돌 회피</h4><p><strong>둘 이상의 데이터가 동일한 해시값을 생성하는 것이 지극히 어려울 때 그 해시 함수를 충돌 회피라 한다.</strong> 즉 서로 다른 데이터가 동일한 해시값을 가질 확율이 매우 낮으면 그 해시 함수는 충돌 회피이고, 이런 해시 함수로 생성된 해시값은 고유성을 지녀 데이터를 식별하는 데 사용할 수 있다. 이 말은 반대로 서로 다른 데이터가 동일한 해시값을 얻으면 충돌에 직면한다는 것이다. 이는 일어나서는 안될 일이며, 이를 회피하기 위해서 엄청난 노력이 쏟아부어진다.</p>
<h3 id="해시-함수-직접-적용해-보기"><a href="#해시-함수-직접-적용해-보기" class="headerlink" title="해시 함수 직접 적용해 보기"></a>해시 함수 직접 적용해 보기</h3><p>해시값은 해시 수로도 불리는 데 16진수로 나타내고, 아래 예시처럼 Input값이 동일하더라도 해시 함수의 종류에 따라 출력된 해시값이 달라진다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;INPUT</span><br><span class="line">Hello World!</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;OUTPUT</span><br><span class="line">MD5: ED076287532E86365E841E92BFC50D8C</span><br><span class="line">SHA1: 2EF7BDE608CE5404E97D5F042F95F89F1C232871</span><br><span class="line">SHA256: 7F83B1657FF1FC53B92DC18148A1D65DFC2D4B1FA3D677284ADDD200126D9069</span><br><span class="line">SHA512: 861844D6704E8573FEC34D967E20BCFEF3D424CF48BE04E6DC08F2BD58C729</span><br><span class="line">743371015EAD891CC3CF1C9D34B49264B510751B1FF9E537937BC46B5D6FF4ECC8</span><br></pre></td></tr></table></figure>
<h3 id="해싱된-데이터의-5가지-패턴"><a href="#해싱된-데이터의-5가지-패턴" class="headerlink" title="해싱된 데이터의 5가지 패턴"></a>해싱된 데이터의 5가지 패턴</h3><p>하나의 데이터가 해시 함수에 입력되면 그 데이터에 해당하는 해시값이 생성되는데, <strong>이는 모든 독립된 데이터는 자신만의 고유한 암호화 해시값을 갖는다는 것을 의미한다.</strong> 만약 서로 독립적인 데이터들의 묶음에 대해 하나의 해시값만 생성하고 싶다면 아래의 5가지 패턴을 사용해서 해시 함수를 적용한다.</p>
<ol>
<li><code>독립 해싱</code><ol>
<li>각 데이터에 대해 독립적으로 해시 함수를 적용한다.</li>
</ol>
</li>
<li><code>반복 해싱</code><ol>
<li>해시 출력값에 해시 함수를 한번 더 적용한다.</li>
<li>해시값은 그 자제로 하나의 데이터로 간주할 수 있기 때문에 해시값을 다시 해시 함수에 입력해서 그에 해당하는 또 다른 해시값을 계산한다.</li>
</ol>
</li>
<li><code>결합 해싱</code><ol>
<li>하나 이상의 데이터에 해싱을 한 번만 적용하여 단일 해시값을 얻는다.</li>
<li>독립된 데이터들을 합쳐 하나의 데이터로 만들고 합쳐진 데이터의 해시값을 계산한다. (제공된 모든 데이터를 한꺼번에 결합)</li>
<li>주어진 시간 안에 가용한 모든 데이터의 집합에 단일 해시값을 부여할 때 유용하다.</li>
<li>다만 리소스(계산 자원, 시간, 기억 공간 등)가 많이 들기 때문에 개별 데이터가 크지 않을 때만 사용한다.</li>
<li>결합된 데이터만 해시 함수에 전달되었기 때문에 개별 데이터의 해시값은 알 수 없다는 단점이 있다.</li>
</ol>
</li>
<li><code>순차적 해싱</code><ol>
<li>새로운 데이터가 도착할 때마다 기존의 해시값이 새로운 데이터와 합쳐져서 해시값을 즉시 갱신한다.</li>
<li>결합 해싱과 반복 해싱을 동시에 사용하는 것이다.</li>
<li>단일 해시값만 유지하면서 새로운 데이터가 도착하는 즉시 해시값을 갱신하고자 할 때 유용하다.</li>
<li>특정 시점의 해시값으로 해당 데이터가 도착한 시점을 추적할 수 있다.</li>
<li>old + new =&gt; brand new</li>
</ol>
</li>
<li><code>계층적 해싱</code><ol>
<li>두 해시값에 결합 해싱을 적용한다. 그러면 최상위에 단일 해시값을 가지는 작은 계층이 형성된다.</li>
<li>결합 해싱과 유사하게 데이터 묶음에서 단일 해시값을 얻고자 하는 아이디어를 가지고 있다.</li>
<li>길이가 매번 변하는 입력이 아니라 늘 일정한 길이의 해시값을 합치기 때문에 효율적이다.</li>
<li>매 단계에서 오직 2개의 해시값만 결합한다.</li>
</ol>
</li>
</ol>
<hr>
<h2 id="11-해시값은-어디서-어떻게-사용될까"><a href="#11-해시값은-어디서-어떻게-사용될까" class="headerlink" title="11. 해시값은 어디서 어떻게 사용될까?"></a>11. 해시값은 어디서 어떻게 사용될까?</h2><h3 id="1-데이터-비교"><a href="#1-데이터-비교" class="headerlink" title="1. 데이터 비교"></a>1. 데이터 비교</h3><ul>
<li><code>목표</code>: 데이터의 크기나 내용과 상관없이 오직 숫자 두 개만 대조해서 쉽게 비교한다.</li>
<li><code>아이디어</code>: <strong>데이터 내용 전체를 일일이 비교하는 대신 암호화된 해시값을 비교한다.</strong></li>
<li><code>작동 원리</code>: 비교하려는 모든 데이터의 암호화 해시값을 계산한 다음 서로 비교한다. 해시값이 다르면 비교 데이터도 다르고, 해시값이 동일하면 입력 데이터가 동일한 것이다.</li>
<li><code>작동하는 이유</code>: 암호화 해시값을 통해 데이터를 비교할 수 있는 <strong>암호화 해시 함수의 충돌 회피 성질</strong> 때문.</li>
</ul>
<h3 id="2-데이터의-변경-감지"><a href="#2-데이터의-변경-감지" class="headerlink" title="2. 데이터의 변경 감지"></a>2. 데이터의 변경 감지</h3><ul>
<li><code>목표</code>: 데이터가 일정 시간이 경과되었거나 타인에게 전송한 후, 또는 데이터베이스에 저장한 후 변경되었는지 확인한다.</li>
<li><code>아이디어</code>: <strong>과거에 기록해 둔 암호화 해시값과 검사하려는 데이터에서 새로 생성한 암호화 해시값을 서로 비교하여 변경되었는지 알아낸다.</strong> 해시값이 동일하면 데이터가 변경되지 않은 것이다.</li>
<li><code>작동 원리</code>: 변경되면 안되는 데이터의 암호화 해시값을 만들어두고, 데이터가 변경되었는지 확인이 필요해질 때 데이터의 암호화 해시값을 다시 생성한다. 그리고, 새로운 해시값과 이전의 해시값을 비교한다. 데이터 전송 전에 해시값을 생성한 후, 수신한 사람이 새로 해시값을 생성해서 그 두 값을 비교하면 전송 도중에 데이터가 변경되었는지 여부를 확인할 수 있다.</li>
<li><code>작동하는 이유</code>: 데이터의 변경 감지는 어떤 이벤트 전후의 해시값 비교를 통해 이루어지고, <strong>암호화 해시 함수의 충돌 회피 성질</strong> 때문에 가능하다.</li>
</ul>
<h3 id="3-변경-감지-방식의-데이터-참조"><a href="#3-변경-감지-방식의-데이터-참조" class="headerlink" title="3. 변경-감지 방식의 데이터 참조"></a>3. 변경-감지 방식의 데이터 참조</h3><blockquote>
<p>블록체인은 해시 참조에 크게 의존하기 때문에, 해시 참조를 꼭 이해해야 한다.</p>
</blockquote>
<ul>
<li><code>목표</code>: 어딘가에 저정된 <code>데이터를 참조</code>하여 데이터가 변경되지 않았다는 것을 보장한다.</li>
<li><code>아이디어</code>:<ul>
<li>데이터와 그 데이터가 저장된 장소 정보를 결합하여 해시값으로 암호화한다. 데이터가 변경되면 데이터와 저장 장소에 대한 정보가 일치하지 않아 유효하지 않은 참조가 된다.</li>
<li>기술적인 오류나 누군가의 고의로 인해 사용자도 모르게 참조 데이터가 변경되었을 때 원본 데이터를 추출하지 못하도록 보호한다.</li>
<li>해시 참조는 한번 생성된 이후 절대 변경되어서는 안되는 데이터에 사용한다.</li>
</ul>
</li>
<li><code>작동 원리</code>:<ul>
<li>컴퓨터 프로그램은 데이터가 저장된 장소를 기억했다가 나중에 추출하기 위해 <code>참조값</code>을 사용하는데, <code>해시 참조는 참조값으로 암호화 해시값을 활용한다.</code></li>
<li>해시 참조로 참조 데이터가 만들어진 뒤로 데이터가 변경되었는지 여부를 검증한다. 참조한 데이터가 변경되었다면 원래 있던 참조값으로 더이상 데이터를 추출할 수 없기 때문이다.</li>
</ul>
</li>
<li><code>작동하는 이유</code>: <strong>암호화 해시값을 활용하는 것이 핵심이다.</strong> 해시값은 고유한 지문과 같은 것이므로 서로 다른 데이터 조각들이 동일한 해시값을 가질 가능성은 극히 드물고, 참조가 깨졌다면 데이터가 변경되었다는 증거가 된다.</li>
</ul>
<h3 id="4-변경-감지-방식으로-데이터-저장"><a href="#4-변경-감지-방식으로-데이터-저장" class="headerlink" title="4. 변경-감지 방식으로 데이터 저장"></a>4. 변경-감지 방식으로 데이터 저장</h3><ul>
<li><code>목표</code>: 변경되어서는 안되는 방대한 데이터, <strong>즉 트랜잭션 데이터를 저장하고, 어떠한 변경도 빠르고 손쉽게 발견할 수 있다.</strong></li>
<li><code>아이디어</code>:<ul>
<li>데이터를 저장할 때 다른 데이터를 가리키는 해시 참조를 함께 저장할 수 있는데, 가리킨 데이터가 또 다른 데이터를 가리키는 해시 참조와 함께 저장하는 방식으로 연속적으로 긴 체인을 형성할 수 있다.</li>
<li>어느 한 데이터라도 해시 참조가 변경이 되면 전체 해시 참조가 손상되고 이것이 데이터가 변경되었다는 증거가 된다.</li>
</ul>
</li>
<li><code>작동 원리</code>:<ul>
<li><ol>
<li><code>체인 방식</code></li>
</ol>
<ul>
<li>연결 리스트(linked list)라 불리고, 각 데이터가 가른 데이터의 해시 참조를 가지는 구조.</li>
<li>데이터가 순차적으로 나타날 때 유용하다.</li>
<li>가장 최근에 추가된 데이터를 참조하는 해시 참조를 헤드(head)라 부르고, 헤드만 있으면 체인으로 연결되어 있는 전체 데이터에 대해 역순으로 모두 접근할 수 있다.</li>
</ul>
</li>
<li><ol>
<li><code>트리 방식</code></li>
</ol>
<ul>
<li>머클 트리(merkle tree)라 불리고, 해시 참조와 트랜잭션 데이터가 트리 형태로 연결되어 있다.</li>
<li><strong>같은 시각에 존재하는 모든 데이터를 한데 묶어 단일 해시 참조로 접근하고자 할 때 유용하다.</strong></li>
<li>최초의 트랜잭션 데이터에서 시작하여 각각에 대한 해시 참조를 생성하고, 각각의 해시참조가 둘씩 쌍을 이루게 한 후, 각 해시 참조 쌍을 가리키는 해시 참조를 또 생성하고, <strong>이런 과정을 단일 해시 참조만 남을 때 까지 반복한다.</strong></li>
<li><em>최종적으로 남은 단일 해시 참조는 머클 트리의 루트라 부른다.</em></li>
</ul>
</li>
</ul>
</li>
<li><code>작동하는 이유</code>: 데이터와 해시 참조를 연결하여 결합하므로 변경-감지 방식으로 데이터를 저장할 수 있다. 그러므로 이 구조에서 손상된 참조가 있다면 데이터가 변경되었다는 증거가 된다.</li>
</ul>
<h3 id="5-시간-소모적-계산량-유발"><a href="#5-시간-소모적-계산량-유발" class="headerlink" title="5. 시간-소모적 계산량 유발"></a>5. 시간-소모적 계산량 유발</h3><ul>
<li><code>목표</code>: 해시값이 컴퓨터끼리 퍼즐 대결을 하는 데 사용될 수 있고, 컴퓨터의 계산 자원을 사용해야만 해결할 수 있는 퍼즐이 필요할 때가 있는데, <strong>이 퍼즐을 푸는 유일한 방법은 오로지 엄청난 양의 컴퓨터 계산 자원에 의존하는 것뿐이어야 한다.</strong> 해시값의 이런 용도가 블록체인의 가장 중요한 개념 중 하나이다. (비트코인을 캔다는 의미의 ‘채굴’은 블록을 만드는 행위이고, 직접 새 블록을 만들려면 반드시 해시 퍼즐을 풀어야 한다.)</li>
<li><code>아이디어</code>: 비밀번호를 정확히 눌러야만 열리는 특수 자물쇠처럼 비밀번호를 알 때까지 가능한 모든 수의 조합을 반복해서 시도하는 방식이다. <code>해시 퍼즐은 오직 시행착오로만 해결할 수 있다.</code></li>
<li><p><code>작동 원리</code>: 해시 퍼즐의 요소.</p>
<ul>
<li>변경되면 안 되는 주어진 데이터</li>
<li>자유롭게 변경 가능한 데이터, 난스(nonce)</li>
<li>적용할 해시 함수</li>
<li>결합 해싱의 해시값에 주어진 제약 조건, 난이도(difficulty level)<blockquote>
<p>데이터와 난스에 결합 해싱을 적용해 도출한 결과 해시값이 주어진 조건을 만족해야 한다.</p>
<ul>
<li>난스를 추측하고 데이터와 결합해 해시 함수를 사용해 해시값을 계산한 후 주어진 제약조건에 따라 결과 해시값을 평가한다.</li>
<li>해시값이 제약조건을 만족하면 퍼즐이 풀린다. 이렇게 어떤 난스가 데이터와 결합해 생성한 해시값이 제약조건을 만족했을 때 그 난스를 <code>해답</code>이라 부른다.</li>
<li>해시 퍼즐을 해결했다면 항상 그 특정 난스(해답)을 보여줘야 한다.</li>
</ul>
</blockquote>
</li>
<li><code>해시 퍼즐의 난이도</code><ul>
<li><strong>해시값이 특정 제약조건을 만족시키는 것이 해시 퍼즐의 핵심</strong></li>
<li>해시 퍼즐에 사용하는 조건은 임의로 만들어서 안되고 표준화되어 컴퓨터끼리 서로 시합할 수 있어야 한다.</li>
<li>해시 퍼즐에서 제약조건을 <code>난이도</code>라 부른다.</li>
<li>난이도의 숫자는 해시값의 맨 앞 자리부터 최소 하나 이상의 0으로 채워진다. (난이도 10은 해시값의 맨 앞자리부터 연속된 10자리 이상이 0이어야 한다는 뜻이다.)</li>
</ul>
</li>
</ul>
</li>
<li><p><code>작동하는 이유</code>: 해시 퍼즐은 해시 함수가 <code>일방향 함수</code>라는 성질에 전적으로 의존해 작동하기 때문에 제약조건을 연구하여 역함수로 해시 퍼즐을 해결하는 것은 불가하다.</p>
</li>
</ul>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/02/220303_blockchain02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/02/220303_blockchain02/" class="post-title-link" itemprop="url">블록체인 무엇인가? 2장 왜 우리에게 블록체인이 필요한가?</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-03 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-03T00:00:00+09:00">2022-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-06 23:40:24" itemprop="dateModified" datetime="2022-12-06T23:40:24+09:00">2022-12-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2-왜-우리에게-블록체인이-필요한가"><a href="#2-왜-우리에게-블록체인이-필요한가" class="headerlink" title="2. 왜 우리에게 블록체인이 필요한가?"></a>2. 왜 우리에게 블록체인이 필요한가?</h1><h2 id="4-블록체인에게-떨어진-미션"><a href="#4-블록체인에게-떨어진-미션" class="headerlink" title="4. 블록체인에게 떨어진 미션"></a>4. 블록체인에게 떨어진 미션</h2><blockquote>
<p>P2P 시스템의 지속가능성은 신뢰와 무결성에 달려 있다</p>
</blockquote>
<p>신뢰와 무결성은 동전의 양면과 같다. 신뢰가 사전에 형성되고 지속적인 상호작용의 결과에 따라 더욱 굳어지거나 약해진다. P2P 시스템은 시스템을 믿는 사람들이 일단 합류하여 시스템에 기여한다. 이후 상호작용 결과가 만족스러우면 계속해서 시스템의 구성원으로 남는다. 사용자들이 계속해서 구성원으로 참여할 수 있도록 시스템에 대한 신뢰를 강화시키려면 <code>시스템의 무결성</code>이 필요하다. 이것이 부족하면 신뢰가 낮아지고 소비자를 잃게 된다.</p>
<p><em>그렇다면 순수 분산 P2P 시스템의 무결성을 확보하고 유지할 수 있는 방법은 무엇일까?</em></p>
<ul>
<li>전체 노드 또는 피어의 개수를 아는가?</li>
<li>각 피어의 신뢰성에 대해 어느 정도 알고 있는가?</li>
</ul>
<p>분산 P2P 시스템 내의 <code>노드 개수</code>와 <code>각 노드의 신뢰성</code>을 알고 있다면 무결성을 확보할 가능성이 더 커진다.</p>
<h3 id="P2P-시스템의-무결성을-위협하는-두-가지-요소"><a href="#P2P-시스템의-무결성을-위협하는-두-가지-요소" class="headerlink" title="P2P 시스템의 무결성을 위협하는 두 가지 요소"></a>P2P 시스템의 무결성을 위협하는 두 가지 요소</h3><ol>
<li>기술적 결함</li>
</ol>
<p>P2P 시스템은 사용자의 개별 컴퓨터로 구성되는데 기계장비라는 것은 언제든 고장이나 오류를 일으킬 수 있기 때문에 개별 컴퓨터나 네트워크 장비 등이 고장이나 오류를 일으켰을 때 대처할 수 있어야 한다.</p>
<ol>
<li>악의적 피어</li>
</ol>
<p>기술적인 원인이 아닌 시스템을 자신의 이릭을 위해 착취하려는 악의적 사용자들이 있고, 이런 사용자들이 P2P 시스템의 신뢰성을 무너뜨린다. 다른 피어를 믿지 못하게 된다면 시스템 사용자들은 시스템을 떠날 것이다.</p>
<blockquote>
<p>블록체인이 해결해야 할 과제는 <code>개수도 알려져 있지 않고 신뢰성과 안정성도 알 수 없는 피어들로 구성된 순수 분산 P2P 시스템의 무결성을 확보하고 유지하는 것이다.</code> 컴퓨터 과학 분야에서는 비잔틴 장군 문제라 한다.</p>
</blockquote>
<hr>
<h2 id="5-그래서-블록체인이-뭔가요"><a href="#5-그래서-블록체인이-뭔가요" class="headerlink" title="5. 그래서 블록체인이 뭔가요?"></a>5. 그래서 블록체인이 뭔가요?</h2><blockquote>
<ol>
<li>데이터 구조의 명칭</li>
<li>알고리즘의 명칭</li>
<li>기술묶음의 명칭</li>
<li>일반 응용분야를 가지는 순수 분산 P2P 시스템을 포괄하는 용어</li>
</ol>
</blockquote>
<ol>
<li>데이터 구조의 명칭<blockquote>
<p>블록이라 불리는 단위에 모인 모든 데이터</p>
</blockquote>
</li>
</ol>
<p>블록체인은 책을 구성하는 페이지들과 유사하게 마치 체인처럼 서로 연결되어 있어서 블록체인이라는 이름이 붙었다. 데이터 구조에서 데이터 블록의 연결은 책의 페이지 번호 매김 방식과는 다른 특수한 번호 매김 방식을 사용한다.</p>
<ol>
<li><p>알고리즘의 명칭</p>
<blockquote>
<p>순수 분산 P2P 시스템에서 여러 블록체인-데이터-구조 내의 정보 내용을 민주주의 투표 방식과 비슷한 방법을 써서 서로 협상하는 일련의 명령어</p>
</blockquote>
</li>
<li><p>기술묶음의 명칭</p>
<blockquote>
<p>블록체인-데이터-구조, 블록체인-알고리즘, 암호화 및 보안 기술의 조합을 의미.</p>
</blockquote>
</li>
</ol>
<p>이들의 조합은 응용분야와 상관없이 순수 분산 P2P 시스템의 무결성을 확보하는 데 이용될 수 있다.</p>
<ol>
<li><p>일반 응용분야를 가지는 순수 분산 P2P 시스템을 포괄하는 용어</p>
<blockquote>
<p>블록체인-기술묶음을 활용하는 거래장부(원장ledger)들의 순수 분산 P2P 시스템을 지칭하는 포괄적인 용어</p>
</blockquote>
</li>
</ol>
<p>이 맥락에서 쓰이는 블록체인은 순수 분산 시스템을 구성하는 한 부분인 소프트웨어의 단위를 의미하는 것이 아니라 <code>순수 분산 시스템 전체를 의미한다.</code></p>
<p>이 책에서는 블록체인을 블록체인-기술묶음을 활용하는 원장의 순수 분산 P2P 시스템을 지칭하는 포괄적인 의미로 사용.</p>
<h3 id="블록체인이란"><a href="#블록체인이란" class="headerlink" title="블록체인이란?"></a>블록체인이란?</h3><blockquote>
<p>무결성을 확보하고 유지하기 위해 순서에 따라 연결된 블록들의 정보 내용을 암호화 기법과 보안기술을 이용해 협상하는 알고리즘으로 구성된 소프트웨어 요소를 활용하는 원장의 순수 분산 P2P 시스템.</p>
</blockquote>
<p>보통 블록체인의 목적을 디지털 화페의 소유권을 관리하기 위한 것으로 두기 마련인데, <strong>암호화폐의 소유권을 관리하는 것은 블록체인 응용분야의 하나일 뿐이며, 그 자체가 블록체인의 전부는 아니다.</strong></p>
<p>다만 블록체인이 유독 디지털 재화의 소유권 관리 측면이 부각된 것은 <em>1. 이해하고 설명하기 쉽고, 2. 경제에 가장 크게 영향을 미치는 실사례</em>이기 때문이다. 소유와 소유권 강화는 인간사회의 핵심 요소이기 때문에 소유권 관리 방식을 혁신적으로 바꿀 수 있는 블록체인이 엄청난 변혁을 불러올 수 있는 기술이라 여겨진다.</p>
<hr>
<h2 id="6-소유권의-본질-이해하기"><a href="#6-소유권의-본질-이해하기" class="headerlink" title="6. 소유권의 본질 이해하기"></a>6. 소유권의 본질 이해하기</h2><p>소유권을 증명하기 위해 단 한 명의 목격자라도 확보하는 것은 좋은 일인데, <strong>특히 독립적인 다수의 목격자를 확보하는 것이 중요하다.</strong> 이 아이디어가 블록체인의 핵심 개념 중 하나이다.</p>
<h3 id="소유권-입증에-필요한-3요소"><a href="#소유권-입증에-필요한-3요소" class="headerlink" title="소유권 입증에 필요한 3요소"></a>소유권 입증에 필요한 3요소</h3><ul>
<li>소유자가 누구인가</li>
<li>소유 물건은 무엇인가</li>
<li>소유자와 물건의 매핑</li>
</ul>
<p>소유권 사용은 오직 허가박은 사람만 그 자산을 사용하도록 인증하고 승인하면서 식별도 필요하다.</p>
<h3 id="속성으로-보안의-3가지-개념-이해하기"><a href="#속성으로-보안의-3가지-개념-이해하기" class="headerlink" title="속성으로 보안의 3가지 개념 이해하기"></a>속성으로 보안의 3가지 개념 이해하기</h3><ul>
<li>식별 : <code>누구</code>라고 주장하는 것</li>
<li>인증 : 당신과 당신이라고 주장하는 누군가가 <code>일치하는지 증명</code></li>
<li><p>승인 : 사전에 인증된 개체에 대해 무엇인가에 대한 <code>접근을 허가하는 것.</code></p>
</li>
<li><p><code>식별</code>: <strong>이름 또는 다른 식별자를 사용해 ‘누군가’라고 주장하는 것.</strong> 식별을 통해 대상이 ‘누구’라고 주장할 수 있는데 그렇게 주장한 사람과 누구로 주장된 사람이 일치하는지는 증명할 수 없다.</p>
</li>
<li><p><code>인증</code>: <strong>어떤 사람이 다른 누군가를 사칭하는 것을 방지하기 위한 것.</strong> ‘누구’라고 주장한 사람과 ‘누구’로 주장된 사람이 일치하는지를 ‘무엇’을 통해 증명한다. 이때 ‘무엇’은 ‘누구’라고 주장되는 그 사람만의 고유한 무엇이어야 한다. (e.g. 지문, 얼굴 사진 등 고유성을 식별해 줄 수 있는 것.)</p>
</li>
<li><p><code>승인</code>: <strong>식별된 사람의 성질과 특성에 기반해 특정 자원이나 서비스에의 접근을 허가해 주는 것.</strong> 성공적인 인증과 함께 인증된 특정인이 가진 특성과 권리에 대한 평가를 토대로 얻는 최종 결과. 항상 이미 인증된 개체의 특성이나 성질을 특정 규칙과 비교 평가한 다음 이루어진다.</p>
</li>
</ul>
<h3 id="원장은-소유권을-증명하기도-이전하기도-한다"><a href="#원장은-소유권을-증명하기도-이전하기도-한다" class="headerlink" title="원장은 소유권을 증명하기도, 이전하기도 한다"></a>원장은 소유권을 증명하기도, 이전하기도 한다</h3><p>원장은 두 가지 상반된 역할을 수행한다.</p>
<ul>
<li>원장에서 읽은 과거 데이터를 이용해 <strong>소유권을 증명해 주는 수단</strong>의 역할</li>
<li>소유권의 이전이 발생한 경우 <strong>원장에 새로운 데이터를 생성하여 이 사실을 문서화</strong>해두는 역할</li>
</ul>
<p>원장이 누구에게나 공개되어 있다면 소유권 증명은 쉬워진다. 따라서 투명성은 소유권을 증명하는 기초가 되고, 소유권의 이전은 법적인 소유자에게만 배타적으로 허가된다.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>원장의 소유권 증명</th>
<th>원장의 소유권 이전</th>
</tr>
</thead>
<tbody>
<tr>
<td>소유권 증명</td>
<td>소유권 이전</td>
</tr>
<tr>
<td>투명성</td>
<td>개인정보 보호</td>
</tr>
<tr>
<td>데이터 읽기</td>
<td>데이터 쓰기</td>
</tr>
<tr>
<td>데이터 이력 사용</td>
<td>신규 데이터 생성</td>
</tr>
<tr>
<td>상태 유지</td>
<td>상태 변경</td>
</tr>
</tbody>
</table>
</div>
<p>원장은 위와 같이 두 가지 상반된 역할들을 수행하는데 블록체인도 이와 비슷하다. <em>누구나 읽을 수 있게 개방된 원장과 유사한 데이터 구조를 사지는 거대한 분산 P2P 시스템이기 때문이다.</em></p>
<h3 id="소유권-관리자로-임명된-블록체인"><a href="#소유권-관리자로-임명된-블록체인" class="headerlink" title="소유권 관리자로 임명된 블록체인"></a>소유권 관리자로 임명된 블록체인</h3><p>정부 규제 원장처럼 형식을 갖춘 목격자를 만드는 것이 자산의 소유권을 명확히 하는 핵심 요소인데, 독립적인 목겨자들이 많아서 상호 영향을 받지 않는 증언을 많이 확보하는 것이 진실을 찾기 위한 이 접근방식의 핵심이다. 이러한 방식을 원장의 소유권 명확화에 적용하면 <em>조작될 위험이 있는 원장을 하나만 유지하는 대신 원장의 순수 분산 P2P 시스템을 활용해 다수의 노드가 동의하는 진실을 이용해 소유권을 확인하면 된다.</em> 즉 하나의 중앙 통제된 원장은 훼손이나 위조의 위험이 있기 때문에 하나의 중앙 통제된 원장 대신 소유권을 기록하는 개별 원장들의 그룹을 형성한 뒤 대다수의 개별 원장이 동의하는 진실을 사용해 소유권을 관리한다.</p>
<ul>
<li>소유권 관리를 위해 사용된 개별 원장은 소유권 관련 데이터를 저장하기 위해 사용된 블록체인-데이터-구조 하나와 같다.</li>
<li>개별 원장들은 P2P 시스템의 컴퓨터(노드)에 저장된다.</li>
<li>블록체인-알고리즘은 개별 노드들이 최종 판결의 기초가 되는 하나의 일관된 소유권 상태에 집단적으로 도달하게 해준다.</li>
<li>시스템의 무결성이란 소유권에 대한 진실을 판단할 능력을 말한다.</li>
<li>식별, 인증, 승인, 데이터 보안을 믿을 수 있는 수단으로 만들기 위해 암호화 기법이 필요하다.</li>
</ul>
<hr>
<h2 id="7-이중사용-블록체인이-해결한다"><a href="#7-이중사용-블록체인이-해결한다" class="headerlink" title="7. 이중사용, 블록체인이 해결한다"></a>7. 이중사용, 블록체인이 해결한다</h2><h3 id="P2P-시스템의-취약성을-이용한-범죄-예방책"><a href="#P2P-시스템의-취약성을-이용한-범죄-예방책" class="headerlink" title="P2P 시스템의 취약성을 이용한 범죄 예방책"></a>P2P 시스템의 취약성을 이용한 범죄 예방책</h3><p><code>이중사용</code>은 이중분양 사기와 비슷한데 두 사람이 동시에 같은 집을 소유할 수 없고, 둘 중 하나만 새로운 합법적 소유자가 되어야 하는 상황을 말한다. 이 책에서는 이중사용을 <em>원장의 순수 분산 P2P 시스템에 발생할 수 있는 취약성을 의미하는 말</em>로 사용하였다. 예를 들어 P2P 시스템에서 소유권이 다른 사람에게 이전될 때 모든 원장이 소유권 이전 사실이 기록된 최신 버전으로 갱신되어야 하는데, 여기에는 시간이 좀 걸리기 때문에 어떤 피어는 최신 정보를 알고 잇고, 다른 피어는 아직 그 정보를 모르는 상태가 있을 수 있다. 그렇기 때문에 예를 들어 만약 A가 B에게 소유권을 이전한 사실을 다른 피어들이 알기 전에 악의적으로 다른 대상에게 소유권 이전을 시도하면 아직 소유권 이전에 대한 사실을 모르는 피어들은 이를 승인하게 된다. 이처럼 소유권을 중복해서 판매할 수 있는 문제점이 생긴다.</p>
<h3 id="대표적인-이중사용-문제-3가지-유형"><a href="#대표적인-이중사용-문제-3가지-유형" class="headerlink" title="대표적인 이중사용 문제 3가지 유형"></a>대표적인 이중사용 문제 3가지 유형</h3><p><strong>1. 디지털 재화를 복사해 발생하는 이중사용 문제</strong></p>
<p>컴퓨터 데이터는 별다른 제약 없이 복사할 수 있는 특성이 있어서 디지털 재화를 비롯한 소유자가 둘 이상일 수 없는 모든 데이터에 문제를 야기한다. 디지털 화폐를 복사해서 동일한 돈을 반복해서 지불에 사용하는 행위이다.</p>
<p><strong>2. 원장의 분산 P2P 시스템에서 발생하는 이중사용 문제</strong></p>
<p>모든 요소들이 소유권 이전과 같은 정보를 전달받기까지 시간이 걸리는 문제 때문에 일부 피어가 상이한 소유권 정보를 가지는 상황이 발생한다. 모든 피어가 동시에 최신 정보를 갖지 못하면 먼저 최신 정보를 습득한 누군가가 이를 악용해서 이중 사용할 우려가 있다.</p>
<p><strong>3. 순수 분산 P2P 시스템의 무결성이 침해된 이중사용 문제</strong></p>
<p>이중사용을 추상화해서 바라보면 <em>분산 P2P 시스템 내 데이터의 일관성을 유지하는 문제이며, 이는 시스템 무결성의 한 측면이기도 하다.</em> 따라서 이중사용은 시스템 무결성이 침해된 특정 사례라 할 수 있다.</p>
<h3 id="이중사용-문제를-해결하는-방법"><a href="#이중사용-문제를-해결하는-방법" class="headerlink" title="이중사용 문제를 해결하는 방법"></a>이중사용 문제를 해결하는 방법</h3><p><strong>1. 디지털 재화를 복사해 이중으로 지불하는 문제 해결</strong></p>
<p>디지털 재화를 나타내는 데이터와 소유자를 매핑하는 수단만 있으면 해결 가능.</p>
<p><strong>2. 원장의 분산 P2P 시스템에서 발생한 이중사용 해결</strong></p>
<p>응용분야는 물론 아키텍처까지 알고 있을 때 블록체인이란 용어 자체가 원장의 분산 P2P 시스템의 이중사용 문제를 없애주는 해결책.</p>
<p><strong>3. 분산 P2P 시스템의 무결성이 침해된 이중사용 해결</strong></p>
<p>시스템의 아키텍처는 특정되었지만 응용분야는 특정되지 않았을 때, 시스템의 구체적인 용도와 상관없이 분산 P2P 시스템의 무결성을 확보하고 유지하는 것에 초점이 있다. <strong>단 분산 P2P 시스템의 <code>용도</code>가 무엇인지에 따라 무결성의 내용과 의미가 결정된다.</strong> 따라서 블록체인-기술묶음이 시스템의 무결성을 확보하고 유지할 수 있는 적절한 도구인가는 <code>응용분야의 목적</code>을 알아야만 판단할 수 있다.</p>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/01/220302_blockchain01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/220302_blockchain01/" class="post-title-link" itemprop="url">블록체인 무엇인가? 1장 소프트웨어 공학에서 변하지 않는 주요 개념들</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-02T00:00:00+09:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-06 23:40:24" itemprop="dateModified" datetime="2022-12-06T23:40:24+09:00">2022-12-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>블록체인의 기본 개념을 제대로 알지 못하면 블록체인의 전반적인 가치나 잠재적인 영향력을 가늠할 수 없을뿐더러 블록체인이 창출하는 부가가치를 이해하기가 어렵다. 또한 (블록체인을 포함해서) 새로운 기술에 대한 개념적 이해가 부족하면 자극적이고 과장된 광고에 휩쓸려 비현실적이고 실현 불가능한 망상에 사로잡히기 쉬워 나중에 실망할 수도 있다. 따라서 이 책은 ‘블록체인의 기본 개념’에 집중한다.<br>&lt;책 서문 발췌&gt;</p>
</blockquote>
<h1 id="1-소프트웨어-공학에서-변하지-않는-주요-개념들"><a href="#1-소프트웨어-공학에서-변하지-않는-주요-개념들" class="headerlink" title="1. 소프트웨어 공학에서 변하지 않는 주요 개념들"></a>1. 소프트웨어 공학에서 변하지 않는 주요 개념들</h1><h2 id="1-시스템을-보는-눈-장착하기"><a href="#1-시스템을-보는-눈-장착하기" class="headerlink" title="1. 시스템을 보는 눈 장착하기"></a>1. 시스템을 보는 눈 장착하기</h2><h3 id="시스템을-계층과-측면으로-분리해-분석하기"><a href="#시스템을-계층과-측면으로-분리해-분석하기" class="headerlink" title="시스템을 계층과 측면으로 분리해 분석하기"></a>시스템을 계층과 측면으로 분리해 분석하기</h3><p>시스템을 개념적으로 분리하기 위해 사용하는 구분 기준은 다음의 두 가지다.</p>
<ul>
<li>응용계층 vs 구현계층</li>
<li>기능적 측면 vs 비기능적 측면</li>
</ul>
<h3 id="1-응용계층-vs-구현계층"><a href="#1-응용계층-vs-구현계층" class="headerlink" title="1. 응용계층 vs 구현계층"></a>1. 응용계층 vs 구현계층</h3><ul>
<li>응용계층: 사용자의 요구사항</li>
<li>구현계층: 요구사항을 실현. 구성요소는 본질적으로 기술적이다. 응용계층에서 사용자의 필요사항을 만족시키기 위한 수단.</li>
</ul>
<h3 id="2-기능적-측면-vs-비기능적-측면"><a href="#2-기능적-측면-vs-비기능적-측면" class="headerlink" title="2. 기능적 측면 vs 비기능적 측면"></a>2. 기능적 측면 vs 비기능적 측면</h3><ul>
<li>기능적 측면: 시스템이 <code>무엇</code>을 하는가? 동사적 역할. e.g. 네트워크를 통한 데이터 전송, 음악 연주 등</li>
<li>비기능적 측면: 시스템이 무엇을 <code>어떻게</code> 하는가? 부사적 역할. e.g. 멋진 인터페이스, 실행속도가 빠른 소프트웨어<ul>
<li>보안: 정확성을 포함하는 개념</li>
<li><code>무결성(integrity)</code>: 시스템이 의도한 대로 작동하는 것. 보안과 정확성 모두를 포함하는 개념</li>
</ul>
</li>
</ul>
<h3 id="사용자는-응용계층의-기능적-측면을-중시한다"><a href="#사용자는-응용계층의-기능적-측면을-중시한다" class="headerlink" title="사용자는 응용계층의 기능적 측면을 중시한다."></a>사용자는 응용계층의 기능적 측면을 중시한다.</h3><p>응용계층의 기능적 측면은 사용자의 명확한 요구사항들이므로 시스템에서 가장 중요하게 부각된다. <strong>반면 구현계층의 비기능적 요소는 시스템의 주요 요소가 아니라 아주 당연한 것으로 여겨진다. 그런데 비기능적 요소 중 무결성 같은 것은 눈에 보이지 않지만 매우 중요하다.</strong></p>
<h3 id="무결성의-주요-요소"><a href="#무결성의-주요-요소" class="headerlink" title="무결성의 주요 요소"></a>무결성의 주요 요소</h3><ul>
<li>데이터 무결성: 시스템에서 사용하고 유지 관리하는 데이터는 완전하고 정확하며 모순이 없다.</li>
<li>작동 무결성: 시스템은 의도한 대로 작동하며 논리적 오류가 없다.</li>
<li>보안: 시스템은 허가받은 사용자에게만 데이터 및 기능에 대한 접근 권한을 부여할 수 있다.</li>
</ul>
<hr>
<h2 id="2-큰-그림으로-바라보기"><a href="#2-큰-그림으로-바라보기" class="headerlink" title="2. 큰 그림으로 바라보기"></a>2. 큰 그림으로 바라보기</h2><p>노드, 컴퓨터, 피어는 동일한 의미를 가질 때가 많지만 반드시 그렇지 않다. 구조에 따라 단일 컴퓨터가 복수의 노드 역할을 할 수 있고, 하나의 노드에 복수의 컴퓨터가 연결되어 있을 수도 있다.</p>
<ul>
<li>피어:<ul>
<li>전체 시스템 노드 중 나와 직접 연결된 노드. 이더리움에서 구분해서 사용한다.</li>
<li>일대일의 의미를 강조하거나 노드를 사용해 특정 행위를 하는 사람의 관점에서 피어라 부름.</li>
</ul>
</li>
<li>노드: 보통의 책에서 전체 시스템 내의 한 요소임을 강조할 때 사용.</li>
<li>컴퓨터: 공유하는 자원 측면에 대해 기술할 때.</li>
</ul>
<h3 id="소프트웨어-아키텍처란-무엇이고-블록체인과-어떤-관계인가"><a href="#소프트웨어-아키텍처란-무엇이고-블록체인과-어떤-관계인가" class="headerlink" title="소프트웨어 아키텍처란 무엇이고 블록체인과 어떤 관계인가?"></a>소프트웨어 아키텍처란 무엇이고 블록체인과 어떤 관계인가?</h3><p>소프트웨어 시스템을 구현하는 방법은 여러가지가 있는데, <code>시스템 아키텍처</code>는 필수적으로 결정해야 한다. <em>시스템 아키텍처는 구성요소를 구조화하고, 구성요소 간 관계를 설정하는 방식을 의미한다.</em> 주로 사용되는 아키텍처는 <code>중앙 통제 방식</code>,<code>분산방식</code>이 있다.</p>
<ul>
<li>중앙 통제 방식<ul>
<li>구성요소들이 하나의 중앙요소에 연결되며, 중앙 요소를 가운데 두고 나머지 요소들이 둘러싸고 있는 구조.</li>
<li>모든 구성요소끼리 직접적으로 연결되지 않고 오직 중앙 요소와만 직접 연결되어 있다.</li>
</ul>
</li>
<li>분산 방식<ul>
<li>시스템을 통제하거나 조정하는 요소 없이 서로 연결된 네트워크 구조를 형성.</li>
<li>모든 구성 요소와 직접적으로 연결된 노드는 단 하나도 없지만 모든 노드는 간접적으로 서로 완전히 연결되어 있다.</li>
</ul>
</li>
</ul>
<h3 id="분산-시스템의-장점"><a href="#분산-시스템의-장점" class="headerlink" title="분산 시스템의 장점"></a>분산 시스템의 장점</h3><ol>
<li><p>계산 능력이 뛰어나다.</p>
<ol>
<li>서로 연결된 모든 컴퓨터의 계산 능력이 합쳐져 발현되기 때문에 단일 컴퓨터보다 더 강력한 계산 능력을 가진다.</li>
</ol>
</li>
<li><p>비용이 절감된다.</p>
<ol>
<li>여러 대의 컴퓨터로 구성되므로 초기 구성 비용은 슈퍼 컴퓨터보다 많지만 유지 운영 비용은 훨씬 적다. 또 슈퍼 컴퓨터와 달리 개별 컴퓨터가 교체 될 때 전체 시스템에 별 영향을 끼치지 않는다.</li>
</ol>
</li>
<li><p>더 안정적이다.</p>
<ol>
<li>시스템을 구성하는 개별 컴퓨터가 고장나면 나머지 구성요소들이 그 일을 대신하기 때문에 전체 네트워크는 문제없이 잘 작동한다.</li>
</ol>
</li>
<li><p>자연스럽게 확장된다.</p>
<ol>
<li>앞서 계산 능력은 연결된 모든 컴퓨터의 계산 능력을 합친 것이라 했으므로, 시스템에 컴퓨터를 추가하면 손쉽게 전체 계산 능력을 높일 수 있다.</li>
</ol>
</li>
</ol>
<h3 id="분산-시스템의-단점"><a href="#분산-시스템의-단점" class="headerlink" title="분산 시스템의 단점"></a>분산 시스템의 단점</h3><ol>
<li><p>조정 오버헤드가 발생한다.</p>
<ol>
<li>중앙 통제 방식과 달리 중앙 요소가 존재하지 않기 때문에 구성요소들 스스로 조정을 해야하는데 이 조정이 쉽지 않아 많은 자원이 소모되는 오버헤드가 발생한다.</li>
</ol>
</li>
<li><p>통신 오버헤드가 발생한다.</p>
<ol>
<li>조정을 위해서 통신이 필수적이고, 이 통신을 위해 계산 능력의 일부가 통신 프로토콜 지원 및 메시지 송수신 및 처리에 소모된다.</li>
</ol>
</li>
<li><p>네트워크 의존도가 높다.</p>
<ol>
<li>컴퓨터들은 네트워크를 통해 통신하는데, 모든 네트워크는 자체적인 결함과 장애 가능성이 내재되어 있기 때문에 통신과 조정에 영향을 끼친다. 그리고 네트워크가 없으면 각 구성요소 간의 협력이 불가하기 때문에 네트워크 의존도가 높다.</li>
</ol>
</li>
<li><p>프로그램이 복잡해진다.</p>
<ol>
<li>앞서 말한 단점들을 해결하기 위해 중앙 통제 방식에서는 필요없는 조정, 통신, 네트워크 이용에 관련된 추가적인 문제 해결 등이 필요하다.</li>
</ol>
</li>
<li><p>보안에 신경써야 한다.</p>
<ol>
<li>네트워크를 통한 통신은 계산 작업 시 데이터의 전송과 공유가 꼭 필요하다. 그러나 이런 행위로 인해 악의를 가진 개체가 정보에 접근하여 악용하는 보안문제가 발생할 수 있다.</li>
</ol>
</li>
</ol>
<h3 id="사용자가-많아질수록-더-강력해지는-분산-P2P-시스템"><a href="#사용자가-많아질수록-더-강력해지는-분산-P2P-시스템" class="headerlink" title="사용자가 많아질수록 더 강력해지는 분산 P2P 시스템"></a>사용자가 많아질수록 더 강력해지는 분산 P2P 시스템</h3><blockquote>
<p>Peer to Peer 네트워크 또는 P2P 네트워크. 분산 네트워크의 특수한 형태</p>
</blockquote>
<p>개별 컴퓨터(노드)로 구성된 시스템으로 중앙 노드의 조정 없이 네트워크의 모든 구성원이 서로에게 계산 자원을 제공한다. <strong>네트워크의 각 노드는 시스템 내에서 동등한 권리와 역할을 가지고, 모두가 자원의 공급자인 동시에 소비자이다.</strong> 사용자들의 컴퓨터를 분산 시스템을 구성하는 노드로 만든다는 아이디어를 배경으로 다양한 분야에 응용이 가능하다.</p>
<h3 id="중앙-통제와-분산-시스템의-장점만-모은-혼합-시스템"><a href="#중앙-통제와-분산-시스템의-장점만-모은-혼합-시스템" class="headerlink" title="중앙 통제와 분산 시스템의 장점만 모은 혼합 시스템"></a>중앙 통제와 분산 시스템의 장점만 모은 혼합 시스템</h3><p>중앙 통제 시스템과 분산 시스템은 정반대의 구조를 가지고 있는데, 이 각각의 강점만 결합한 혼합 시스템이 있다.</p>
<ul>
<li><p>분산 시스템 내의 중앙 통제<br>분산 시스템 내부에 중앙 통제 요소를 구축한 아키텍처로 겉보기에 분산 시스템을 이루는 것처럼 보이지만 <strong>모든 노드는 중앙의 큰 원에 직접 연결되어 있다.</strong></p>
</li>
<li><p>중앙 통제 시스템 내의 분산 시스템<br>겉보기에 주변 노드가 모드 중앙의 큰 원에 직접 연결되어 있는 중앙 통제 시스템처럼 보이는데, 중앙의 큰 원 내부를 들여다보면 분산 시스템으로 구성되어 있다. 심지어 주변 구성요소들은 중앙 요소가 분산 시스템으로 이루어져 있는지 모를 수도 있다.</p>
</li>
</ul>
<h3 id="분산-시스템인지-구분하는-방법"><a href="#분산-시스템인지-구분하는-방법" class="headerlink" title="분산 시스템인지 구분하는 방법"></a>분산 시스템인지 구분하는 방법</h3><p>전체 시스템을 동시에 종료할 수 있는 단일 구성요소가 있는지 찾는다. 이런 요소가 있다면 분산 시스템이 아니다.</p>
<h3 id="큰-그림으로-본-블록체인의-목적"><a href="#큰-그림으로-본-블록체인의-목적" class="headerlink" title="큰 그림으로 본 블록체인의 목적"></a>큰 그림으로 본 블록체인의 목적</h3><p>소프트웨어 시스템 디자인에서 아키텍처의 선정은 시스템 구현 관점에서 목적 달성을 위한 수단이기 때문에 분산 방식 또는 중앙 통제 방식 중 어떤 것으로도 구현할 수 있다. 다만 어떤 아키텍처를 선택하느냐에 따라 시스템이 기능적, 비기능적 측면을 달성하는 방법에 영향을 미친다. <strong>특히 무결성에 대해서 두 가지 아키텍처가 매우 다른 방식으로 접근하기 때문에 이런 점에서 블록 체인이 중요하다.</strong> <code>블록체인은 분산 시스템이 무결성을 확보하게 해주는 도구이며, 분산 시스템의 무결성을 구현하고 유지하는 것이 바로 블록체인의 목적이다.</code>즉 구현계층의 비기능적 측면을 성취하게 해주는 도구이다.</p>
<hr>
<h2 id="3-P2P-시스템의-엄청난-잠재력"><a href="#3-P2P-시스템의-엄청난-잠재력" class="headerlink" title="3. P2P 시스템의 엄청난 잠재력"></a>3. P2P 시스템의 엄청난 잠재력</h2><h3 id="P2P-시스템이-세상을-어떻게-바꿀-것인가"><a href="#P2P-시스템이-세상을-어떻게-바꿀-것인가" class="headerlink" title="P2P 시스템이 세상을 어떻게 바꿀 것인가?"></a>P2P 시스템이 세상을 어떻게 바꿀 것인가?</h3><p>P2P 시스템이 음악산업을 어떻게 변화시켰는지를 보면서 블록체인과 어떤 관계가 있는지 살펴본다. 전통적인 음악산업은 음악가와 스튜디오가 계약을 맺고, 스튜디오가 음악가의 노래를 녹음해서 다양한 유통채널을 통해 판매하는 구조로 운영되어 왔다. 스튜디오가 사실상 음악가와 음악을 청취하고자 하는 사람들 사이의 <code>중개자</code>역할을 한 것이다. 중개자로서 스튜디오는 음반제작 전반에 관한 독점적 지식을 가지고 있었는데 2000년대 이후 음악의 디지털화, 개인 PC 보급 확대, 인터넷의 등장 등이 스튜디오를 더이상 필요하지 않게 만들었다. 즉 스튜디오가 가지고 있던 독점적인 지식인 제작, 마케팅, 판매를 스튜디오를 거치지 않고도 가능하게 된 것이다. 특히 냅스터라는 소프트웨어의 등장은 P2P 접근방식으로 MP3 파일을 공유하는 방식으로 음악을 소비하게 해주었기 때문에 스튜디오의 효용성이 더욱 떨어지게 되었다. 냅스터의 사례처럼 <strong>중개자 역할을 개인간의 상호작용으로 대체한다.</strong>는 아이디어를 기반으로 P2P 시스템이 음악 산업이 생태계 전쳬를 뒤흔든 것이다.</p>
<p>그런데 이런 P2P 시스템은 앞으로도 무형의 상품이나 디지털화된 상품 또는 서비스를 중개하는 역할을 주업으로 하는 산업에 큰 영향을 미치게 될 것이고, 결국은 이런 산업의 생태계도 P2P로 대체될 가능성이 높다. 금융업이 대표적인 예라고 할 수 있다. 대부분의 돈과 자산은 물리적인 지폐나 동전으로 거래되기 보다는 금융회사의 중앙 정보 기술 시스템에 저장되어 있고, 은행은 소비하는 사람들과 회사 사이의 중개자 역할을 주로 수행한다. 다만 간단한 거래 하나에도 상당수 많은 중개자가 관여하고 있어서 오랜 처리 시간과 많은 거래 비용을 필요로 하는 상황이다. 만약 P2P 거래 시스템을 사용한다면 훨씬 적은 시간과 비용을 들여 거래를 진행할 수 있다. 현재 은행의 중앙 통제 시스템에 비해 P2P 시스템은 중개자를 통해 간접적으로 상호작용하지 않고 거래 당사자끼리 직접 상호작용하기 때문에 처리 시간과 비용이 줄어든다.</p>
<h3 id="P2P-시스템과-블록체인은-어떤-관련이-있나"><a href="#P2P-시스템과-블록체인은-어떤-관련이-있나" class="headerlink" title="P2P 시스템과 블록체인은 어떤 관련이 있나?"></a>P2P 시스템과 블록체인은 어떤 관련이 있나?</h3><ol>
<li>P2P 시스템의 정의</li>
</ol>
<blockquote>
<p>여러 노드(개별 컴퓨터)들로 구성된 분산 소프트웨어 시스템. <code>한 노드의 자원을 다른 노드들이 직접 사용</code>할 수 있다는 특징이 있다.</p>
</blockquote>
<p>P2P 시스템에 참여하면 사용자의 컴퓨터는 시스템의 노드로 전환되고, 모든 노드에게는 동등한 권리와 역할이 주어진다. <strong>즉 시스템의 모든 노드는 동일한 기능과 책임을 가지고, 모든 사용자의 컴퓨터는 자원의 공급자인 동시에 소비자가 된다.</strong></p>
<ol>
<li>P2P 시스템의 아키텍처</li>
</ol>
<blockquote>
<p>P2P 시스템의 구조는 <code>분산 컴퓨터 시스템</code></p>
</blockquote>
<p>개별 노드로 구성된 컴퓨터들은 서로 자원을 공유한다. 순수 분산 P2P 시스템은 중앙에서 통제하거나 조정하는 어떤 요소도 없다. 따라서 모든 노드는 동일한 과제를 수행하고, 자원과 서비스의 생산자인 동시에 소비자 역할을 한다. 물론 중앙 통제 요소를 가지는 P2P 시스템도 존재한다. 이 시스템은 중앙 통제와 분산 시스템이 장점만을 뽑아 만들어진 것으로 중앙 노드를 이용해 노드 간 상호작용을 중개하고, 피어 노드가 제공하는 서비스 목록들을 유지 관리하고 노드를 검색하고 식별한다.</p>
<ol>
<li>P2P 시스템과 블록체인의 연관성</li>
</ol>
<blockquote>
<p>블록체인은 분산 시스템에서 무결성을 확보하고 유지하는 도구이다. <code>즉 순수 분산 P2P 시스템은 무결성의 확보와 유지를 위해 블록체인을 사용한다.</code></p>
</blockquote>
<p>이러한 P2P 시스템과 블록체인의 연관성 때문에 블록체인이 중요한 요소가 된 것이고, 무결성을 유지하고 확보하기 위한 도구라는 점보다 더욱 중요한 점은 <code>탈중개화</code>이다. 블록체인은 단지 <code>탈중개화</code>를 위한 도구일 뿐이다.</p>
<hr>
<p><em>References</em><br>[블록체인 무엇인가?] 다니엘 드레셔 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/03/01/220302_item56to62/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/220302_item56to62/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 56 - 아이템 62</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-02T00:00:00+09:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-06 23:40:24" itemprop="dateModified" datetime="2022-12-06T23:40:24+09:00">2022-12-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-56-정보를-감추는-목적으로-private-사용하지-않기"><a href="#아이템-56-정보를-감추는-목적으로-private-사용하지-않기" class="headerlink" title="아이템 56 정보를 감추는 목적으로 private 사용하지 않기"></a>아이템 56 정보를 감추는 목적으로 private 사용하지 않기</h2><p>자바스크립트는 클래스에 비공개 속성을 만들 수 없다. 비공개 속성임을 나태내기 위해 <code>언더스코어(_)</code>를 접두사로 붙이던 것이 관례로 인정되어 왔던 것 뿐이다. <em>하지만 언더스코어를 붙이는 것은 비공개라고 표시한 것 뿐, 일반적인 속성과 동일하게 클래스 외부로 공개되어 있다.</em></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Diary &#123;</span><br><span class="line">  <span class="keyword">private</span> secret = <span class="string">'cheated on my English test'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> diary = <span class="keyword">new</span> Diary()</span><br><span class="line">;(diary <span class="keyword">as</span> <span class="built_in">any</span>).secret <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>타입스크립트에서 위의 예시처럼 public, protected, private 접근 제어자를 사용하기 때문에 규칙을 강제하는 것으로 오해하기 쉬운데 <strong>이는 타입스크립트 키워드이기 때문에 컴파일 후에 제거된다.</strong> 그래서 타입스크립트의 컴파일되면 위의 예제는 아래의 예제처럼 자바스크립트 코드(target=ES2017)로 변환된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Diary &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.secret = <span class="string">'cheated on my English test'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> diary = <span class="keyword">new</span> Diary()</span><br><span class="line">diary.secret</span><br></pre></td></tr></table></figure>
<p>컴파일 후에 확인해보면 타입스크립트 키워드인 private이 제거되었고, secret은 일반적인 속성이어서 접근할 수 있다. 즉 언더스코어의 관례처럼 타입스크립트의 접근 제어자들도 런타임에는 아무런 효력이 없다. 심지어 타입스크립트 상태에서도 단언문을 사용하면 private에 접근 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">text: string</span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">PasswordChecker</span> </span>&#123;</span><br><span class="line">  checkPassword: <span class="function">(<span class="params">password: string</span>) =&gt;</span> boolean</span><br><span class="line">  <span class="keyword">constructor</span>(passwordHash: number) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkPassword = <span class="function">(<span class="params">password: string</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> hash(password) === passwordHash</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checker = <span class="keyword">new</span> PasswordChecker(hash(<span class="string">'s3cret'</span>))</span><br><span class="line">checker.checkPassword(<span class="string">'s3cret'</span>) <span class="comment">// Returns true</span></span><br></pre></td></tr></table></figure>
<p>따라서 정보를 감추기 위한 목적으로 private을 사용하면 안된다. <em>자바스크립트에서 정보를 숨기기 위한 가장 효과적은 방법은 클로저이다.</em> 위의 예시는 생성자에서 클로저를 만드는 예시이다. 이렇게 작성하면 PasswordChecker의 생성자 외부에서 passwordHash 변수에 접근할 수 없어서 정보를 숨기는 목적은 달성하게 되는데, 주의사항이 있다. passwordHash를 생성자 외부에서 접근할 수 없기 때문에 passwordHash에 접근해야 하는 메서드는 생성자 내부에 정의되어야 한다. 또 메서드 정의가 생성자 내부에 존재하게 되면, 인스턴스를 생성할 때마다 각 메서드의 복사본이 생성되기 때문에 메모리를 낭비하게 된다. 클로저를 쓰지 않으면 현재 표준화가 진행 중인 비공개 필드 기능을 사용할 수 있는데, 접두사 #을 붙여서 타입 체크과 런타임 모두에서 비공개로 만드는 역할을 한다.</p>
<hr>
<h2 id="아이템-57-소스맵을-사용하여-타입스크립트-디버깅하기"><a href="#아이템-57-소스맵을-사용하여-타입스크립트-디버깅하기" class="headerlink" title="아이템 57 소스맵을 사용하여 타입스크립트 디버깅하기"></a>아이템 57 소스맵을 사용하여 타입스크립트 디버깅하기</h2><p>타입스크립트 코드를 실행한다는 것은 타입스크립트 컴파일러가 생성한 자바스크립트 코드를 생성한다는 것이다. 그런데 변환된 자바스크립트 코드는 복잡해서 디버깅하기가 어렵다. <strong>디버깅하기 쉽도록 해결책을 내놓은 것이 소스맵이다.</strong> 소스맵은 변환된 코드의 위치와 심벌들을 원본 코드의 원래 위치와 심벌들로 매핑한다. 보통 자바스크립트로 변환된 코드는 원본 코드와 거의 비슷해서 디버깅하기 쉽지만 복잡하게 변환된다면 소스맵이 필요하다. 타입스크립트가 소스맵을 생성할 수 있도록 tsconfig.json에 소스맵 옵션을 다음과 같이 설정한다.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compiletOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"sourceMap"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-58-모던-자바스크립트로-작성하기"><a href="#아이템-58-모던-자바스크립트로-작성하기" class="headerlink" title="아이템 58 모던 자바스크립트로 작성하기"></a>아이템 58 모던 자바스크립트로 작성하기</h2><p>타입스크립트 코드를 특정 버전의 자바스크립트로 컴파일 할 수 있다. 즉 타입스크립트를 자바스크립트 트랜스 파일러로 사용할 수 있다. 옛날 버전의 자바스크립트 코드를 타입스크립트 컴파일러에서 동작하게 만들면 그 이후 회신 버전의 자바스크립트 기능을 코드에 추가해도 문제가 없다. 이렇게 옛날 버전의 자바스크립트 코드를 최신 버전의 자바스크립트로 바꾸는 작업이 타입스크립트로 전환하는 작업의 일부라 볼 수 있다. <em>타입스크립트는 자바스크립트의 상위 집합이기 때문에 코드를 최신 버전으로 바꾸다 보면 타입스크립트의 일부를 저절로 익힐 수 있다.</em> 타입스크립트 도입 시 가장 중요하나 기능은 ECMAScript 모듈과 ES2015 클래스이다.</p>
<h3 id="ECMA-모듈-사용하기"><a href="#ECMA-모듈-사용하기" class="headerlink" title="ECMA 모듈 사용하기"></a>ECMA 모듈 사용하기</h3><p>ES2015부터 import, export를 사용하는 ECMAScript 모듈이 표준이 되었다. 따라서 자바스크립트 코드가 단일 파일이거나 비표준 모듈 시스템을 사용 중이라면 ES 모듈로 전환해야 한다. 이 과정에서 웹팩이나 ts-node와 같은 도구가 필요할 수도 있다. ES 모듈 시스템은 모듈 단위로 전환할 수 있게 해주기 때문에 점진적 마이그레이션이 원활해진다.</p>
<h3 id="프로토타입-대신-클래스-사용하기"><a href="#프로토타입-대신-클래스-사용하기" class="headerlink" title="프로토타입 대신 클래스 사용하기"></a>프로토타입 대신 클래스 사용하기</h3><p>자바스크립트에서 프로토타입 기반의 객체 모델을 사용하는데, 많은 개발자들이 클래스 기반 모델을 선호했기 때문에 ES2015에서 class 키워드를 사용하는 클래스 기반 모델이 도입되었다. <em>만약 단순한 객체를 다룰 때 프로토타입을 사용하고 있었다면 클래스로 바꾸는 것이 좋다.</em></p>
<h3 id="var-대신-let-const-사용하기"><a href="#var-대신-let-const-사용하기" class="headerlink" title="var 대신 let/const 사용하기"></a>var 대신 let/const 사용하기</h3><p>var 키워드에는 스코프 규칙의 문제가 있었고, let이나 const를 쓰는 것으로 이러한 문제를 피할 수 있었다. var로 되어있던 코드를 let이나 const로 수정하면 일부 코드에서 타입스크립트가 오류를 표시할 수 있다. 만약 오류가 발생했다면 잠재적으로 스코프 문제가 존재하는 코드이니 수정이 필요하다.</p>
<h3 id="for-대신-for-of-또는-배열-메서드-사용하기"><a href="#for-대신-for-of-또는-배열-메서드-사용하기" class="headerlink" title="for(;;) 대신 for-of 또는 배열 메서드 사용하기"></a>for(;;) 대신 for-of 또는 배열 메서드 사용하기</h3><p>과거에는 자바스크립트가 배열을 순회할 때 for 루프를 사용했는데 모던 자바스크립트에는 <code>for~of</code>가 존재하기 때문에 이를 사용하면 된다. for~of가 for문에 비해 코드가 짧고 인덱스 변수를 사용하지 않기 때문에 실수를 줄일 수 있다. 만약 인덱스 변수가 필요하다면 forEach를 사용하면 되고, 비슷한 루프문으로 for~in도 있지만 몇 가지 문제점이 있으므로 쓰지 않는 것이 좋다.</p>
<h3 id="함수-표현식보다-화살표-함수-사용하기"><a href="#함수-표현식보다-화살표-함수-사용하기" class="headerlink" title="함수 표현식보다 화살표 함수 사용하기"></a>함수 표현식보다 화살표 함수 사용하기</h3><p>this 키워드는 일반 변수들과 다른 스코프 규칙을 가지기 때문에 가장 어려운 개념 중 하나이다. 그러나 화살표 함수를 사용하면 상위 스코프의 this를 유지할 수 있다. 컴파일러 옵션에 noImplicitThis(또는 strict)를 설정하면 타입스크립트가 this 바인딩 관련된 오류를 표시해준다.</p>
<h3 id="단축-객체-표현과-구조-분해-할당-사용하기"><a href="#단축-객체-표현과-구조-분해-할당-사용하기" class="headerlink" title="단축 객체 표현과 구조 분해 할당 사용하기"></a>단축 객체 표현과 구조 분해 할당 사용하기</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>,</span><br><span class="line">  y = <span class="number">2</span>,</span><br><span class="line">  z = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123;</span><br><span class="line">  x: x,</span><br><span class="line">  y: y,</span><br><span class="line">  z: z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같은 코드는 아래와 같이 구조 분해 할당을 이용하여 더 간단하게 표현할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>,</span><br><span class="line">  y = <span class="number">2</span>,</span><br><span class="line">  z = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123; x, y, z &#125;</span><br></pre></td></tr></table></figure>
<h3 id="함수-매개변수-기본값-사용하기"><a href="#함수-매개변수-기본값-사용하기" class="headerlink" title="함수 매개변수 기본값 사용하기"></a>함수 매개변수 기본값 사용하기</h3><p>자바스크립트의 함수의 모든 매개변수는 선택적(생략 가능)이며, 매개변수를 지정하지 않았을 때는 undefined로 간주된다. 매개변수에 기본값을 직접 지정할 수도 있는데 이렇게 하면 코드가 간결해진다.</p>
<h3 id="저수준-프로미스나-콜백-대신-async-await-사용하기"><a href="#저수준-프로미스나-콜백-대신-async-await-사용하기" class="headerlink" title="저수준 프로미스나 콜백 대신 async/await 사용하기"></a>저수준 프로미스나 콜백 대신 async/await 사용하기</h3><p>async/await가 코드의 가독성을 높이는 것 뿐 아니라 비동기 코드에 타입 정보가 전달되어 타입 추론을 가능하게 한다.</p>
<h3 id="연관-배열에-객체-대신-Map과-Set-사용하기"><a href="#연관-배열에-객체-대신-Map과-Set-사용하기" class="headerlink" title="연관 배열에 객체 대신 Map과 Set 사용하기"></a>연관 배열에 객체 대신 Map과 Set 사용하기</h3><h3 id="타입스크립트에-use-strict-넣지-않기"><a href="#타입스크립트에-use-strict-넣지-않기" class="headerlink" title="타입스크립트에 use strict 넣지 않기"></a>타입스크립트에 use strict 넣지 않기</h3><p>버그가 될 수 있는 코드 패턴에 오류를 표시해 주는 엄격 모드가 ES5에서 도입되었는데 타입스크립트에서 수행되는 안정성 검사가 엄격 모드보다 훨싼 더 엄격한 체크를 수행한다.</p>
<hr>
<h2 id="아이템-59-타입스크립트-도입-전에-ts-check와-JSDoc으로-시험해-보기"><a href="#아이템-59-타입스크립트-도입-전에-ts-check와-JSDoc으로-시험해-보기" class="headerlink" title="아이템 59 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기"></a>아이템 59 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기</h2><p>@ts-check 지시자를 써서 타입 체커가 파일을 분석하고, 발견된 오류를 보고하도록 지시할 수 있다. 단 매우 느슨한 수준으로 타입 체크를 수행하고, noImplicitAny를 해제한 것보다 헐거운 체크를 수행한다. <em>JSDoc의 @types 구문을 사용해서 타입 단언을 대체할 수 있는데 이때 중요한 것은 타입을 감싸는 중괄호가 필요하다는 것이다.</em> 이처럼 자바스크립트 환경에서도 @ts-check 지시자와 JSDoc 주석으로 타입스크립트와 비슷한 경험의 작업이 가능하다.</p>
<h2 id="아이템-60-allowJs로-타입스크립트와-자바스크립트-같이-사용하기"><a href="#아이템-60-allowJs로-타입스크립트와-자바스크립트-같이-사용하기" class="headerlink" title="아이템 60 allowJs로 타입스크립트와 자바스크립트 같이 사용하기"></a>아이템 60 allowJs로 타입스크립트와 자바스크립트 같이 사용하기</h2><p>마이그레이션 기간 중에 자바스크립트와 타입스크립트가 동시에 동작할 수 있도록 해야 한다. 이 두 가지가 공존할 수 있도록 하는 핵심은 <code>allowJs</code>컴파일러 옵션이다. 타입스크립트 파일과 자바스크립트 파일을 서로 임포트할 수 있게 해준다. 타입 체크와 관련이 없지만 기존 빌드 과정에 타입스크립트 컴파일러를 추가하기 위해서도 allowJs 옵션이 필요하고, 모듈 단위로 타입스크립트로 전환하는 과정에서 테스트를 수행해야 하기 때문에도 이 옵션이 필요하다.</p>
<hr>
<h2 id="아이템-61-의존성-관계에-따라-모듈-단위로-전환하기"><a href="#아이템-61-의존성-관계에-따라-모듈-단위로-전환하기" class="headerlink" title="아이템 61 의존성 관계에 따라 모듈 단위로 전환하기"></a>아이템 61 의존성 관계에 따라 모듈 단위로 전환하기</h2><p>점진적 마이그레이션에서는 모듈 단위로 각개격파하는 것이 이상적인데, 한 모듈을 골라서 타입 정보를 추가하면 <em>해당 모듈이 의존하는 모듈에서 비롯되는 타입 오류</em>가 발생하게 된다. 따라서 다른 모듈에 의존하지 않는 최하단 모듈부터 시작하여 의존성의 최상단에 있는 모듈을 마지막으로 완성해야 한다.</p>
<ul>
<li>서드파티 라이브러리 타입 정보를 가장 먼저 해결한다.</li>
</ul>
<p>프로젝트 내에 존재하는 모듈은 서드파티 라이브러리에 의존하지만 서드파티 라이브러리는 해당 모듈에 의존하지 않기 때문에 가장 먼저 타입 정보를 해결해야 한다. <code>@types</code>모듈을 설치하면 된다. (e.g. @types/lodash)</p>
<ul>
<li>외부 API의 타입 정보 추가</li>
</ul>
<p>프로젝트 내의 모듈은 API에 의존하지만 API는 해당 모듈에 의존하지 않기 때문에 먼저 해결한다. 단 특별한 문맥이 없어서 타입스크립트가 추론하기 어렵기 때문에 <strong>API에 대한 사양을 기반으로 타입 정보를 생성하도록 한다.</strong></p>
<ul>
<li><p>의존성 관계도에서 가장 의존성이 낮은 모듈부터 타입 정보 추가<br>대부분의 프로젝트 최하단에 유틸리티 종류의 모듈이 위치하는 패턴이 있다. <strong>이때 중요한 것은 타입정보를 추가한 것이지 리팩토링을 하려 해서는 안된다.</strong></p>
</li>
<li><p>선언되지 않은 클래스 멤버</p>
</li>
</ul>
<p>자바스크립트에서 클래스 멤버 변수를 선언할 필요가 없지만 타입스크립트에서는 명시적으로 선언해야 한다.</p>
<ul>
<li>타입이 바뀌는 값</li>
</ul>
<p>자바스크립트일 때 문제가 없다가 타입스크립트가 되는 순간 오류가 발생하는 값들이 많은데, 한꺼번에 객체를 생성하여 간단히 오류를 해결할 수 있다. 한꺼번에 생성이 어렵다면 타입 단언문을 사용할 수 있다. <em>단, 당장 마이그레이션이 최우선이라 임시 방편으로 사용한 것이지 마이그레이션이 완료된 후에는 적절한 방법으로 타입을 선언해야 한다.</em> 또한 자바스크립트에서 JSDoc와 @ts-check를 사용해서 타입 정보를 추가했다면 타입스크립트로 전환하는 순간 타입 정보가 무효화 된다는 것에 유의하도록 한다.</p>
<ul>
<li>테스트 코드를 타입스크립트로 전환<br>로직 코드가 테스트 코드에 의존하지 않기 때문에, 테스트 코드는 항상 의존성 관계도의 최상단에 위치한다. 따라서 최하단의 모듈부터 마이그레이션 하는 중에도 테스트는 정상적으로 수행할 수 있다.</li>
</ul>
<hr>
<h2 id="아이템-62-마이그레이션의-완성을-위해-noImplicitAny-설정하기"><a href="#아이템-62-마이그레이션의-완성을-위해-noImplicitAny-설정하기" class="headerlink" title="아이템 62 마이그레이션의 완성을 위해 noImplicitAny 설정하기"></a>아이템 62 마이그레이션의 완성을 위해 noImplicitAny 설정하기</h2><p>만약 noImplicitAny를 설정하지 않았다면 타입 선언에서 비롯되는 실제 오류를 완벽하게 잡을 수 없으므로 마이그레이션이 완료되었다고 말하기 어렵다. 아래와 같은 코드는 <code>noImplicitAny:true</code>를 설정한 순간 에러가 발생하게 된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsConfig: &#123;"noImplicitAny":true,"strictNullChecks":false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HIDE</span></span><br><span class="line"><span class="keyword">class</span> Chart &#123;</span><br><span class="line">  indices: <span class="built_in">number</span>[]</span><br><span class="line">  <span class="comment">// END</span></span><br><span class="line">  getRanges() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> r of <span class="keyword">this</span>.indices) &#123;</span><br><span class="line">      <span class="keyword">const</span> low = r[<span class="number">0</span>]</span><br><span class="line">      <span class="comment">// ~~~~ Element implicitly has an 'any' type because</span></span><br><span class="line">      <span class="comment">//      type 'Number' has no index signature</span></span><br><span class="line">      <span class="keyword">const</span> high = r[<span class="number">1</span>]</span><br><span class="line">      <span class="comment">// ~~~~ Element implicitly has an 'any' type because</span></span><br><span class="line">      <span class="comment">//      type 'Number' has no index signature</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// HIDE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// END</span></span><br></pre></td></tr></table></figure>
<p>noImplicitAny를 설정할 때는 로컬에만 설정하고 작업을 하여 점진적 마이그레이션이 가능하도록 한다.</p>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Heejin Lee</p>
  <div class="site-description" itemprop="description">Today I Learned</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">133</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heejin Lee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
