<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heejinlee07.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Today I Learned">
<meta property="og:type" content="website">
<meta property="og:title" content="Heejin">
<meta property="og:url" content="https://heejinlee07.github.io/page/2/index.html">
<meta property="og:site_name" content="Heejin">
<meta property="og:description" content="Today I Learned">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Heejin Lee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://heejinlee07.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Heejin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heejin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Front-end Developer</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/09/220210_item21to27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/09/220210_item21to27/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 21 - 아이템 27</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-10 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-10T00:00:00+09:00">2022-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-21 23:10:05" itemprop="dateModified" datetime="2022-03-21T23:10:05+09:00">2022-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-21-타입-넓히기"><a href="#아이템-21-타입-넓히기" class="headerlink" title="아이템 21 타입 넓히기"></a>아이템 21 타입 넓히기</h2><p>런타임에 모든 변수는 유일한 <code>값</code>을 가지고, 타입스크립트가 코드를 체크하는 정적 분석 시점에 변수는 가능한 값들의 집합인 <code>타입</code>을 가진다. 그래서 상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커가 타입을 결정해야 한다. <em>즉 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다.</em>는 뜻이다. 그리고 이를 <code>넓히기(widening)</code>라고 부른다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixed = [<span class="string">'x'</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//추론 가능한 타입</span></span><br><span class="line">(<span class="string">'x'</span> | <span class="number">1</span>)[]</span><br><span class="line">[<span class="string">'x'</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line">(<span class="built_in">string</span>|<span class="built_in">number</span>)[]</span><br><span class="line"></span><br><span class="line"><span class="comment">//생략</span></span><br></pre></td></tr></table></figure>
<p>위 예제에서 mixed는 추론 가능한 타입이 여러개이다. 만약 mixed에 대한 타입이 충분하지 않다면 어떤 타입으로 추론되어야 하는지 할 수 없어서 타입스크립트는 작성자의 의도를 추측한다.</p>
<h3 id="넓히기-과정을-제어하는-방법"><a href="#넓히기-과정을-제어하는-방법" class="headerlink" title="넓히기 과정을 제어하는 방법"></a>넓히기 과정을 제어하는 방법</h3><ul>
<li>const의 사용 : let 대신 const로 변수를 선언한다. const는 재할당이 불가하기 때문에 타입스크립트가 추론 가능한 타입이 여러개여서 모호한 과정에 빠지지 않는다. 다만 객체와 배열의 경우 const를 써도 문제가 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v = &#123;</span><br><span class="line">  x: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">v.x = <span class="number">3</span> <span class="comment">// OK</span></span><br><span class="line">v.x = <span class="string">'3'</span></span><br><span class="line"><span class="comment">// ~ Type '"3"' is not assignable to type 'number'</span></span><br><span class="line">v.y = <span class="number">4</span></span><br><span class="line"><span class="comment">// ~ Property 'y' does not exist on type '&#123; x: number; &#125;'</span></span><br><span class="line">v.name = <span class="string">'Pythagoras'</span></span><br><span class="line"><span class="comment">// ~~~~ Property 'name' does not exist on type '&#123; x: number; &#125;'</span></span><br></pre></td></tr></table></figure>
<p><strong>타입스크립트는 명확성과 유연성 사이의 균형을 유지하려고 한다.</strong> 그래서 구체적으로 타입을 추론해야 하지만, 잘못된 추론을 할 정도로 구체적으로 수행하진 않는다. 만약 타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의한다.</p>
<h3 id="타입스크립트의-기본-동작-제어방법"><a href="#타입스크립트의-기본-동작-제어방법" class="headerlink" title="타입스크립트의 기본 동작 제어방법"></a>타입스크립트의 기본 동작 제어방법</h3><ul>
<li>명시적 타입 구문 제공</li>
<li>타입 체커에 추가적인 문맥 제공</li>
<li>const 단언만 사용<ul>
<li>이 const는 변수 선언에 쓰이는 const와 가른 것이므로 헷갈려서는 안된다. <em>const 단언문은 온전히 타입 공간의 기법이다.</em></li>
<li>아래 예제에서 값 뒤에 <code>as const</code>를 작성하면 최대한 좁은 타입으로 추론하기 때문에 v3에서 넓히기가 동작하지 않는다.</li>
<li>배열을 튜플로 추론할 때도 <code>as const</code>를 쓸 수 있다.</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Vector3 &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">  z: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params">vector: Vector3, axis: 'x' | 'y' | 'z'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> vector[axis]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span></span><br><span class="line">&#125; <span class="comment">// Type is &#123; x: number; y: number; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">  x: <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">const</span>,</span><br><span class="line">  y: <span class="number">2</span></span><br><span class="line">&#125; <span class="comment">// Type is &#123; x: 1; y: number; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v3 = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span> <span class="comment">// Type is &#123; readonly x: 1; readonly y: 2; &#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-22-타입-좁히기"><a href="#아이템-22-타입-좁히기" class="headerlink" title="아이템 22 타입 좁히기"></a>아이템 22 타입 좁히기</h2><p><code>타입 넓히기의 반대개념이다.</code> 타입스크립트가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말한다.</p>
<ul>
<li>null 체크</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>) <span class="comment">// Type is HTMLElement | null</span></span><br><span class="line"><span class="keyword">if</span> (el) &#123;</span><br><span class="line">  el <span class="comment">// Type is HTMLElement</span></span><br><span class="line">  el.innerHTML = <span class="string">'Party Time'</span>.blink()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  el <span class="comment">// Type is null</span></span><br><span class="line">  alert(<span class="string">'No element #foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>) <span class="comment">// Type is HTMLElement | null</span></span><br><span class="line"><span class="keyword">if</span> (!el) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unable to find #foo'</span>)</span><br><span class="line">el <span class="comment">// Now type is HTMLElement</span></span><br><span class="line">el.innerHTML = <span class="string">'Party Time'</span>.blink()</span><br></pre></td></tr></table></figure>
<p>위 예시에서 1️⃣의 el이 null이면 첫번 째 블록의 <em>const el = document.getElementById(‘foo’); // Type is HTMLElement | null</em> 을 실행하지 않기 때문에 <em>Type is HTMLElement | null</em>에서 null을 제외하므로 더 좁은 타입이 된다. 2️⃣와 같이 분기문에서 예외를 던지거나 함수를 반환해서 블록의 나머지 부분에서 변수의 타입을 좁힐 수도 있다.</p>
<ul>
<li>instanceof사용</li>
<li>속성 체크</li>
<li>Array.isArray 사용</li>
<li>조건문 사용</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>) <span class="comment">// type is HTMLElement | null</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> el === <span class="string">'object'</span>) &#123;</span><br><span class="line">  el <span class="comment">// Type is HTMLElement | null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>조건문이 가장 타입을 좁히는 데 능숙한 방법이지만 위와 같은 예제처럼 실수를 일으키기 쉽다. 위 예제에서 <code>typeof null은 object</code>이기 때문에 if문에서 null이 제외되지 않는다. 다음과 같은 기본형에서도 기본형 값이 잘못되어도 제대로 좁혀지지 않는다. 빈 문자열 ‘’와 0 모두 false가 되기 때문에 좁혀지지 않는다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x?: <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">    x <span class="comment">// Type is string | number | null | undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>명시적 태그를 붙이기 (태그된 유니온 또는 구별된 유니온</li>
<li>사용자 정의 타입 가드 사용: 타입스크립트가 타입을 식별하지 못할 때 커스텀 함수를 도입할 수 있다.</li>
<li>타입 가드 사용</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jackson5 = [<span class="string">'Jackie'</span>, <span class="string">'Tito'</span>, <span class="string">'Jermaine'</span>, <span class="string">'Marlon'</span>, <span class="string">'Michael'</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDefined</span>&lt;<span class="title">T</span>&gt;(<span class="params">x: T | <span class="literal">undefined</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> members = [<span class="string">'Janet'</span>, <span class="string">'Michael'</span>]</span><br><span class="line">  .map(<span class="function"><span class="params">who</span> =&gt;</span> jackson5.find(<span class="function"><span class="params">n</span> =&gt;</span> n === who))</span><br><span class="line">  .filter(isDefined) <span class="comment">// Type is string[]</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-23-한꺼번에-객체-생성하기"><a href="#아이템-23-한꺼번에-객체-생성하기" class="headerlink" title="아이템 23 한꺼번에 객체 생성하기"></a>아이템 23 한꺼번에 객체 생성하기</h2><blockquote>
<p>타입스크립트의 타입은 변경되지 않기 때문에 객체를 생성할 때는 속성을 하나씩 추가하는 것 보다 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//에러 발생</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123;&#125;</span><br><span class="line">pt.x = <span class="number">3</span></span><br><span class="line"><span class="comment">// ~ Property 'x' does not exist on type '&#123;&#125;'</span></span><br><span class="line">pt.y = <span class="number">4</span></span><br><span class="line"><span class="comment">// ~ Property 'y' does not exist on type '&#123;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//에러 발생</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pt: Point = &#123;&#125;</span><br><span class="line"><span class="comment">// ~~ Type '&#123;&#125;' is missing the following properties from type 'Point': x, y</span></span><br><span class="line">pt.x = <span class="number">3</span></span><br><span class="line">pt.y = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//통과 - 객체 한꺼번에 생성</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pt = &#123;</span><br><span class="line">  x: <span class="number">3</span>,</span><br><span class="line">  y: <span class="number">4</span></span><br><span class="line">&#125; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>객체를 반드시 제각각 나눠서 만들어야 한다면 <code>타입 단언문(as)</code>를 사용한다. 그러나 객체를 한꺼번에 만드는 것이 더욱 권장된다. 작은 객체들을 조합해서 큰 객체를 만들어야 할 때는 <code>전개 연산자</code>를 사용해서 객체를 한꺼번에 만든다. 이렇게 하면 타입 걱정 없이 필드 단위로 객체를 생성할 수 있는데 이때 중요한 점은 <strong>모든 업데이트마다 새 변수를 사용하여 새로운 타입을 얻도록 하는 것이다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//전개 연산자 사용</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pt = &#123; x: <span class="number">3</span>, y: <span class="number">4</span> &#125;</span><br><span class="line"><span class="keyword">const</span> id = &#123; name: <span class="string">'Pythagoras'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> namedPoint = &#123; ...pt, ...id &#125;</span><br><span class="line">namedPoint.name <span class="comment">// OK, type is string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//전개 연산자를 사용할 때 모든 업데이트 시</span></span><br><span class="line"><span class="comment">//새 변수를 사용하여 새로운 타입을 얻도록 한다.</span></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pt0 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> pt1 = &#123; ...pt0, x: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">const</span> pt: Point = &#123; ...pt1, y: <span class="number">4</span> &#125; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>타입에 안전한 방식으로 조건부 속성을 추가하려면 속성을 추가하지 않는 null 또는 {}로 객체 전개를 사용한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ 조건부 속성의 추가 - &#123;&#125;</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> hasMiddle: <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">const</span> firstLast = &#123; first: <span class="string">'Harry'</span>, last: <span class="string">'Truman'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> president = &#123; ...firstLast, ...(hasMiddle ? &#123; middle: <span class="string">'S'</span> &#125; : &#123;&#125;) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣전개 연산자로 한꺼번에 여러 속성을 추가한다.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> hasDates: <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">const</span> nameTitle = &#123; first: <span class="string">'Harry'</span>, last: <span class="string">'Truman'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> pharaoh = &#123;</span><br><span class="line">  ...nameTitle,</span><br><span class="line">  ...(hasDates ? &#123; start: <span class="number">-289</span>, end: <span class="number">-22</span> &#125; : &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2️⃣의 타입은 <code>유니온</code>으로 추론된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pharaoh:</span><br><span class="line">   &#123;</span><br><span class="line">      start: number;</span><br><span class="line">      end: number;</span><br><span class="line">      name: string;</span><br><span class="line">      title: string;</span><br><span class="line">    &#125;</span><br><span class="line">  | &#123; <span class="attr">name</span>: string; title: string &#125;;</span><br></pre></td></tr></table></figure>
<p>이 경우 pharaoh.start로 접근하면 start와 end는 항상 함께 정의되기 때문에 속성이 없다는 에러가 표시된다. <strong>따라서 유니온을 사용하는 것이 가능한 값의 집합을 더 정확히 표현하는 것이다.</strong> 다만 유니온보다 선택적 필드가 다루기에 더 쉬울 수 있다. 아래와 같이 헬퍼 함수를 사용해서 표현한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> hasMiddle: <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">const</span> firstLast = &#123; first: <span class="string">'Harry'</span>, last: <span class="string">'Truman'</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOptional</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">U</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  a: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  b: U | <span class="literal">null</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">T</span> &amp; <span class="title">Partial</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...a, ...b &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> president = addOptional(firstLast, hasMiddle ? &#123; middle: <span class="string">'S'</span> &#125; : <span class="literal">null</span>)</span><br><span class="line">president.middle <span class="comment">// OK, type is string | undefined</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-24-일관성-있는-별칭-사용하기"><a href="#아이템-24-일관성-있는-별칭-사용하기" class="headerlink" title="아이템 24 일관성 있는 별칭 사용하기"></a>아이템 24 일관성 있는 별칭 사용하기</h2><p>별칭의 값을 변경하면 원래 속성값에서도 변경된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> borough = &#123; name: <span class="string">'Brooklyn'</span>, location: [<span class="number">40.688</span>, <span class="number">-73.979</span>] &#125;</span><br><span class="line"><span class="keyword">const</span> loc = borough.location</span><br><span class="line"></span><br><span class="line">loc[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">borough.location <span class="comment">// [0, -73.979]</span></span><br></pre></td></tr></table></figure>
<p>이렇게 별칭을 사용할 때 남발해서 사용하면 제어 흐름을 분석하기 어렵다. 제어 흐름을 분석하기 어려워서 오류가 발생할 수 있는데, <code>별칭은 일관성있게 사용한다</code>는 기본 원칙을 지키면 오류를 방지할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Coordinate &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BoundingBox &#123;</span><br><span class="line">  x: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">  y: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Polygon &#123;</span><br><span class="line">  exterior: Coordinate[]</span><br><span class="line">  holes: Coordinate[][]</span><br><span class="line">  bbox?: BoundingBox</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//객체 비구조화 사용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPointInPolygon</span>(<span class="params">polygon: Polygon, pt: Coordinate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; bbox &#125; = polygon</span><br><span class="line">  <span class="keyword">if</span> (bbox) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = bbox</span><br><span class="line">    <span class="keyword">if</span> (pt.x &lt; x[<span class="number">0</span>] || pt.x &gt; x[<span class="number">1</span>] || pt.y &lt; x[<span class="number">0</span>] || pt.y &gt; y[<span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>위와 같이 별칭 대신 객체 비구조화를 사용해서 일관된 이름을 사용할 수 있는데,</strong> 배열과 중첩된 구조에서도 사용 가능하다. 다만 아래의 두 가지 문제를 주의한다.</p>
<ul>
<li>전체 bbox 속성이 아니라 x와 y가 선택적 속성일 경우 속성 체크가 더 필요하다. 따라서 타입의 경계에 null 값을 추가하는 것이 좋다.</li>
<li>bbox에는 선택적 속성이 적합했지만 holes에는 그렇지 않다. holes가 선택적이라면 값이 없거나 빈 배열이었을 것이다. 차이가 없는데 이름을 구별한 것이다. 빈 배열은 ‘holes없음’을 나타내는 좋은 방법이다.</li>
</ul>
<p>별칭은 타입 체커 뿐 아니라 런타임에도 혼동을 야기할 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Coordinate &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BoundingBox &#123;</span><br><span class="line">  x: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">  y: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Polygon &#123;</span><br><span class="line">  exterior: Coordinate[]</span><br><span class="line">  holes: Coordinate[][]</span><br><span class="line">  bbox?: BoundingBox</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1️⃣ 런타임에 혼동을 야기한다.</span></span><br><span class="line"><span class="comment">// HIDE</span></span><br><span class="line"><span class="keyword">const</span> polygon: Polygon = &#123; exterior: [], holes: [] &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculatePolygonBbox</span>(<span class="params">polygon: Polygon</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// END</span></span><br><span class="line"><span class="keyword">const</span> &#123; bbox &#125; = polygon</span><br><span class="line"><span class="keyword">if</span> (!bbox) &#123;</span><br><span class="line">  calculatePolygonBbox(polygon) <span class="comment">// Fills in polygon.bbox</span></span><br><span class="line">  <span class="comment">// Now polygon.bbox and bbox refer to different values!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ 객체 속성에 대해 주의한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">p: Polygon</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">polygon.bbox <span class="comment">// Type is BoundingBox | undefined</span></span><br><span class="line"><span class="keyword">if</span> (polygon.bbox) &#123;</span><br><span class="line">  polygon.bbox <span class="comment">// Type is BoundingBox</span></span><br><span class="line">  fn(polygon)</span><br><span class="line">  polygon.bbox <span class="comment">// Type is still BoundingBox</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2️⃣의 경우 fn(polygon)을 호출하면 polygon.bbox를 제거할 가능성이 있다. 따라서 타입은 BoundingBox | undefined로 되돌리는 것이 안전하다. 그러나 함수를 호출할 때마나 속성 체크를 반복해야한다는 문제가 있다. <strong>그래서 타입스크립트는 함수가 타입 정제를 무효화하지 않는다고 가정하지만 실제로는 무효화될 가능성이 있다.</strong></p>
<h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h3><ul>
<li>별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때 일관되게 사용해야 한다.</li>
<li>비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.</li>
<li>함수 호출이 객체 속성의 타입 정제를 무효화하 수 있다는 점에 주의한다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.</li>
</ul>
<hr>
<h2 id="아이템-25-비동기-코드에는-콜백-대신-async-함수-사용하기"><a href="#아이템-25-비동기-코드에는-콜백-대신-async-함수-사용하기" class="headerlink" title="아이템 25 비동기 코드에는 콜백 대신 async 함수 사용하기"></a>아이템 25 비동기 코드에는 콜백 대신 async 함수 사용하기</h2><p>자바스크립트는 비동기 동작을 모델링하기 위해 <code>콜백 패턴</code>을 사용했는데, 필연적으로 콜백 지옥을 마주하여 직관적으로 코드를 이해하기 어려운 상황에 부딪히게 된다. 이를 극복하기 위해 프로미스, async await 키워드가 도입되어서 콜백 지옥을 간단하게 해결할 수 있게 되었다. ES5 또는 그 이전 버전을 대상으로 할 때 타입스크립트 컴파일러는 async와 await가 동작하도록 정교한 변환을 수행한다. <strong>즉 런타임에 관계없이 async/await를 사용할 수 있다.</strong> async 함수는 항상 프로미스를 반환하도록 강제된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _cache: &#123; [url: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchWithCache</span>(<span class="params">url: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (url <span class="keyword">in</span> _cache) &#123;</span><br><span class="line">    <span class="keyword">return</span> _cache[url]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url)</span><br><span class="line">  <span class="keyword">const</span> text = <span class="keyword">await</span> response.text()</span><br><span class="line">  _cache[url] = text</span><br><span class="line">  <span class="keyword">return</span> text</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> requestStatus: <span class="string">'loading'</span> | <span class="string">'success'</span> | <span class="string">'error'</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">userId: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  requestStatus = <span class="string">'loading'</span></span><br><span class="line">  <span class="keyword">const</span> profile = <span class="keyword">await</span> fetchWithCache(<span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span>)</span><br><span class="line">  requestStatus = <span class="string">'success'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드에서 async/await를 사용했기 때문에 requestStatus가 ‘success’로 끝나는 것이 명백해졌다. 콜백이나 프로미스를 사용하면 의도치한게 동기코드를 작성하게 되는 것처럼 실수로 반(half)동기 코드를 작성할 수 있지만 async를 사용하면 항상 비동기 코드를 작성하게 된다. 또한 async함수에서 프로미스를 반환하면 또 다른 프로미스로 래핑되지 않기 때문에 <code>Promise&lt;Promise&lt;T&gt;&gt;</code>가 아닌 <code>Promise&lt;T&gt;</code>가 된다.</p>
<h3 id="TL-DR-1"><a href="#TL-DR-1" class="headerlink" title="TL;DR"></a>TL;DR</h3><ul>
<li>콜백보다는 프로미스를 사용하는 게 코드 작성과 타입 추론 면에서 유리하다.</li>
<li>가능하면 프로미스를 생성하기보다 async와 await를 사용하는 것이 좋다. 간결하고 직관적인 코드를 작성할 수 있고 모든 종류의 오류를 제거할 수 있기 때문이다.</li>
<li>어떤 함수가 프로미스를 반환한다면 async로 선언하는 것이 좋다.</li>
</ul>
<hr>
<h2 id="아이템-26-타입-추론에-문맥이-어떻게-사용되는지-이해하기"><a href="#아이템-26-타입-추론에-문맥이-어떻게-사용되는지-이해하기" class="headerlink" title="아이템 26 타입 추론에 문맥이 어떻게 사용되는지 이해하기"></a>아이템 26 타입 추론에 문맥이 어떻게 사용되는지 이해하기</h2><p><strong>타입스크립트는 타입 추론 시 값만 고려하는 것이 아니라 그 값이 존재하는 곳의 문맥도 살핀다.</strong> 그렇기 때문에 가끔 이상한 결과가 나오기도 해서 타입 추론에 문맥이 어떻게 사용되는지 이해하는 것이 중요하다.</p>
<p>자바스크립트는 코드의 동작과 실행 순서를 바꾸지 않으면서 표현식을 상수로 분리해 낼 수 있다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLanguage</span>(<span class="params">language: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setLanguage(<span class="string">'JavaScript'</span>) <span class="comment">// OK, 인라인 형태</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> language = <span class="string">'JavaScript'</span></span><br><span class="line">setLanguage(language) <span class="comment">// OK, 참조 형태</span></span><br></pre></td></tr></table></figure>
<p>인라인 형태의 타입스크립트는 함수 선언을 통해 <em>매개변수가 language 타입</em>이어야 한다는 것을 알고 있다. 타입스크립트는 일반적으로 값이 처음 등장할 때 타입을 결정하기 때문이다. 그러나 이 값으르 변수로 분리해내면 타입스크립트는 할당 시점에 타입을 추론한다. 그래서 아래와 같이 string으로 추론하고, Language 타입에 할당이 불가능해서 오류가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Language = <span class="string">'JavaScript'</span> | <span class="string">'TypeScript'</span> | <span class="string">'Python'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLanguage</span>(<span class="params">language: Language</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setLanguage(<span class="string">'JavaScript'</span>) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> language = <span class="string">'JavaScript'</span></span><br><span class="line">setLanguage(language)</span><br><span class="line"><span class="comment">// ~~~~~~~~ Argument of type 'string' is not assignable</span></span><br><span class="line"><span class="comment">//          to parameter of type 'Language'</span></span><br></pre></td></tr></table></figure>
<h3 id="해결-방법"><a href="#해결-방법" class="headerlink" title="해결 방법"></a>해결 방법</h3><ul>
<li>타입 선언에서 language의 가능한 값을 제한한다.</li>
<li>language를 상수로 만든다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//타입 선언에서 language의 가능한 값을 제한한다.</span></span><br><span class="line"><span class="keyword">let</span> language: Language = <span class="string">'JavaScript'</span></span><br><span class="line">setLanguage(language) <span class="comment">//정상</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//language를 상수로 만든다.</span></span><br><span class="line"><span class="keyword">const</span> language = <span class="string">'JavaScript'</span></span><br><span class="line">setLanguage(language) <span class="comment">//정상</span></span><br></pre></td></tr></table></figure>
<h3 id="튜플-사용-시-주의점"><a href="#튜플-사용-시-주의점" class="headerlink" title="튜플 사용 시 주의점"></a>튜플 사용 시 주의점</h3><p>튜플은 요소의 타입과 개수가 고정된 배열을 표현할 수 있는 타입이다. 따라서 아래와 같이 사용하면 에러가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Language = <span class="string">'JavaScript'</span> | <span class="string">'TypeScript'</span> | <span class="string">'Python'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLanguage</span>(<span class="params">language: Language</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Parameter is a (latitude, longitude) pair.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panTo</span>(<span class="params">where: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">panTo([<span class="number">10</span>, <span class="number">20</span>]) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loc = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">panTo(loc)</span><br><span class="line"><span class="comment">//    ~~~ Argument of type 'number[]' is not assignable to</span></span><br><span class="line"><span class="comment">//        parameter of type '[number, number]'</span></span><br></pre></td></tr></table></figure>
<p>loc로 선언하여서 타입이 number[]로 추론된다. 이는 길이를 알 수 없는 숫자의 배열이어서 <code>[10,20]</code>과 맞지 않는 수의 요소이기 때문에 튜플에 할당할 수 없다. 이 에러를 해결하는 방법은 다음과 같다.</p>
<ul>
<li>타입스크립트가 의도를 정확히 파악할 수 있도록 타입 선언 제공</li>
<li>상수 문맥 제공: as const로 값이 가리키는 참조와 그 값이 내부까지 상수임을 알려준다. 단 as const는 타입 정의에 실수가 있을 때 타입 정의가 아니라 호출되는 곳에서 에러가 발생해서 근본적인 원인을 찾기 어렵게 한다.</li>
<li>readonly의 사용</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Language = <span class="string">'JavaScript'</span> | <span class="string">'TypeScript'</span> | <span class="string">'Python'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLanguage</span>(<span class="params">language: Language</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Parameter is a (latitude, longitude) pair.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panTo</span>(<span class="params">where: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1️⃣ 타입 선언</span></span><br><span class="line"><span class="keyword">const</span> loc: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">panTo(loc) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ as const로 상수 문맥 제공 - 이 케이스에서는 에러발생</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panTo</span>(<span class="params">where: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> loc = [<span class="number">10</span>, <span class="number">20</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line">panTo(loc)</span><br><span class="line"><span class="comment">// ~~~ Type 'readonly [10, 20]' is 'readonly'</span></span><br><span class="line"><span class="comment">//     and cannot be assigned to the mutable type '[number, number]'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3️⃣ 타입 시그니처에 readonly 사용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">panTo</span>(<span class="params">where: readonly [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> loc = [<span class="number">10</span>, <span class="number">20</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line">panTo(loc) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h3 id="객체-사용-시-주의점"><a href="#객체-사용-시-주의점" class="headerlink" title="객체 사용 시 주의점"></a>객체 사용 시 주의점</h3><p>객체 사용 시에도 에러를 발생시키는 문제가 생기는데 아래와 같은 방법으로 해결한다.</p>
<ul>
<li>타입 선언 추가</li>
<li>상수 단언(as const)사용</li>
</ul>
<h3 id="콜백-사용-시-주의점"><a href="#콜백-사용-시-주의점" class="headerlink" title="콜백 사용 시 주의점"></a>콜백 사용 시 주의점</h3><p>콜백을 다른 함수로 전달할 때 콜백의 매개변수 타입을 추론하기 위해 문맥을 사용한다. 그런데 아래 예시에서 fn으로 콜백을 상수로 뽑아내면 문맥이 소실되어 noImplicitAny오류가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callWithRandomNumbers</span>(<span class="params">fn: (n1: <span class="built_in">number</span>, n2: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  fn(<span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ~    Parameter 'a' implicitly has an 'any' type</span></span><br><span class="line">  <span class="comment">//    ~ Parameter 'b' implicitly has an 'any' type</span></span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line">callWithRandomNumbers(fn)</span><br><span class="line"></span><br><span class="line"><span class="comment">//해결방법</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line">callWithRandomNumbers(fn)</span><br></pre></td></tr></table></figure>
<p>해결방법은 아래와 같다.</p>
<ul>
<li>매개변수에 타입 구문을 추가한다.</li>
<li>가능하다면 전체 함수 표현식에 타입 선언</li>
</ul>
<hr>
<h2 id="아이템-27-함수형-기법과-라이브러리로-타입-흐름-유지하기"><a href="#아이템-27-함수형-기법과-라이브러리로-타입-흐름-유지하기" class="headerlink" title="아이템 27 함수형 기법과 라이브러리로 타입 흐름 유지하기"></a>아이템 27 함수형 기법과 라이브러리로 타입 흐름 유지하기</h2><p>로대시(lodash)와 같은 라이브러리의 일부 기능은 순수 자바스크립트로 구현되어 있고, 루프를 대체할 수 있기 때문에 유용하게 사용되고, 타입스크립트와 조합했을 때 더욱 유용하게 사용된다. <strong>타입 정보는 유지하면서 타입 흐름이 계속 전달되도록 하기 때문이다.</strong> 하지만 서드파티 라이브러리 기반으로 코드를 짧게 줄이는데 시간이 많이 든다면 사용하지 않는게 낫다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rows = rawRows</span><br><span class="line">  .slice(<span class="number">1</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">rowStr</span> =&gt;</span></span><br><span class="line">    rowStr</span><br><span class="line">      .split(<span class="string">','</span>)</span><br><span class="line">      .reduce(<span class="function">(<span class="params">row, val, i</span>) =&gt;</span> ((row[headers[i]] = val), row), &#123;&#125;)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">//lodash zipObject사용</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"><span class="keyword">const</span> rows = rawRows</span><br><span class="line">  .slice(<span class="number">1</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">rowStr</span> =&gt;</span> _.zipObject(headers, rowStr.split(<span class="string">','</span>)))</span><br></pre></td></tr></table></figure>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/07/220208_tsitem19to20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/07/220208_tsitem19to20/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 19 - 아이템 20</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-08 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-08T00:00:00+09:00">2022-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-21 23:10:05" itemprop="dateModified" datetime="2022-03-21T23:10:05+09:00">2022-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-19-추론-가능한-타입을-사용해-장황한-코드-방지하기"><a href="#아이템-19-추론-가능한-타입을-사용해-장황한-코드-방지하기" class="headerlink" title="아이템 19 추론 가능한 타입을 사용해 장황한 코드 방지하기"></a>아이템 19 추론 가능한 타입을 사용해 장황한 코드 방지하기</h2><p>타입스크립트가 결국 타입을 위한 언어이기 때문에 변수를 선언할 때마다 타입을 명시해야 한다고 생각하기 쉽다. <em>하지만 코드의 모든 변수에 타입을 선언하는 것은 비생산적이다.</em> 타입스크립트는 타입 추론이 된다면 명시적 타입 구문은 필요하지 않다. <code>let x = 12;</code>와 같은 구문은 x가 number로 추론되기 때문에 굳이 <code>let x: number = 12;</code>로 작성하지 않아도 되고, 객체와 배열에 대해서도 동일하다. 아래 예시에서 1️⃣은 2️⃣로 작성해도 동일하다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣</span></span><br><span class="line"><span class="keyword">const</span> person: &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  born: &#123;</span><br><span class="line">    where: <span class="built_in">string</span>;</span><br><span class="line">    when: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  died: &#123;</span><br><span class="line">    where: <span class="built_in">string</span>;</span><br><span class="line">    when: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  name: <span class="string">'Sojourner Truth'</span>,</span><br><span class="line">  born: &#123;</span><br><span class="line">    where: <span class="string">'Swartekill, NY'</span>,</span><br><span class="line">    when: <span class="string">'c.1797'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  died: &#123;</span><br><span class="line">    where: <span class="string">'Battle Creek, MI'</span>,</span><br><span class="line">    when: <span class="string">'Nov. 26, 1883'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sojourner Truth'</span>,</span><br><span class="line">  born: &#123;</span><br><span class="line">    where: <span class="string">'Swartekill, NY'</span>,</span><br><span class="line">    when: <span class="string">'c.1797'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  died: &#123;</span><br><span class="line">    where: <span class="string">'Battle Creek, MI'</span>,</span><br><span class="line">    when: <span class="string">'Nov. 26, 1883'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>때로는 추론이 더 정확할 때가 있는데, 아래의 경우 명시적으로 string이라고 타입을 준 것 보다 추론된 ‘y’가 사실은 더 정확하다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axis1: <span class="built_in">string</span> = <span class="string">'x'</span>; <span class="comment">// Type is string</span></span><br><span class="line"><span class="keyword">const</span> axis2 = <span class="string">'y'</span>; <span class="comment">// Type is "y"</span></span><br></pre></td></tr></table></figure>
<p>아래 예시에서 Product의 id를 number라고 작성했다가 나중에 문자도 있을 수 있다는 것을 알게되어 string으로 작성했다고 가정해보자. 이 경우 선언된 타입과 함수 내의 타입이 일치하지 않아서 오류를 발생시킨다. 만약 여기서 명시적 타입 구문이 없었다면 문제없이 타입 체커를 통과했을 것이다. 그래서 이런 경우에는 비구조 할당문으로 구현하는 것이 더 나은 선택이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Product &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProduct</span>(<span class="params">product: Product</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id: <span class="built_in">number</span> = product.id;</span><br><span class="line">  <span class="comment">// ~~ Type 'string' is not assignable to type 'number'</span></span><br><span class="line">  <span class="keyword">const</span> name: <span class="built_in">string</span> = product.name;</span><br><span class="line">  <span class="keyword">const</span> price: <span class="built_in">number</span> = product.price;</span><br><span class="line">  <span class="built_in">console</span>.log(id, name, price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//비구조 할당 - 여기에 추가로 명시적 타입 구문을 넣는 것은 불필요하다.</span></span><br><span class="line"><span class="keyword">interface</span> Product &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProduct</span>(<span class="params">product: Product</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; id, name, price &#125; = product;</span><br><span class="line">  <span class="built_in">console</span>.log(id, name, price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>그러나 정보가 부족해서 타입스크립트가 스스로 판단하기 어려운 경우에는 명시적 타입 구문이 필요하다.</strong> 위 예제에서 logProduct 함수에서 매개밴수의 타입을 Product로 명시한 경우가 그 예이다. 이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역변수에는 타입 구문을 넣지 않는 것이다. 단, 기본값이 있는 경우에는 타입 구문을 생략하기도 한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseNumber</span>(<span class="params">str: <span class="built_in">string</span>, base = 10</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>타입이 추론될 수 있음에도 타입을 명시하고 싶은 경우가 있다. 객체 리터럴의 정의과 함수의 반환 타입을 명시할 때이다.</p>
<h3 id="객체-리터럴의-정의"><a href="#객체-리터럴의-정의" class="headerlink" title="객체 리터럴의 정의"></a>객체 리터럴의 정의</h3><p>객체 리터럴에서 타입을 명시하면 잉여 속성 체크가 동작해서 실제로 실수가 방생한 부분에 정확하게 오류를 표시해 줄 수 있다. 아래 예시에서 타입 구문을 제거하면 잉여 속성 체크가 동작하지 않아서 실제 오류가 발생한 id쪽이 아니라 객체가 사용되는 곳에서 오류가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Product &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProduct</span>(<span class="params">product: Product</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id: <span class="built_in">number</span> = product.id;</span><br><span class="line">  <span class="comment">// ~~ Type 'string' is not assignable to type 'number'</span></span><br><span class="line">  <span class="keyword">const</span> name: <span class="built_in">string</span> = product.name;</span><br><span class="line">  <span class="keyword">const</span> price: <span class="built_in">number</span> = product.price;</span><br><span class="line">  <span class="built_in">console</span>.log(id, name, price);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> furby: Product = &#123;</span><br><span class="line">  name: <span class="string">'Furby'</span>,</span><br><span class="line">  id: <span class="number">630509430963</span>,</span><br><span class="line">  <span class="comment">// ~~ Type 'number' is not assignable to type 'string'</span></span><br><span class="line">  price: <span class="number">35</span>,</span><br><span class="line">&#125;;</span><br><span class="line">logProduct(furby);</span><br></pre></td></tr></table></figure>
<h3 id="함수의-반환"><a href="#함수의-반환" class="headerlink" title="함수의 반환"></a>함수의 반환</h3><p>타입 추론이 가능한 경우에도 구현상의 오류가 함수를 호출한 곳까지 영향을 미치지 않도록 하기 위함이다. 반환 타입을 명시하면 구현상의 오류가 사용자 코드의 오류로 표시되지 않고, 오류의 위치를 제대로 표시해준다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache: &#123; [ticker: <span class="built_in">string</span>]: <span class="built_in">number</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQuote</span>(<span class="params">ticker: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//getQuote가 반환하는 것은 Promise.resolve(cache[ticker])이어야 한다.</span></span><br><span class="line">  <span class="comment">//따라서 여기에서 아래와 같은 오류가 발생해야 한다.</span></span><br><span class="line">  <span class="comment">//~~~~~~~~~~~~~ Type 'number' is not assignable to 'Promise&lt;number&gt;'</span></span><br><span class="line">  <span class="comment">//하지만 실제 오류는 가장 아래 getQuote를 호출한 코드에서 발생한다.</span></span><br><span class="line">  <span class="keyword">if</span> (ticker <span class="keyword">in</span> cache) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[ticker];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">`https://quotes.example.com/?q=<span class="subst">$&#123;ticker&#125;</span>`</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function">(<span class="params">quote</span>) =&gt;</span> &#123;</span><br><span class="line">      cache[ticker] = quote;</span><br><span class="line">      <span class="keyword">return</span> quote;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">considerBuying</span>(<span class="params">x: <span class="built_in">any</span></span>) </span>&#123;&#125;</span><br><span class="line">getQuote(<span class="string">'MSFT'</span>).then(considerBuying);</span><br><span class="line"><span class="comment">// ~~~~ Property 'then' does not exist on type</span></span><br><span class="line"><span class="comment">//        'number | Promise&lt;any&gt;'</span></span><br><span class="line"><span class="comment">//      Property 'then' does not exist on type 'number'</span></span><br></pre></td></tr></table></figure>
<p>그 외에도 반환타입을 명시하는 것은 아래 두 가지 장점이 있다.</p>
<ul>
<li><code>함수를 더욱 명확하게 알기 쉽다.</code> 반환 타입을 명시하려면 입력, 출력 타입에 대해 알아야 하고 미리 명시해야만 하기 때문에 타입을 미리 작성하여 구현이 맞추어 주먹구구식으로 타입이 작성되는 것이 아닌 테스트 주도 개발처럼 작성할 수 있게 된다.</li>
<li><code>명명된 타입을 사용할 수 있다.</code> 반환 타입을 명시하면 더욱 직관적인 표현이 되고, 반환 값을 별도의 타입으로 정의하면 타입에 대한 주석을 작설항 수 있어 함수에 대해 더 자세히 설명하게 된다.</li>
</ul>
<hr>
<h2 id="아이템-20-다른-타입에는-다른-변수-사용하기"><a href="#아이템-20-다른-타입에는-다른-변수-사용하기" class="headerlink" title="아이템 20 다른 타입에는 다른 변수 사용하기"></a>아이템 20 다른 타입에는 다른 변수 사용하기</h2><p>자바스크립트에서는 한 변수를 다른 목적을 가지는 다른 타입으로 재사용해도 되는데, 타입스크립트에서는 이렇게 사용하면 두 가지 오류가 발생한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//자바스크립트</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="string">'12-34-56'</span>;</span><br><span class="line">fetchProduct(id); <span class="comment">//string으로 사용</span></span><br><span class="line"></span><br><span class="line">id = <span class="number">123456</span>;</span><br><span class="line">fetchProductBySerialNumber(id); <span class="comment">//number로 사용</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//타입스크립트</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProduct</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProductBySerialNumber</span>(<span class="params">id: <span class="built_in">number</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> id = <span class="string">'12-34-56'</span>;</span><br><span class="line">fetchProduct(id);</span><br><span class="line"></span><br><span class="line">id = <span class="number">123456</span>;</span><br><span class="line"><span class="comment">// ~~ '123456' is not assignable to type 'string'.</span></span><br><span class="line">fetchProductBySerialNumber(id);</span><br><span class="line"><span class="comment">// ~~ Argument of type 'string' is not assignable to</span></span><br><span class="line"><span class="comment">//    parameter of type 'number'</span></span><br></pre></td></tr></table></figure>
<p>여기서 중요한 점은 <strong>변수의 값은 바뀔 수 있지만 타입은 바뀌지 않는다.</strong>는 점이다. 범위를 좁히는 방법으로 타입을 바꿀 수는 있지만 그것은 새로운 변수값을 포함하도록 확장하는 것이 아니라 타입을 더 작게 제한하는 것이다.</p>
<h3 id="유니온-타입을-이용한-타입의-확장"><a href="#유니온-타입을-이용한-타입의-확장" class="headerlink" title="유니온 타입을 이용한 타입의 확장"></a>유니온 타입을 이용한 타입의 확장</h3><p>id가 string, number를 모두 포함할 수 있도록 타입을 확장하는 유니온을 통해 아래와 같이 작성하면 에러는 해결된다. 하지만 이렇게 작성하면 매번 id값이 string인지 number인지 확인해야 하기 때문에 이런 경우에는 별도의 변수로 작성하는 것이 낫다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProduct</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProductBySerialNumber</span>(<span class="params">id: <span class="built_in">number</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> id: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">'12-34-56'</span>;</span><br><span class="line">fetchProduct(id);</span><br><span class="line"></span><br><span class="line">id = <span class="number">123456</span>; <span class="comment">// OK</span></span><br><span class="line">fetchProductBySerialNumber(id); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//유니온 타입 대신 별도의 변수로 작성</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProduct</span>(<span class="params">id: <span class="built_in">string</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchProductBySerialNumber</span>(<span class="params">id: <span class="built_in">number</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> id = <span class="string">'12-34-56'</span>;</span><br><span class="line">fetchProduct(id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serial = <span class="number">123456</span>; <span class="comment">// OK</span></span><br><span class="line">fetchProductBySerialNumber(serial); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>무엇보다 변수를 재사용하는 방식은 타입 체커는 물론 사람에게도 혼란을 주기 때문에 지양해야 한다. 타입이 다른 경우 별도의 변수를 사용하는 것이 바람직한 이유는 다음과 같다.</p>
<ul>
<li>서로 관련이 없는 두 개의 값을 분리한다.</li>
<li>변수명을 더 구체적으로 지을 수 있다.</li>
<li>타입 추론을 향상시키며, 타입 구문이 불필요해진다.</li>
<li>타입이 간결해진다.</li>
<li>let 대신 const로 변수를 선언하게 된다. 이렇게 하면 코드가 간결하고, 타입 체커의 타입 추론이 용이하다.</li>
</ul>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/06/220207_userAgent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/06/220207_userAgent/" class="post-title-link" itemprop="url">사용자 에이전트 (User Agent)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-07T00:00:00+09:00">2022-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-21 23:10:05" itemprop="dateModified" datetime="2022-03-21T23:10:05+09:00">2022-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>사용자를 대표하는 컴퓨터 프로그램, 웹에서는 <code>브라우저</code>를 의미하고, 웸 페이지를 긁어가는 봇, 다운로드 관리자, 웹에 접근하는 다른앱 등이 있다.</p>
</blockquote>
<ul>
<li>브라우저는 서버에 보내는 모든 요청에 <code>User-Agent HTTP(사용자 에이전트 문자열) 헤더</code>를 보낸다.</li>
<li>여기에는 브라우저 종류, 버전 번호, 호스트 운영체제를 포함하는 브라우저 정보가 담겨있다.</li>
<li>클라이언트에서 JS의 <code>navigator.userAgent</code> 속성으로 사용자 에이전트 문자열에 접근할 수 있다.</li>
</ul>
<hr>
<h2 id="user-agent를-이용한-브라우저-감지"><a href="#user-agent를-이용한-브라우저-감지" class="headerlink" title="user agent를 이용한 브라우저 감지"></a>user agent를 이용한 브라우저 감지</h2><p><em>웹은 유저가 어떤 브라우저, 어떤 디바이스를 사용하고 있는지와 관계없이 모두에게 접근성이 용이해야 한다.</em> 하지만 브라우저와 웹 표준이 완벽하지 않기 때문에 몇 가지 edge case가 존재하여 브라우저 감지를 필요로 한다. <strong>user agent를 사용하여 브라우저를 감지하는 것은 간단하지만 그것을 잘하기는 매우 어려운 문제이다.</strong></p>
<h2 id="브라우저-감지-전에-고려해야할-점"><a href="#브라우저-감지-전에-고려해야할-점" class="headerlink" title="브라우저 감지 전에 고려해야할 점"></a>브라우저 감지 전에 고려해야할 점</h2><blockquote>
<p>웬만하면 user agent를 사용한 브라우저 감지를 하지 않는 것이 우선이다. 하지만 그럼에도 불구하고 필요하다고 판단된다면 아래 질문에 근거하여 <em>정말로 내가 왜 그 기능을 필요로 하는가를 고려해보도록 한다.</em></p>
</blockquote>
<ul>
<li>특정 브라우저 버전에 있는 버그를 고치려고 하는가?<ul>
<li>포럼에서 버그를 찾아보고, 처음 발견한 버그라면 질문해보도록 한다. 만약 정상적이지 않은 문제로 보인다면 브라우저 제공자의 버그 추척 시스템(<a href="https://bugzilla.mozilla.org/" target="_blank" rel="noopener">Mozilla</a>, <a href="https://bugs.webkit.org/" target="_blank" rel="noopener">WebKit</a>, <a href="https://www.chromium.org/issue-tracking/" target="_blank" rel="noopener">Blink</a>, <a href="https://bugs.opera.com/login.jsp" target="_blank" rel="noopener">Opera</a>)에 보고된 버그인지 확인해본다.</li>
</ul>
</li>
<li>특정 기능의 존재 여부를 체크하려고 하는가?<ul>
<li>몇몇 브라우저에서 지원하지 않는 기능을 사이트에서 사용하고자 할 때, 그 유저들을 기능은 더 적지만 작동할 것임이 분명한 옛 버전의 웹 사이트로 보내고 싶을텐데, 결국에는 언젠가 해당 브라우저에서 그 기능이 동작할 것임을 알고 있는 상황이다. 이런 상황이 user agent를 이용한 브라우저 감지를 사용하는 가장 나쁜 케이스인데, 몇몇 브라우저에서 지원하지 않는 기능들도 결국에는 지원하는 방향이 될 것이기 때문이다. 또한 비교적 인기가 덜한 브라우저의 웹 기능까지 모두 테스트하는 것은 실용적이지 않다. 이런 경우에는 user agent를 사용한 탐지를 절대 피해야 한다. 언제나 기능을 탐지할 수 있는 대안이 존재하기 때문이다.</li>
</ul>
</li>
<li>사용하는 브라우저에 따라 다른 HTML을 제공해야 하는가?<ul>
<li>보통 이런 것은 나쁜 방법이지만 필요한 경우가 있다. 필요에 의해 사용해야 한다면 <em>먼저 정말로 이렇게 해야하는지 당신이 처한 상황에 대해 분석해보아야 한다.</em> non-semantic 요소인 <code>&lt;div&gt;, &lt;span&gt;</code> 등을 추가하여 피할 수 있는 방법이 있을까? user Agent 감지를 성공적으로 하는 것의 어려움은 HTML의 순수성을 혼란스럽게 할 수 있다. 또한 디자인에 대해 다시 생각해보아야 한다. 브라우저별로 다른 HTML을 사용할 필요성을 없애기 위해 점진적 향상을 고려하거나 가변 레이아웃(fluid layouts)를 사용할 수 있는가?</li>
</ul>
</li>
</ul>
<h2 id="user-agent-사용을-대신할-방법"><a href="#user-agent-사용을-대신할-방법" class="headerlink" title="user agent 사용을 대신할 방법"></a>user agent 사용을 대신할 방법</h2><h3 id="모바일-장치-감지"><a href="#모바일-장치-감지" class="headerlink" title="모바일 장치 감지"></a>모바일 장치 감지</h3><p>틀림없이 user agent의 가장 흔한 사용 및 오용은 디바이스가 모바일 디바이스인지 여부를 감지하는 것이다. 그러나 사람들은 정말로 해야하는 것이 무엇인지 간과하기 쉽다. 사람들은 user agent를 사용해서 유저의 디바이스가 터치 친화적(touch-friendly)인지 작은 스크린에서도 그에 따라 웹사이트를 최적화할 수 있는지 여부를 감지한다. user agent가 때때로 이런 것을 감지할 수 있지만 모든 디바이스에 대해 동일한 것은 아니다. 일부 모바일 장치는 큰 스크린을 가진 경우가 있고, 일부 데스크톱은 작은 터치스크린을 가진 경우가 있다. 어떤 사람은 smart TV를 쓰기도 하고, 또 어떤 사람들은 태블릿을 옆으로 움직여서 화면의 높이와 너비를 동적으로 변경할 수도 있다. 그러므로 user agent의 사용은 확실히 올바른 방법은 아니다. 그리고 더 좋은 대안이 있다.<br><code>Navigator.maxTouchPoints</code>을 사용해서 유저가 터치스크린을 가졌는지 여부를 감지한다. 그런 다음 <code>if (!(&quot;maxTouchPoints&quot; in Navigator)) { /*Code here*/}.</code>한 경우에만 기본적으로(default) user agent 화면을 확인한다. 이 정보를 통해 어떤 디바이스가 터치스크린을 가졌는지 여부를 확인하고, 이를 사용해서 전체 레이아웃을 변경하지 않고 오직 터치 스크린일 경우에 대해서만 특정 작업을 더 만들거나 유지 관리를 할 수 있다. 예를 들어, 좀 더 크고, 클릭하기 쉬운 버튼과 같은 touch 편의성(convenience)을 추가한다. 이를 위해서 스크린 사이즈에 따라 단순하게 <code>window.innerWidth</code>와 <code>window.addEventListener(&quot;resize&quot;, function(){ /_refresh screen size dependent things_/ }).</code>를 사용하면 된다. 스크린 사이즈를 위해 해야하는 일은 작은 화면에서 보여줘야할 정보를 줄이는 것이 아니다. 이런 방법은 사람들에게 데스크톱 버전을 사용하도록 강제하는 것이기 때문에 짜증만 날 뿐이다. 이보다는 작은 스크린의 긴 페이지에서는 더 적은 열(columns)의 정보를 갖도록 하고, 더 큰 스크린의 짧은 페이지에서는 더 많은 열(cloumns)를 갖도록 한다. 이러한 효과는 CSS flexboxㄹㄹ 이용해서 쉽게 얻을 수 있다. 그리고 항상 코드를 동적으로 만들어야 한다. 유저는 모바일 디바이스를 옆으로 움직여서 페이지의 너비와 높이를 바꿀 수 있다. 그렇기 때문에 웹 페이지가 부드럽고 유동적이며 동적으로 크카가 조정되는 동안 개발자 도구를 열어서 화면 크기를 조정할 수 있을 때까지 웹 페이지에 만족하지 않도록 한다.</p>
<hr>
<p><em>References</em><br><a href="https://developer.mozilla.org/en-US/docs/Glossary/User_agent" target="_blank" rel="noopener">User agent</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent" target="_blank" rel="noopener">Browser detection using the user agent</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/02/01/220202_tsitem10to18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/01/220202_tsitem10to18/" class="post-title-link" itemprop="url">타입스크립트 이펙티브 아이템 10 - 아이템 18</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-02T00:00:00+09:00">2022-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-21 23:10:05" itemprop="dateModified" datetime="2022-03-21T23:10:05+09:00">2022-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="아이템-10-객체-래퍼-타입-피하기"><a href="#아이템-10-객체-래퍼-타입-피하기" class="headerlink" title="아이템 10 객체 래퍼 타입 피하기"></a>아이템 10 객체 래퍼 타입 피하기</h2><h3 id="자바스크립트의-타입"><a href="#자바스크립트의-타입" class="headerlink" title="자바스크립트의 타입"></a>자바스크립트의 타입</h3><blockquote>
<p>기본형 값들에 대한 일곱가지 타입 (string, number, boolean, null, undefined, symbol(ES2015에서 추가), bigint(최종 확정 단계))<br>객체</p>
</blockquote>
<p><strong>기본형은 불변이며, 메서드를 가지지 않는다.</strong> 그런데 기본형인 string이 메서드를 가진 것처럼 보이는 이유는 자바스크립트에 메서드를 가지는 <code>String 객체 타입</code>이 정의되어 있기 때문이다. 만약 charAt과 같은 메서드를 기본형에 사용한다면 기본형을 String 객체로 래핑하여 메서드를 호출한 후 마지막에 래핑한 객체를 버리는 방식으로 작동된다. null과 undefined를 제외한 모든 기본형에 이와 같은 객체 래퍼 타입이 존재한다. 이러한 래퍼 객체는 직접 생성할 필요가 없고, 기본형을 사용해야하는데 래퍼 객체를 사용하지 않도록 주의하여야 한다. <strong>타입스크립트가 제공하는 타입 선언은 전부 기본형 타입이다.</strong> 다만 기본형 타입은 객체 래퍼에 할당할 수 있기 때문에 타입스크립트는 기본형 타입을 객체 래퍼에 할당하는 것을 허용한다. 그러나 이런 방법은 오해하기 쉽고 이렇게 쓰지 않는 것이 좋다.</p>
<hr>
<h2 id="아이템-11-잉여-속성-체크의-한계-인지하기"><a href="#아이템-11-잉여-속성-체크의-한계-인지하기" class="headerlink" title="아이템 11 잉여 속성 체크의 한계 인지하기"></a>아이템 11 잉여 속성 체크의 한계 인지하기</h2><p>타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지, <strong>그 외의 속성은 없는지</strong> 확인한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ 잉여 속성 체크</span></span><br><span class="line"><span class="keyword">interface</span> Room &#123;</span><br><span class="line">  numDoors: <span class="built_in">number</span>;</span><br><span class="line">  ceilingHeightFt: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> r: Room = &#123;</span><br><span class="line">  numDoors: <span class="number">1</span>,</span><br><span class="line">  ceilingHeightFt: <span class="number">10</span>,</span><br><span class="line">  elephant: <span class="string">'present'</span>,</span><br><span class="line">  <span class="comment">// ~~~~~~~~~~~~~~~~~~ Object literal may only specify known properties,</span></span><br><span class="line">  <span class="comment">//                    and 'elephant' does not exist in type 'Room'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣</span></span><br><span class="line"><span class="keyword">interface</span> Room &#123;</span><br><span class="line">  numDoors: <span class="built_in">number</span>;</span><br><span class="line">  ceilingHeightFt: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  numDoors: <span class="number">1</span>,</span><br><span class="line">  ceilingHeightFt: <span class="number">10</span>,</span><br><span class="line">  elephant: <span class="string">'present'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> r: Room = obj; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>1️⃣ 의 샘플코드는 <code>잉여 속성 체크</code>가 수행되었다. 구조적 타입 시스템에서 발생할 수 있는 중요한 오류를 잡을 수 있도록 한다. 1️⃣ 의 샘플코드는 <em>구조적 타입</em>의 관점에서 생각해보면 elephant 속성이 있어도 오류가 발생하지 않아야 하지만, 오류가 발생했다. 이처럼 잉여 속성 체크를 사용하면 타입 시스템의 구조적 본질을 해치치 않으면서도 객체 리터럴에 알 수 없는 속성을 허용하지 않음으로써 문제의 발생을 방지 할 수 있다. 단, 조건에 따라 동작하지 않을 수 있고, 통상적인 할당 가능 검사와 함께 쓰이면 구조적 타이핑이 무엇인지 혼란스러워 진다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Room &#123;</span><br><span class="line">  numDoors: <span class="built_in">number</span>;</span><br><span class="line">  ceilingHeightFt: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDarkMode</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  darkMode?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> intermediate = &#123; darkmode: <span class="literal">true</span>, title: <span class="string">'Ski Free'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> o: Options = intermediate; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o2 = &#123; darkmode: <span class="literal">true</span>, title: <span class="string">'Ski Free'</span> &#125; <span class="keyword">as</span> Options; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>위 예시에서 intermediate 변수의 오른쪽은 객체 리터럴이지만 o변수의 intermediate는 객체 리터럴이 아니다. 타입 구문이 없는 임시 변수이다. 이 경우 잉여 속성 체크가 적용되지 않아서 오류가 사라진다. 위의 예시에서 o2와 같이 타입 단언을 사용해도 잉여 속성 체크는 적용되지 않는다. 아래 예시처럼 선택적 속성만 가지는 약한 타입에도 비슷한 체크가 동작한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> LineChartOptions &#123;</span><br><span class="line">  logscale?: <span class="built_in">boolean</span>;</span><br><span class="line">  invertedYAxis?: <span class="built_in">boolean</span>;</span><br><span class="line">  areaChart?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; logScale: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> o: LineChartOptions = opts;</span><br><span class="line"><span class="comment">// ~ Type '&#123; logScale: boolean; &#125;' has no properties in common</span></span><br><span class="line"><span class="comment">//   with type 'LineChartOptions'</span></span><br></pre></td></tr></table></figure>
<p>위 예시에서 LineChartOptions 타입은 모든 속성이 선택적이므로 모든 객체를 포함할 수 있는 약한 타입이다. 이 경우 타입스크립트가 값 타입과 선언 타입에 공통된 속성이 있는지 확인하는 별도의 체크를 수행한다. 오타를 잡는데 효과적이며 구조적으로 엄격하지 않지만 잉여 속성 체크와 다른 점은 약한 타입과 관련된 할당문마다 수행된다는 점이다. 따라서 임시 변수를 제거하더라도 공통 속성 체크는 여전히 동작한다.</p>
<hr>
<p>TL;DR</p>
<ul>
<li>객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 체크 속성이 수행된다.</li>
<li>잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이 다르다. 할당의 개념을 정확히 알아야 잉여 속성 체크와 일반적인 구조적 할당 가능성 체크를 구분할 수 있다.</li>
<li>잉여 속성 체크에는 한계가 있다. 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다.</li>
</ul>
<h2 id="아이템-12-함수-표현식에-타입-적용하기"><a href="#아이템-12-함수-표현식에-타입-적용하기" class="headerlink" title="아이템 12 함수 표현식에 타입 적용하기"></a>아이템 12 함수 표현식에 타입 적용하기</h2><p>자바스크립트에서는 함수 문장(statement)와 함수 표현식(expression)을 다르게 인식한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rollDice1</span>(<span class="params">sides: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* COMPRESS */</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* END */</span></span><br><span class="line">&#125; <span class="comment">// Statement</span></span><br><span class="line"><span class="keyword">const</span> rollDice2 = <span class="function"><span class="keyword">function</span> (<span class="params">sides: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* COMPRESS */</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* END */</span></span><br><span class="line">&#125;; <span class="comment">// Expression</span></span><br><span class="line"><span class="keyword">const</span> rollDice3 = (sides: number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* COMPRESS */</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* END */</span></span><br><span class="line">&#125;; <span class="comment">// Also expression</span></span><br></pre></td></tr></table></figure>
<p>타입스크립트에서는 <code>함수 표현식</code>을 사용하는 것이 좋다. 그 이유는 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있기 때문이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ 사칙연산을 하는 함수 - 함수의 매개변수에 타입 선언</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ 함수 시그니처를 하나의 함수 타입으로 통합 - 함수 표현식 전체 타입을 정의</span></span><br><span class="line"><span class="keyword">type</span> BinaryFn = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">const</span> add: BinaryFn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">const</span> sub: BinaryFn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b;</span><br><span class="line"><span class="keyword">const</span> mul: BinaryFn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * b;</span><br><span class="line"><span class="keyword">const</span> div: BinaryFn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a / b;</span><br></pre></td></tr></table></figure>
<p>1️⃣ 에 비해 2️⃣ 가 코드가 간결하고 안전하다.</p>
<hr>
<h2 id="아이템-13-타입과-인터페이스-차이점-알기"><a href="#아이템-13-타입과-인터페이스-차이점-알기" class="headerlink" title="아이템 13 타입과 인터페이스 차이점 알기"></a>아이템 13 타입과 인터페이스 차이점 알기</h2><p>타입스크립트에서 명명된 타입을 정의하는 방법은 아래와 같이 <code>type</code>, <code>interface</code>의 두 가지 방법이 있다. 대부분의 경우 둘 중 어떤 것을 사용해도 상관없지만 <strong>두 가지 타입이 가지는 차이점을 명확히 알고 사용해야 한다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TState = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type-interface의-비슷한-점"><a href="#type-interface의-비슷한-점" class="headerlink" title="type, interface의 비슷한 점"></a><code>type</code>, <code>interface</code>의 비슷한 점</h3><ul>
<li>명명된 타입은 <code>type</code>, <code>interface</code> 둘 중 어떤 것으로 정의하든 상태에 차이가 없지만, <strong>추가 속성과 함께 할당하려고 하면 오류가 발생한다.</strong></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//예제코드에서 type은 T, interface는 I를 접두사로 사용했는데,</span></span><br><span class="line"><span class="comment">//이해를 돕기 위함이며, 실제코드에서는 이렇게 사용하지 않도록 한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TState = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wyoming: TState = &#123;</span><br><span class="line">  name: <span class="string">'Wyoming'</span>,</span><br><span class="line">  capital: <span class="string">'Cheyenne'</span>,</span><br><span class="line">  population: <span class="number">500</span>_000,</span><br><span class="line">  <span class="comment">// ~~~~~~~~~~~~~~~~~~ Type ... is not assignable to type 'TState'</span></span><br><span class="line">  <span class="comment">//                    Object literal may only specify known properties, and</span></span><br><span class="line">  <span class="comment">//                    'population' does not exist in type 'TState'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>인덱스 시그니처의 사용이 가능하다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TDict = &#123; [key: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">interface</span> IDict &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>함수 타입도 정의할 수 있고, 제너릭이 가능하다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TFn = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">interface</span> IFn &#123;</span><br><span class="line">  (x: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//단순한 함수 타입에서는 타입 별칭이 더 나은 선택일 수 있다.</span></span><br><span class="line"><span class="keyword">const</span> toStrT: TFn = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="string">''</span> + x; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> toStrI: IFn = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="string">''</span> + x; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<ul>
<li>타입을 확장할 수 있다. 단 interface는 주의사항이 몇 가지 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TState = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IStateWithPop <span class="keyword">extends</span> TState &#123;</span><br><span class="line">  population: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface는 유니온 타입과 같은 복잡한 타입을 확장하지 못한다.</span></span><br><span class="line"><span class="comment">// 확장하려면 아래와 같이 타입과 &amp;을 사용해야 한다.</span></span><br><span class="line"><span class="keyword">type</span> TStateWithPop = IState &amp; &#123; population: <span class="built_in">number</span> &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>class를 사용하면 type, interface 모두 사용 가능.</li>
</ul>
<h3 id="type-interface의-다른-점"><a href="#type-interface의-다른-점" class="headerlink" title="type, interface의 다른 점"></a><code>type</code>, <code>interface</code>의 다른 점</h3><ul>
<li>interface는 타입을 확장할 수 있고, 유니온은 할 수 없다. 유니온 타입은 있지만 유니온 인터페이스라는 개념은 없다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Input = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> Output = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input 타입과 Output 타입은 별도의 타입인데, VariableMap interface를 만들 수 있다.</span></span><br><span class="line"><span class="keyword">interface</span> VariableMap &#123;</span><br><span class="line">  [name: <span class="built_in">string</span>]: Input | Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//아래와 같이 유니온 타입에 name 속성을 붙인 타입을 만들 수도 있다.</span></span><br><span class="line"><span class="comment">//이 타입은 interface로 표현할 수 없다.</span></span><br><span class="line"><span class="keyword">type</span> NamedVariable = (Input | Output) &amp; &#123; name: <span class="built_in">string</span> &#125;;</span><br></pre></td></tr></table></figure>
<p><code>type</code> 키워드는 interface보다 쓰임새가 많은데, 유니온이 될 수도 있고, 매핑된 타입 또는 조건부 타입 같은 고급 기능에도 활용된다. 튜플과 배열 타입을 표현하는 것도 용이하다. interface로 튜플과 비슷하게 구현할 수 있지만 concat과 같은 메서드를 사용할 수 없다.</p>
<ul>
<li>interface는 보강이 가능하고, type은 그렇지 않다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  capital: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  population: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wyoming: IState = &#123;</span><br><span class="line">  name: <span class="string">'Wyoming'</span>,</span><br><span class="line">  capital: <span class="string">'Cheyenne'</span>,</span><br><span class="line">  population: <span class="number">500</span>_000,</span><br><span class="line">&#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>위 예제에서 속싱이 확장되었는데 이를 <code>선언 병합(declaration merging)</code>라고 한다. 선언 병합은 주로 타입 선언 파일에 사용횐다. <em>즉 타입 선언 파일을 작성할 때는 선언 병합을 지원하기 위해 반드시 interface를 사용해야 한다.</em></p>
<h3 id="type-interface를-언제-써야하는가"><a href="#type-interface를-언제-써야하는가" class="headerlink" title="type, interface를 언제 써야하는가?"></a><code>type</code>, <code>interface</code>를 언제 써야하는가?</h3><ul>
<li>타입 선언 파일 뿐 아니라 일반적인 코드에서도 병합이 지원된다. 따라서 보강이 있는 경우는 interface, 기존 타입에 추가 보강이 없는 경우는 type을 쓴다.</li>
<li>복잡한 타입은 타입 별칭을 사용한다.</li>
<li>type, interface 두 가지 모두로 표현할 수 있는 간단한 객체 타입이라면?<ul>
<li>일관성과 보강의 관점을 고려해 본다.</li>
<li>코드베이스에서 일관되게 type을 쓰고 있다면 type을, interface를 쓰고 있다면 interface를 쓴다.</li>
<li>API에 대한 타입 선언은 API가 변경될 때 사용자가 interface를 통해 새로운 필드를 병합할 수 있으니 interface를 쓴다. 단, 프로젝트 내부적으로 사용되는 타입에 선언 병합이 발생하는 것은 잘못된 설계이며, 이럴 때는 type을 쓴다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="아이템-14-타입-연산과-제너릭-사용으로-반복-줄이기"><a href="#아이템-14-타입-연산과-제너릭-사용으로-반복-줄이기" class="headerlink" title="아이템 14 타입 연산과 제너릭 사용으로 반복 줄이기"></a>아이템 14 타입 연산과 제너릭 사용으로 반복 줄이기</h2><p>코드를 작성할 때 코드를 반복하지 말라는 DRY(don’t repeat yourself)원칙에 따라 코드 중복을 제거하려고 노력하는 사람도 타입에 대해 간과하기 쉽다. 그 이유는 중복을 제거하는 매커니즘이 기존 코드에 대해 행하던 것에 비해 익숙치 않기 때문이다. 그러나 타입의 중복도 많은 문제를 일으키기 때문에 중복을 최소화해야 한다.</p>
<h3 id="반복을-줄이는-방법"><a href="#반복을-줄이는-방법" class="headerlink" title="반복을 줄이는 방법"></a>반복을 줄이는 방법</h3><ul>
<li><code>타입에 이름을 붙인다.</code> 아래 예시에서 파라미터 a, b에 반복되는 타입인 <code>{ x: number; y: number }</code>은 Point2D interface로 이름을 붙여서 중복을 제거하였다. 몇몇 함수가 같은 타입 시그니처를 공유한다고 할 때도 해당 시그니처를 명명된 타입으로 본리할 수 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">a: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;, b: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(a.x - b.x, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">a: Point2D, b: Point2D</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>interface를 사용할 경우, 한 interface가 다른 interface를 확장하게 해서 반복을 제거한다.</code></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  lastName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PersonWithBirthDate <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  birth: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>이미 존재하는 타입을 확장한다면 intersection 연산자(&amp;)을 쓴다.</code> 단, 일반적이지는 않다. 주로 확장할 수 없는 유니온 타입에 속성을 추가하려고 할 때 유용한 방법이다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  lastName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PersonWithBirthDate = Person &amp; &#123; birth: <span class="built_in">Date</span> &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>매핑된 타입</code>을 사용한다.<br>아래 예시에서 State는 전체 어플리케이션의 상태, TopNavState는 부분만 표현하는 상태라고 하고, 어떻게 매핑된 타입을 사용하는지 살펴보자. TopNavState를 확장해서 State를 구성할 수도 있지만, 의미상 State의 TopNavState를 정의하는 것이 바람직 할 것이다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">  userId: <span class="built_in">string</span>;</span><br><span class="line">  pageTitle: <span class="built_in">string</span>;</span><br><span class="line">  recentFiles: <span class="built_in">string</span>[];</span><br><span class="line">  pageContents: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> TopNavState &#123;</span><br><span class="line">  userId: <span class="built_in">string</span>;</span><br><span class="line">  pageTitle: <span class="built_in">string</span>;</span><br><span class="line">  recentFiles: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>아래 예시에서 1️⃣은 의미상 TopNavState를 State의 부분 집합이 되도록 작성하기 위해 State를 인덱싱해서 속성의 타입에 중복을 제거하였다. 이렇게 하면 State에 있는 속성의 타입이 바뀌더라도 잘 반영된다. 하지만 여전히 반복되는 코드가 있기 때문에 <strong>2️⃣와 같이 매핑된 타입을 사용한다.</strong> 매핑된 타입은 배열의 필드를 루프 도는 것과 같은 방식이다. 표준 라이브러리에서는 <code>Pick</code>이라 한다. Pick은 제너릭 타입이며, 3️⃣과 같이 사용한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ - 인덱싱하여 중복제거</span></span><br><span class="line"><span class="keyword">type</span> TopNavState = &#123;</span><br><span class="line">  userId: State[<span class="string">'userId'</span>];</span><br><span class="line">  pageTitle: State[<span class="string">'pageTitle'</span>];</span><br><span class="line">  recentFiles: State[<span class="string">'recentFiles'</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ - 매핑된 타입 사용</span></span><br><span class="line"><span class="keyword">type</span> TopNavState = &#123;</span><br><span class="line">  [k <span class="keyword">in</span> <span class="string">'userId'</span> | <span class="string">'pageTitle'</span> | <span class="string">'recentFiles'</span>]: State[k];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3️⃣ - Pick 사용</span></span><br><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123; [k <span class="keyword">in</span> K]: T[k] &#125;; <span class="comment">// Pick의 정의</span></span><br><span class="line"><span class="comment">//만약 Pick에 잘못된 키를 넣으면 오류가 발생한다.</span></span><br><span class="line"><span class="keyword">type</span> TopNavState = Pick&lt;State, <span class="string">'userId'</span> | <span class="string">'pageTitle'</span> | <span class="string">'recentFiles'</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>태그된 유니온에서 중복이 발생하면 어떻게 할 수 있을까? 아래 예시에서 ‘save’,’load’가 중복된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SaveAction &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'save'</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> LoadAction &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'load'</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Action = SaveAction | LoadAction;</span><br></pre></td></tr></table></figure>
<p>위와 같이 중복이 발생할 때는 Action 유니온을 인덱싱하여 ActionType을 정의한다. 이제 Action에 타입이 더 추가되더라도 ActionType은 자동으로 그 타입을 포함하게 된다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ActionType = Action[<span class="string">'type'</span>]; <span class="comment">// Type is "save" | "load"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Pick을 사용하여 type 속성을 가지는 interface와 인덱싱을 사용하는 방법은 다르다.</span></span><br><span class="line"><span class="keyword">type</span> ActionRec = Pick&lt;Action, <span class="string">'type'</span>&gt;; <span class="comment">// &#123;type: "save" | "load"&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>매핑된 타입과 keyof를 사용한다.</code> 아래와 같이 생성한 후 업데이트가 되는 클래스를 정의할 때를 가정해본다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">  width: <span class="built_in">number</span>;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> OptionsUpdate &#123;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">  height?: <span class="built_in">number</span>;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  label?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> UIWidget &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">init: Options</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  update(options: OptionsUpdate) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이때 매핑된 타입과 keyof를 사용하여 OptionsUpdate를 만든다.</p>
<ul>
<li>keyof는 타입을 받아서 속성 타입의 유니온을 반환한다.</li>
<li>매핑된 타입[k in keyof Options]은 순회하며 Options 내 k 값에 해당하는 속성이 있는지 찾는다.</li>
<li><code>?</code>는 속성을 선택적으로 만드는데 표준 라이브러리에는 <code>Partial</code>이라는 이름으로 포함되어 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OptionsUpdate = &#123; [k <span class="keyword">in</span> keyof Options]?: Options[k] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OptionsKeys = keyof Options;</span><br><span class="line"><span class="comment">// Type is "width" | "height" | "color" | "label"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>typeof</code>를 사용한다. 값의 형태에 해당하는 타입을 정의하고 싶을 때 사용하는 방법이다. 자바스트립트의 typeof처럼 보이지만 실제로는 타입스크립트 단계에서 연산된다. 단, 값으로부터 타입을 만들어 낼 때 <em>선언의 순서에 주의한다.</em> 타입 정의 후 값이 그 타입에 할당 가능하다고 선언하는 것이 명확하고, 예상하기 어려운 타입 변동을 방지할 수 있다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> INIT_OPTIONS = &#123;</span><br><span class="line">  width: <span class="number">640</span>,</span><br><span class="line">  height: <span class="number">480</span>,</span><br><span class="line">  color: <span class="string">'#00FF00'</span>,</span><br><span class="line">  label: <span class="string">'VGA'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">  width: <span class="built_in">number</span>;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Options = <span class="keyword">typeof</span> INIT_OPTIONS;</span><br></pre></td></tr></table></figure>
<ul>
<li>함수나 메서드의 반환 값에 명명된 타입을 만들고 싶다면 <code>ReturnType</code>을 사용한다. <em>아래 예시에서 <code>ReturnType</code>은 함수의 <code>값</code>인 getUserInfo가 아닌 typeof getUserInfo에 적용되었다.</em></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> INIT_OPTIONS = &#123;</span><br><span class="line">  width: <span class="number">640</span>,</span><br><span class="line">  height: <span class="number">480</span>,</span><br><span class="line">  color: <span class="string">'#00FF00'</span>,</span><br><span class="line">  label: <span class="string">'VGA'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">userId: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// COMPRESS</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">'Bob'</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">const</span> height = <span class="number">48</span>;</span><br><span class="line">  <span class="keyword">const</span> weight = <span class="number">70</span>;</span><br><span class="line">  <span class="keyword">const</span> favoriteColor = <span class="string">'blue'</span>;</span><br><span class="line">  <span class="comment">// END</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    userId,</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    height,</span><br><span class="line">    weight,</span><br><span class="line">    favoriteColor,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Return type inferred as &#123; userId: string; name: string; age: number, ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo = ReturnType&lt;<span class="keyword">typeof</span> getUserInfo&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>제너릭 타입을 사용한다.</code> 제너릭 타입은 타입을 위한 함수와 같다. 다만 함수에서 매개변수로 매핑할 수 있는 값을 제한하기 위해 타입 시스템을 사용하는 것처럼 매개변수를 제한할 수 있는 방법이 필요하다. 제너릭 타입에서 그 방법은 <code>extends</code>를 사용하는 것이다. 이는 제너릭 매개변수가 특정 타입을 확장한다고 선언할 수 있게 한다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Name &#123;</span><br><span class="line">  first: <span class="built_in">string</span>;</span><br><span class="line">  last: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> DancingDuo&lt;T <span class="keyword">extends</span> Name&gt; = [T, T];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> couple1: DancingDuo&lt;Name&gt; = [</span><br><span class="line">  &#123; first: <span class="string">'Fred'</span>, last: <span class="string">'Astaire'</span> &#125;,</span><br><span class="line">  &#123; first: <span class="string">'Ginger'</span>, last: <span class="string">'Rogers'</span> &#125;,</span><br><span class="line">]; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;first:string&#125;은 Name을 확장하지 않기 때문에 오류 발생</span></span><br><span class="line"><span class="keyword">const</span> couple2: DancingDuo&lt;&#123; first: <span class="built_in">string</span> &#125;&gt; = [</span><br><span class="line">  <span class="comment">// ~~~~~~~~~~~~~~~</span></span><br><span class="line">  <span class="comment">// Property 'last' is missing in type</span></span><br><span class="line">  <span class="comment">// '&#123; first: string; &#125;' but required in type 'Name'</span></span><br><span class="line">  &#123; first: <span class="string">'Sonny'</span> &#125;,</span><br><span class="line">  &#123; first: <span class="string">'Cher'</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-15-동적-데이터에-인덱스-시그니처-사용하기"><a href="#아이템-15-동적-데이터에-인덱스-시그니처-사용하기" class="headerlink" title="아이템 15 동적 데이터에 인덱스 시그니처 사용하기"></a>아이템 15 동적 데이터에 인덱스 시그니처 사용하기</h2><p>자바스크립트는 객체를 생성하는 문법이 간단하고, 문자열 키를 타입의 값에 관계없이 매핑할 수 있다. <em>타입스크립트에서는 타입에 <code>인덱스 시그니처</code>를 명시하여 유연하게 매핑을 표현할 수 있다.</em></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1️⃣ 인덱스 시그니처</span></span><br><span class="line"><span class="keyword">type</span> Rocket = &#123; [property: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> rocket: Rocket = &#123;</span><br><span class="line">  name: <span class="string">'Falcon 9'</span>,</span><br><span class="line">  variant: <span class="string">'v1.0'</span>,</span><br><span class="line">  thrust: <span class="string">'4,940 kN'</span>,</span><br><span class="line">&#125;; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2️⃣ 인터페이스</span></span><br><span class="line"><span class="keyword">interface</span> Rocket &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  variant: <span class="built_in">string</span>;</span><br><span class="line">  thrust_kN: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> falconHeavy: Rocket = &#123;</span><br><span class="line">  name: <span class="string">'Falcon Heavy'</span>,</span><br><span class="line">  variant: <span class="string">'v1'</span>,</span><br><span class="line">  thrust_kN: <span class="number">15</span>_200,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>위 예제 1️⃣에서 <code>[property: string]: string</code>이 인덱스 시그니처이다.</p>
<ul>
<li>키의 이름: 키의 위치만 표시. 타입 체커에서는 사용하지 않는다.</li>
<li>키의 타입: string이나 number 또는 symbol의 조합이어야 하지만 보통 string을 사용한다.</li>
<li>값의 타입: 어떤 것이든 가능하다.</li>
</ul>
<p>그러나 인덱스 시그니처는 타입 체크 수행 시 아래와 같은 단점을 가진다.</p>
<ul>
<li>잘못된 키를 포함한 모든 키를 허용 (name이 아닌 Name도 유효한 Rocket의 타입)</li>
<li>특정 키가 필요하지 않아. ({}도 유효한 Rocket의 타입)</li>
<li>키마다 다른 타입을 가질 수 없다. (thrust만 number일 수도 있는데 그렇게 사용할 수 없다.)</li>
<li>키는 무엇이든 가능하기 때문에 언어서비스(자동 완성 기능)이 제대로 동작하지 않는다.</li>
</ul>
<p>이런 부정확한 부분을 개선하기 위해 2️⃣와 같이 <code>인터페이스</code>로 작성한다.</p>
<h3 id="그렇다면-인덱스-시그니처는-어떤-상황에서-사용해야-할까"><a href="#그렇다면-인덱스-시그니처는-어떤-상황에서-사용해야-할까" class="headerlink" title="그렇다면 인덱스 시그니처는 어떤 상황에서 사용해야 할까?"></a>그렇다면 인덱스 시그니처는 어떤 상황에서 사용해야 할까?</h3><blockquote>
<p>동적 데이터를 표현할 때, 런타임 때가지 객체의 속성을 알 수 없을 경우</p>
</blockquote>
<p>예를 들어 CSV 파일처럼 행, 열에 이름이 있고 데이터 행을 열 이름과 값으로 매핑하는 객체로 나타내고 싶다면 인덱스 시그니처를 사용할 수 있다.</p>
<ul>
<li>열 이름이 무엇인지 모른다 -&gt; 인덱스 시그니처 사용</li>
<li>열 이름을 알고 있다 -&gt; 미리 선언해 둔 타입 사용. 단, 런타임에 실제로 일치하지 않을 수도 있으므로 undefined를 추가해서 나타낼 수 있다.</li>
<li>어떤 타입에 가능한 필드가 제한되어 있다(e.g. 데이터 상에 키를 알고 있는데, 그것이 얼마나 있는지 알 수 없다.) -&gt; 선택적 필드 또는 유니온 타입을 사용</li>
</ul>
<h3 id="string-타입이-너무-광범위해서-인덱스-시그니처를-사용하는-데-문제가-있다면"><a href="#string-타입이-너무-광범위해서-인덱스-시그니처를-사용하는-데-문제가-있다면" class="headerlink" title="string 타입이 너무 광범위해서 인덱스 시그니처를 사용하는 데 문제가 있다면?"></a>string 타입이 너무 광범위해서 인덱스 시그니처를 사용하는 데 문제가 있다면?</h3><ul>
<li>Record를 사용한다. 키 타입에 유연성을 제공하는 제너릭 타입으로 string의 부분 집합을 사용할 수 있다.</li>
<li>매핑된 타입을 사용한다. 키마다 별도의 타입을 사용하게 해준다.</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Record 사용</span></span><br><span class="line"><span class="keyword">type</span> Vec3D = Record&lt;<span class="string">'x'</span> | <span class="string">'y'</span> | <span class="string">'z'</span>, <span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="comment">// Type Vec3D = &#123;</span></span><br><span class="line"><span class="comment">//   x: number;</span></span><br><span class="line"><span class="comment">//   y: number;</span></span><br><span class="line"><span class="comment">//   z: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//매핑된 타입 사용</span></span><br><span class="line"><span class="keyword">type</span> Vec3D = &#123; [k <span class="keyword">in</span> <span class="string">'x'</span> | <span class="string">'y'</span> | <span class="string">'z'</span>]: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">// Same as above</span></span><br><span class="line"><span class="keyword">type</span> ABC = &#123; [k <span class="keyword">in</span> <span class="string">'a'</span> | <span class="string">'b'</span> | <span class="string">'c'</span>]: k <span class="keyword">extends</span> <span class="string">'b'</span> ? <span class="built_in">string</span> : <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">// Type ABC = &#123;</span></span><br><span class="line"><span class="comment">//   a: number;</span></span><br><span class="line"><span class="comment">//   b: string;</span></span><br><span class="line"><span class="comment">//   c: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-16-number-인덱스-시그니처보다는-Array-튜플-ArrayLike를-사용하기"><a href="#아이템-16-number-인덱스-시그니처보다는-Array-튜플-ArrayLike를-사용하기" class="headerlink" title="아이템 16 number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기"></a>아이템 16 number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기</h2><p>자바스크립트의 객체는 키/값 쌍의 모음인데, 키는 보통 문자열, 값은 어떤 것이든 될 수 있다. <em>그래서 숫자는 키로 사용할 수 없다.</em> 배열의 경우, 분명히 객체인데 숫자 인덱스를 사용하는 것이 당연하다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x[<span class="number">0</span>]; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">x[<span class="string">'1'</span>]; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(x); <span class="comment">//['0','1','2']</span></span><br></pre></td></tr></table></figure>
<p>배열에서 인덱스는 숫자타입이더라도 문자열로 변환되어 사용한다. 따라서 문자열 키를 사용해도 배열의 요소에 접근할 수 있다. Object.keys를 이용하여 배열의 키를 나열해보면 문자열로 구성되어 있음을 알 수 있다. <strong>타입스크립트는 이러한 혼란을 바로 잡기 위해서 숫자 키를 허용하고, 문자열 키와 다른 것으로 인식한다.</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for ~ in - 배열을 순회하는 방법이지만 좋은 방법은 아니다.</span></span><br><span class="line"><span class="keyword">const</span> xs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(xs); <span class="comment">// Type is string[]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> xs) &#123;</span><br><span class="line">  key; <span class="comment">// Type is string</span></span><br><span class="line">  <span class="keyword">const</span> x = xs[key]; <span class="comment">// Type is number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for ~ of - 인덱스에 신경쓰지 않는 경우</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x of xs) &#123;</span><br><span class="line">  x; <span class="comment">// Type is number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Array.prototype.forEach - 인덱스의 타입이 중요한 경우</span></span><br><span class="line">xs.forEach(<span class="function">(<span class="params">x, i</span>) =&gt;</span> &#123;</span><br><span class="line">  i; <span class="comment">// Type is number</span></span><br><span class="line">  x; <span class="comment">// Type is number</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//for - 루프 중간에 멈춰야 하는 경우</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; xs.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> x = xs[i];</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>타입이 불확실하면, for ~ in 루프는 for ~ of 루프에 비해 몇 배 느리다.</em> 여기서 for ~ in, for ~ of는 둘 다 반복문인데, for ~ in은 반복가능한 객체를 순환하고, for ~ of는 배열 요소를 탐색한다. 두 가지가 다른점은 for ~ in의 대상이 되는 객체는 이터러블이 아니므로 객체에 대해서 for ~ of를 사용하면 에러가 발생한다는 것이고, for ~ in의 대상이 되는 배열의 경우 이터러블한 객체여서 for~of를 적용해도 에러가 발생하지 않는다. 다만 배열에 대해 for ~ in을 사용하면 객체의 키 값에 해당하는 인덱스가 나오고, for ~ of를 쓰면 해당요소가 나온다는 점이 다르다.</p>
<p>배열은 인덱스 시그니처가 number로 표현되어 있다면 입력한 값이 number여야 한다는 것을 의미하지만 실제 런타임에 사용되는 키는 string타입이다. 그러나 일반적으로 string 대신 number를 타입의 인덱스 시그니처로 사용할 이유는 많지 않다. <em>만약 숫자를 사용하여 인덱스할 항목을 지정한다면 Array 또는 튜플 타입을 사용한다.</em> number를 인덱스로 쓰면 어떤 특별한 의미를 지닌다는 오해를 불러 일으킬 수 있다. 그리고, 어떤 길이를 가지는 배열과 비슷한 형태의 튜플을 사용하고 싶다면 타입스크립트에 있는 ArrayLike 타입을 사용한다. 단, ArrayLike를 사용해도 키는 여전히 문자열이다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkedAccess</span>&lt;<span class="title">T</span>&gt;(<span class="params">xs: ArrayLike&lt;T&gt;, i: <span class="built_in">number</span></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; xs.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> xs[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Attempt to access <span class="subst">$&#123;i&#125;</span> which is past end of array.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="아이템-17-변경-관련된-오류-방지를-위해-readonly-사용하기"><a href="#아이템-17-변경-관련된-오류-방지를-위해-readonly-사용하기" class="headerlink" title="아이템 17 변경 관련된 오류 방지를 위해 readonly 사용하기"></a>아이템 17 변경 관련된 오류 방지를 위해 readonly 사용하기</h2><p>아래 예제에서 1️⃣은 계산이 끝나면 원래 배열이 전부 비게 되는데도, 자바스크립트는 배열의 내용을 변경할 수 있기 때문에 타입스크립트에서 오류 없이 통과한다. 그래서 오류의 범위는 좁히기 위해 readonly 접근 제어자를 사용한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1️⃣</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraySum</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>,</span><br><span class="line">    num;</span><br><span class="line">  <span class="keyword">while</span> ((num = arr.pop()) !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    sum += num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraySum</span>(<span class="params">arr: readonly <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>,</span><br><span class="line">    num;</span><br><span class="line">  <span class="keyword">while</span> ((num = arr.pop()) !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// ~~~ 'pop' does not exist on type 'readonly number[]'</span></span><br><span class="line">    sum += num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 예제에서 2️⃣의 readonly number[]는 타입이다. 특징은 아래와 같다.</p>
<ul>
<li>배열의 요소를 읽을 수 있지만, 쓸 수는 없다.</li>
<li>length를 읽을 수 있지만, 바꿀 수 없다.</li>
<li>배열을 변경하는 pop을 비롯한 다른 메서드를 호출할 수 없다.</li>
<li>변경 가능한 배열을 readonly 배열에 할당할 수 있다. 하지만 그 반대는 불가하다.</li>
</ul>
<p>매개변수를 readonly로 선언하면 특징은 다음과 같다.</p>
<ul>
<li>타입스크립트는 매개변수가 함수 내에서 변경이 일어나는지 체크한다.</li>
<li>호출하는 쪽에서 함수가 매개변수를 변경하지 않는다는 보장을 받게 된다.</li>
<li>호출하는 쪽에서 함수에 readonly 배열을 매개변수에 넣을 수 있다.</li>
<li>함수가 매개변수를 변경하지 않는다면, readonly로 선언한다.</li>
<li>readonly는 <code>얕게(shallow)</code> 동작하므로 만약 객체의 readonly 배열이 있다면 객체 자체는 readonly가 아니다.</li>
</ul>
<hr>
<h2 id="아이템-18-매핑된-타입을-사용하여-값을-동기화하기"><a href="#아이템-18-매핑된-타입을-사용하여-값을-동기화하기" class="headerlink" title="아이템 18 매핑된 타입을 사용하여 값을 동기화하기"></a>아이템 18 매핑된 타입을 사용하여 값을 동기화하기</h2><p>다음은 타입 체커가 동작하도록 개선한 코드인데, <em>핵심은 매핑된 타입과 객체를 사용하는 것이다.</em> <code>[k in keyof ScatterProps]</code>는 타입 체커에게 REQUIRES_UPDATE가 ScatterProps와 동일한 속성을 가져야 한다는 정보를 제공한다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ScatterProps &#123;</span><br><span class="line">  <span class="comment">// The data</span></span><br><span class="line">  xs: <span class="built_in">number</span>[];</span><br><span class="line">  ys: <span class="built_in">number</span>[];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Display</span></span><br><span class="line">  xRange: [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line">  yRange: [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Events</span></span><br><span class="line">  onClick: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span>, index: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> REQUIRES_UPDATE: &#123; [k <span class="keyword">in</span> keyof ScatterProps]: <span class="built_in">boolean</span> &#125; = &#123;</span><br><span class="line">  xs: <span class="literal">true</span>,</span><br><span class="line">  ys: <span class="literal">true</span>,</span><br><span class="line">  xRange: <span class="literal">true</span>,</span><br><span class="line">  yRange: <span class="literal">true</span>,</span><br><span class="line">  color: <span class="literal">true</span>,</span><br><span class="line">  onClick: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldUpdate</span>(<span class="params">oldProps: ScatterProps, newProps: ScatterProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> k: keyof ScatterProps;</span><br><span class="line">  <span class="keyword">for</span> (k <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldProps[k] !== newProps[k] &amp;&amp; REQUIRES_UPDATE[k]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><em>References</em><br>[이펙티브 타입스크립트] 댄 밴더캄 지음</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2022/01/03/220104_rtkCreatApi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/03/220104_rtkCreatApi/" class="post-title-link" itemprop="url">RTK Query - createApi</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-04 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-04T00:00:00+09:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-21 23:10:05" itemprop="dateModified" datetime="2022-03-21T23:10:05+09:00">2022-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RTK-Query"><a href="#RTK-Query" class="headerlink" title="RTK Query"></a>RTK Query</h1><blockquote>
<p>원문링크: <a href="https://redux-toolkit.js.org/rtk-query/api/createApi" target="_blank" rel="noopener">https://redux-toolkit.js.org/rtk-query/api/createApi</a></p>
</blockquote>
<p><strong>createApi는 RTK Query의 핵심이다.</strong> 이를 통해 해당하는 데이터를 가져오고 변환하는 방법을 구성하는 것을 포함하여 일련의 엔드포인트들로부터 데이터를 어떻게 회수(검색)해야하는 지에 대해 일련의 엔드포인트에 대한 방법을 정의할 수 있다. createApi는 여기에 캡슐화된 데이터 fetching와 caching 프로세스는 포함하는 Redux 로직(옵셔널한 React hooks)이 담겨있는 <a href="https://redux-toolkit.js.org/rtk-query/api/created-api/overview" target="_blank" rel="noopener">API slice structure</a>를 생성한다.</p>
<p>💡 일반적으로 어플리케이션이 통신해야 하는 base URL 하나 당 하나의 API slice만 있어야 한다. 예를 들어 당신의 사이트가 /api/posts와 /api/users 모두에서 데이터를 fetch한다면 /api/를 base URL로 가지는 single API slice를 가지고 있고, posts와 users로 엔드포인트 정의를 분할했을 것이다. 이렇게 하면 엔드포인트에서 <a href="https://redux-toolkit.js.org/rtk-query/usage/automated-refetching#tags" target="_blank" rel="noopener">태그</a> 관계를 정의해서 <a href="https://redux-toolkit.js.org/rtk-query/usage/automated-refetching" target="_blank" rel="noopener">자동화된 re-fetching</a>의 이점을 효과적으로 사용할 수 있다.</p>
<p>유지(maintainability)의 목적을 위해 모든 엔드포인트를 포한하는 single API slice를 유지하면서 여러 파일에 걸쳐 endpoint 정의를 분할해서 사용할 수 있다. injectEndpoints 속성을 사용하여 다른 파일의 엔드포인트를 <a href="https://redux-toolkit.js.org/rtk-query/usage/code-splitting" target="_blank" rel="noopener">code splitting</a>을 하는 방법은 <a href="https://redux-toolkit.js.org/rtk-query/usage/code-splitting" target="_blank" rel="noopener">code splitting</a>을 참조한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example: src/services/pokemon.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// React hook의 생성을 허용하려면 React의 특정 엔트리포인트를 사용해야 한다.</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApi, fetchBaseQuery &#125; <span class="keyword">from</span> <span class="string">'@reduxjs/toolkit/query/react'</span></span><br><span class="line"><span class="keyword">import</span> type &#123; Pokemon &#125; <span class="keyword">from</span> <span class="string">'./types'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// baseURL과 엔드포인트를 사용하여 서비스를 정의한다.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> pokemonApi = createApi(&#123;</span><br><span class="line">  reducerPath: <span class="string">'pokemonApi'</span>,</span><br><span class="line">  baseQuery: fetchBaseQuery(&#123; <span class="attr">baseUrl</span>: <span class="string">'https://pokeapi.co/api/v2/'</span> &#125;),</span><br><span class="line">  endpoints: <span class="function">(<span class="params">builder</span>) =&gt;</span> (&#123;</span><br><span class="line">    getPokemonByName: builder.query&lt;Pokemon, string&gt;(&#123;</span><br><span class="line">      query: <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`pokemon/<span class="subst">$&#123;name&#125;</span>`</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 컴포넌트에서 사용하기 위해 hooks를 export하고,</span></span><br><span class="line"><span class="comment">// 엔드포인트가 정의된 곳에 기반하여 자동 생성되도록 한다.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; useGetPokemonByNameQuery &#125; = pokemonApi</span><br></pre></td></tr></table></figure>
<h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p>createApi는 아래와 같은 옵션이 있는 단을 구성 객체(single configuration object)를 받아들인다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">baseQuery(args: InternalQueryArgs, <span class="attr">api</span>: BaseQueryApi, extraOptions?: DefinitionExtraOptions): any;</span><br><span class="line">  endpoints(build: EndpointBuilder&lt;InternalQueryArgs, TagTypes&gt;): Definitions;</span><br><span class="line">  extractRehydrationInfo?: (</span><br><span class="line">    action: AnyAction,</span><br><span class="line">    &#123;</span><br><span class="line">      reducerPath,</span><br><span class="line">    &#125;: &#123;</span><br><span class="line">      reducerPath: ReducerPath</span><br><span class="line">    &#125;</span><br><span class="line">  ) =&gt;</span><br><span class="line">    | <span class="literal">undefined</span></span><br><span class="line">    | CombinedState&lt;Definitions, TagTypes, ReducerPath&gt;</span><br><span class="line">  tagTypes?: readonly TagTypes[];</span><br><span class="line">  reducerPath?: ReducerPath;</span><br><span class="line">  serializeQueryArgs?: SerializeQueryArgs&lt;InternalQueryArgs&gt;;</span><br><span class="line">  keepUnusedDataFor?: number; <span class="comment">// value is in seconds</span></span><br><span class="line">  refetchOnMountOrArgChange?: boolean | number; <span class="comment">// value is in seconds</span></span><br><span class="line">  refetchOnFocus?: boolean;</span><br><span class="line">  refetchOnReconnect?: boolean;</span><br></pre></td></tr></table></figure>
<h2 id="baseQuery"><a href="#baseQuery" class="headerlink" title="baseQuery"></a>baseQuery</h2><p>base query는 <code>queryFn</code> 옵션이 특정되지 않은 경우에 각 endpoint에서 사용된다. RTK Query는 <a href="https://redux-toolkit.js.org/rtk-query/api/fetchBaseQuery" target="_blank" rel="noopener">fetchBaseQuery</a>라고 불리는 유틸리티로 일반적인 사용 케이스에서 fetch를 감싸는 경량 wrapper로써 export된다. 만약 fetchBaseQuery가 요구 사항을 처리할 수 없는 경우에 <a href="https://redux-toolkit.js.org/rtk-query/usage/customizing-queries" target="_blank" rel="noopener">Customizing Queries</a>를 참조하도록 한다.</p>
<p><strong>baseQuery function arguments</strong></p>
<ul>
<li>args: 주어진 endpoint에 대한 query 함수의 반환값</li>
<li>api - signal, dispatch, getState, extra 속성을 포함하는 BaseQueryApi 객체<ul>
<li>singal: Dom 요청을 중단하거나 요청이 중단되었는지 여부를 읽어들이는 데 사용할 수 있는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal" target="_blank" rel="noopener">AbortSignal</a> 객체</li>
<li>dispatch: Redux store와 대응하게 하는 <code>store.dispatch</code> 매서드</li>
<li>getState: 현재의 store 상태에 접근하기 위해 호출될 수 있는 함수</li>
<li>extra: configureStore getDefaultMiddleware option에 thunk.extraArgument로 제공된다.</li>
</ul>
</li>
<li>extraOptions: 주어진 endpoint를 위해 제공되는 선택적 extraOptions의 값</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base Query signature</span></span><br><span class="line"><span class="keyword">export</span> type BaseQueryFn&lt;</span><br><span class="line">  Args = any,</span><br><span class="line">  Result = unknown,</span><br><span class="line">  <span class="built_in">Error</span> = unknown,</span><br><span class="line">  DefinitionExtraOptions = &#123;&#125;,</span><br><span class="line">  Meta = &#123;&#125;</span><br><span class="line">&gt; = (</span><br><span class="line">  args: Args,</span><br><span class="line">  api: BaseQueryApi,</span><br><span class="line">  extraOptions: DefinitionExtraOptions</span><br><span class="line">) =&gt; MaybePromise&lt;QueryReturnValue&lt;Result, <span class="built_in">Error</span>, Meta&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface BaseQueryApi &#123;</span><br><span class="line">  signal: AbortSignal</span><br><span class="line">  dispatch: ThunkDispatch&lt;any, any, any&gt;</span><br><span class="line">  getState: <span class="function"><span class="params">()</span> =&gt;</span> unknown</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type QueryReturnValue&lt;T = unknown, E = unknown, M = unknown&gt; =</span><br><span class="line">  | &#123;</span><br><span class="line">      error: E</span><br><span class="line">      data?: <span class="literal">undefined</span></span><br><span class="line">      meta?: M</span><br><span class="line">    &#125;</span><br><span class="line">  | &#123;</span><br><span class="line">      error?: <span class="literal">undefined</span></span><br><span class="line">      data: T</span><br><span class="line">      meta?: M</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="endpoints"><a href="#endpoints" class="headerlink" title="endpoints"></a>endpoints</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApi, fetchBaseQuery &#125; <span class="keyword">from</span> <span class="string">'@reduxjs/toolkit/query'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = createApi(&#123;</span><br><span class="line">  baseQuery: fetchBaseQuery(&#123; <span class="attr">baseUrl</span>: <span class="string">'/'</span> &#125;),</span><br><span class="line">  endpoints: <span class="function"><span class="params">build</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">// ...endpoints</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>endpoints는 서버에 대해 수행하려는 작업들의 집합이다. builder syntax를 사용해서 객체로 정의한다. 여기에는 <code>query, mutaion</code> 의 두 가지 기본적인 엔드포인트 유형이 있다.</p>
<p>각 속성에 대한 세부내용이 궁금하여 <a href="https://redux-toolkit.js.org/rtk-query/api/createApi#anatomy-of-an-endpoint" target="_blank" rel="noopener">다음의 링크</a>를 참조한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Query endpoint definition</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type QueryDefinition&lt;</span><br><span class="line">  QueryArg,</span><br><span class="line">  BaseQuery extends BaseQueryFn,</span><br><span class="line">  TagTypes extends string,</span><br><span class="line">  ResultType,</span><br><span class="line">  ReducerPath extends string = string</span><br><span class="line">&gt; = &#123;</span><br><span class="line">  query(arg: QueryArg): BaseQueryArg&lt;BaseQuery&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* either `query` or `queryFn` can be present, but not both simultaneously */</span></span><br><span class="line">  queryFn(</span><br><span class="line">    arg: QueryArg,</span><br><span class="line">    api: BaseQueryApi,</span><br><span class="line">    extraOptions: BaseQueryExtraOptions&lt;BaseQuery&gt;,</span><br><span class="line">    baseQuery: <span class="function">(<span class="params">arg: Parameters&lt;BaseQuery&gt;[<span class="number">0</span>]</span>) =&gt;</span> ReturnType&lt;BaseQuery&gt;</span><br><span class="line">  ): MaybePromise&lt;QueryReturnValue&lt;ResultType, BaseQueryError&lt;BaseQuery&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* transformResponse only available with `query`, not `queryFn` */</span></span><br><span class="line">  transformResponse?(</span><br><span class="line">    baseQueryReturnValue: BaseQueryResult&lt;BaseQuery&gt;,</span><br><span class="line">    meta: BaseQueryMeta&lt;BaseQuery&gt;,</span><br><span class="line">    arg: QueryArg</span><br><span class="line">  ): ResultType | <span class="built_in">Promise</span>&lt;ResultType&gt;</span><br><span class="line"></span><br><span class="line">  extraOptions?: BaseQueryExtraOptions&lt;BaseQuery&gt;</span><br><span class="line"></span><br><span class="line">  providesTags?: ResultDescription&lt;</span><br><span class="line">    TagTypes,</span><br><span class="line">    ResultType,</span><br><span class="line">    QueryArg,</span><br><span class="line">    BaseQueryError&lt;BaseQuery&gt;</span><br><span class="line">  &gt;</span><br><span class="line"></span><br><span class="line">  keepUnusedDataFor?: number</span><br><span class="line"></span><br><span class="line">  onQueryStarted?(</span><br><span class="line">    arg: QueryArg,</span><br><span class="line">    &#123;</span><br><span class="line">      dispatch,</span><br><span class="line">      getState,</span><br><span class="line">      extra,</span><br><span class="line">      requestId,</span><br><span class="line">      queryFulfilled,</span><br><span class="line">      getCacheEntry,</span><br><span class="line">      updateCachedData, <span class="comment">// available for query endpoints only</span></span><br><span class="line">    &#125;: QueryLifecycleApi</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt;</span><br><span class="line"></span><br><span class="line">  onCacheEntryAdded?(</span><br><span class="line">    arg: QueryArg,</span><br><span class="line">    &#123;</span><br><span class="line">      dispatch,</span><br><span class="line">      getState,</span><br><span class="line">      extra,</span><br><span class="line">      requestId,</span><br><span class="line">      cacheEntryRemoved,</span><br><span class="line">      cacheDataLoaded,</span><br><span class="line">      getCacheEntry,</span><br><span class="line">      updateCachedData, <span class="comment">// available for query endpoints only</span></span><br><span class="line">    &#125;: QueryCacheLifecycleApi</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutation endpoint definition</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type MutationDefinition&lt;</span><br><span class="line">  QueryArg,</span><br><span class="line">  BaseQuery extends BaseQueryFn,</span><br><span class="line">  TagTypes extends string,</span><br><span class="line">  ResultType,</span><br><span class="line">  ReducerPath extends string = string,</span><br><span class="line">  Context = Record&lt;string, any&gt;</span><br><span class="line">&gt; = &#123;</span><br><span class="line">  query(arg: QueryArg): BaseQueryArg&lt;BaseQuery&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* either `query` or `queryFn` can be present, but not both simultaneously */</span></span><br><span class="line">  queryFn(</span><br><span class="line">    arg: QueryArg,</span><br><span class="line">    api: BaseQueryApi,</span><br><span class="line">    extraOptions: BaseQueryExtraOptions&lt;BaseQuery&gt;,</span><br><span class="line">    baseQuery: <span class="function">(<span class="params">arg: Parameters&lt;BaseQuery&gt;[<span class="number">0</span>]</span>) =&gt;</span> ReturnType&lt;BaseQuery&gt;</span><br><span class="line">  ): MaybePromise&lt;QueryReturnValue&lt;ResultType, BaseQueryError&lt;BaseQuery&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* transformResponse only available with `query`, not `queryFn` */</span></span><br><span class="line">  transformResponse?(</span><br><span class="line">    baseQueryReturnValue: BaseQueryResult&lt;BaseQuery&gt;,</span><br><span class="line">    meta: BaseQueryMeta&lt;BaseQuery&gt;,</span><br><span class="line">    arg: QueryArg</span><br><span class="line">  ): ResultType | <span class="built_in">Promise</span>&lt;ResultType&gt;</span><br><span class="line"></span><br><span class="line">  extraOptions?: BaseQueryExtraOptions&lt;BaseQuery&gt;</span><br><span class="line"></span><br><span class="line">  invalidatesTags?: ResultDescription&lt;TagTypes, ResultType, QueryArg&gt;</span><br><span class="line"></span><br><span class="line">  onQueryStarted?(</span><br><span class="line">    arg: QueryArg,</span><br><span class="line">    &#123;</span><br><span class="line">      dispatch,</span><br><span class="line">      getState,</span><br><span class="line">      extra,</span><br><span class="line">      requestId,</span><br><span class="line">      queryFulfilled,</span><br><span class="line">      getCacheEntry,</span><br><span class="line">    &#125;: MutationLifecycleApi</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt;</span><br><span class="line"></span><br><span class="line">  onCacheEntryAdded?(</span><br><span class="line">    arg: QueryArg,</span><br><span class="line">    &#123;</span><br><span class="line">      dispatch,</span><br><span class="line">      getState,</span><br><span class="line">      extra,</span><br><span class="line">      requestId,</span><br><span class="line">      cacheEntryRemoved,</span><br><span class="line">      cacheDataLoaded,</span><br><span class="line">      getCacheEntry,</span><br><span class="line">    &#125;: MutationCacheLifecycleApi</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>endpoints에 익숙해지는 방법</strong></p>
<p>아래와 같이 getPosts를 키로 정의할 때, 이 이름이 api로부터 export되고, api.endpoints.getPosts.useQuery(), api.endpoints.getPosts.initiate(), api.endpoints.getPosts.select() 아래에서 reference될 수 있다는 것을 아는 것이 중요하다. 비슷한 방식으로 mutaion에도 적용이 되는데 useQuery대신 useMutaion이 적용된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApi, fetchBaseQuery &#125; <span class="keyword">from</span> <span class="string">'@reduxjs/toolkit/query/react'</span></span><br><span class="line">interface Post &#123;</span><br><span class="line">  id: number</span><br><span class="line">  name: string</span><br><span class="line">&#125;</span><br><span class="line">type PostsResponse = Post[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = createApi(&#123;</span><br><span class="line">  baseQuery: fetchBaseQuery(&#123; <span class="attr">baseUrl</span>: <span class="string">'/'</span> &#125;),</span><br><span class="line">  tagTypes: [<span class="string">'Posts'</span>],</span><br><span class="line">  endpoints: <span class="function">(<span class="params">build</span>) =&gt;</span> (&#123;</span><br><span class="line">    getPosts: build.query&lt;PostsResponse, <span class="keyword">void</span>&gt;(&#123;</span><br><span class="line">      query: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'posts'</span>,</span><br><span class="line">      providesTags: <span class="function">(<span class="params">result</span>) =&gt;</span></span><br><span class="line">        result ? result.map(<span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> (&#123; <span class="attr">type</span>: <span class="string">'Posts'</span>, id &#125;)) : [],</span><br><span class="line">    &#125;),</span><br><span class="line">    addPost: build.mutation&lt;Post, Partial&lt;Post&gt;&gt;(&#123;</span><br><span class="line">      query: <span class="function">(<span class="params">body</span>) =&gt;</span> (&#123;</span><br><span class="line">        url: <span class="string">`posts`</span>,</span><br><span class="line">        method: <span class="string">'POST'</span>,</span><br><span class="line">        body,</span><br><span class="line">      &#125;),</span><br><span class="line">      invalidatesTags: [<span class="string">'Posts'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Auto-generated hooks</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; useGetPostsQuery, useAddPostMutation &#125; = api</span><br><span class="line"></span><br><span class="line"><span class="comment">// Possible exports</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; endpoints, reducerPath, reducer, middleware &#125; = api</span><br><span class="line"><span class="comment">// reducerPath, reducer, middleware are only used in store configuration</span></span><br><span class="line"><span class="comment">// endpoints will have:</span></span><br><span class="line"><span class="comment">// endpoints.getPosts.initiate(), endpoints.getPosts.select(), endpoints.getPosts.useQuery()</span></span><br><span class="line"><span class="comment">// endpoints.addPost.initiate(), endpoints.addPost.select(), endpoints.addPost.useMutation()</span></span><br><span class="line"><span class="comment">// see `createApi` overview for _all exports_</span></span><br></pre></td></tr></table></figure>
<h3 id="extractRehydrationInfo"><a href="#extractRehydrationInfo" class="headerlink" title="extractRehydrationInfo"></a>extractRehydrationInfo</h3><p>모든 디스패치된 액션에 전달되는 함수이다. 이것이 undefined 이외의 값을 반환하면 해당 반환 값은 성공하였거나 실패한 커리를 rehydrate하는데 사용된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next-redux-wrapper rehydration example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createApi, fetchBaseQuery &#125; <span class="keyword">from</span> <span class="string">'@reduxjs/toolkit/query/react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; HYDRATE &#125; <span class="keyword">from</span> <span class="string">'next-redux-wrapper'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> api = createApi(&#123;</span><br><span class="line">  baseQuery: fetchBaseQuery(&#123; <span class="attr">baseUrl</span>: <span class="string">'/'</span> &#125;),</span><br><span class="line">  extractRehydrationInfo(action, &#123; reducerPath &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (action.type === HYDRATE) &#123;</span><br><span class="line">      <span class="keyword">return</span> action.payload[reducerPath]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  endpoints: <span class="function"><span class="params">build</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">// omitted</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>See also <a href="https://redux-toolkit.js.org/rtk-query/usage/server-side-rendering" target="_blank" rel="noopener">Server Side Rendering</a> and <a href="https://redux-toolkit.js.org/rtk-query/usage/persistence-and-rehydration" target="_blank" rel="noopener">Persistence and Rehydration</a>.</p>
<h2 id="tagTypes"><a href="#tagTypes" class="headerlink" title="tagTypes"></a>tagTypes</h2><p>string tag type 이름들이 있는 배열이다. tag types를 지정하는 것은 선택적이나 caching과 invalidation에 사용하고 싶다면 정의해야 한다. tag type을 정의할 때, <code>providesTags</code> 와 함께 제공하고, <a href="https://redux-toolkit.js.org/rtk-query/api/createApi#endpoints" target="_blank" rel="noopener">endpoints</a>를 구성할 때 <code>invalidatesTags</code> 와 함께 <a href="https://redux-toolkit.js.org/rtk-query/usage/automated-refetching#invalidating-tags" target="_blank" rel="noopener">무효화</a>시킬 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApi, fetchBaseQuery &#125; <span class="keyword">from</span> <span class="string">'@reduxjs/toolkit/query'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = createApi(&#123;</span><br><span class="line">  baseQuery: fetchBaseQuery(&#123; <span class="attr">baseUrl</span>: <span class="string">'/'</span> &#125;),</span><br><span class="line">  tagTypes: [<span class="string">'Post'</span>, <span class="string">'User'</span>],</span><br><span class="line">  endpoints: <span class="function"><span class="params">build</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">// ...endpoints</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="reducerPath"><a href="#reducerPath" class="headerlink" title="reducerPath"></a>reducerPath</h3><p>서비스가 당신의 store에 장착될 수 있도록 하는 unique key이다. 당신의 어플리케이션에서 createApi를 한 번 이상 호출했다면 당신은 매번 unique한 value를 제공해야 하고, default는 api이다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApi, fetchBaseQuery &#125; <span class="keyword">from</span> <span class="string">'@reduxjs/toolkit/query'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apiOne = createApi(&#123;</span><br><span class="line">  reducerPath: <span class="string">'apiOne'</span>,</span><br><span class="line">  baseQuery: fetchBaseQuery(&#123; <span class="attr">baseUrl</span>: <span class="string">'/'</span> &#125;),</span><br><span class="line">  endpoints: <span class="function"><span class="params">builder</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">// ...endpoints</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apiTwo = createApi(&#123;</span><br><span class="line">  reducerPath: <span class="string">'apiTwo'</span>,</span><br><span class="line">  baseQuery: fetchBaseQuery(&#123; <span class="attr">baseUrl</span>: <span class="string">'/'</span> &#125;),</span><br><span class="line">  endpoints: <span class="function"><span class="params">builder</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">// ...endpoints</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<p><em>References</em><br><a href="https://redux-toolkit.js.org/rtk-query/api/createApi" target="_blank" rel="noopener">createApi</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2021/12/27/211228_substr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/27/211228_substr/" class="post-title-link" itemprop="url">문자열 자르기와 관련된 함수 (substr, substring, slice)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-28 00:00:00" itemprop="dateCreated datePublished" datetime="2021-12-28T00:00:00+09:00">2021-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-21 23:10:05" itemprop="dateModified" datetime="2022-03-21T23:10:05+09:00">2022-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h2><blockquote>
<p>💡 substr은 새로운 웹사이트에서는 더이상 사용되지 않는다. 웹 표준에서 제거된 것은 아니지만 다른 매서드로 대체하는 것이 바람직하다.</p>
</blockquote>
<p>문자열에서 특정 위치에서 시작하여 특정 문자 수 만큼의 문자들을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">// expected output: "el"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// expected output: "llo"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>str.substr(start[, length])<br>str.substr(시작위치의 인덱스, 추출한 문자의 length )</p>
</blockquote>
<ul>
<li>start 값이 양수이고, 문자열 전체 길이보다 크거나 같으면 빈 문자열을 반환한다.</li>
<li>start가 음수이면 문자열 끝에서 start 숫자만큼 뺀 곳에서 시작한다.</li>
<li>start가 음수이고, 절대값이 문자열 전체보다 크면 문자열의 0번째 인덱스부터 시작</li>
<li>length가 0 이거나 음수이면 빈 문자열 반환한다.</li>
<li>length가 생략되었다면 문자열의 끝까지 추출하여 반환한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'helloworld'</span></span><br><span class="line"></span><br><span class="line">str.substr(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 1번째 index에서 2개 추출</span></span><br><span class="line"><span class="comment">// expected output:'el'</span></span><br><span class="line">str.substr(<span class="number">-3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 전체 문자열 길이 10에서 -3만큼 뺀 곳에서 시작하여 2개 추출</span></span><br><span class="line"><span class="comment">// expected output:'rl'</span></span><br><span class="line">str.substr(<span class="number">-3</span>)</span><br><span class="line"><span class="comment">// start가 음수이므로 전체 문자열 길리 10에서 -3만큼 뺀 곳에서 시작,</span></span><br><span class="line"><span class="comment">// length는 생략되었으므로 문자열의 끝까지 추출</span></span><br><span class="line"><span class="comment">// expected output:'rld'</span></span><br><span class="line">str.substr(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 1번째 인덱스에서 시작하여 length는 생략되었으므로 문자열의 끝까지 추출</span></span><br><span class="line"><span class="comment">// expected output:'elloworld'</span></span><br><span class="line">str.substr(<span class="number">-20</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// start가 음수이고, 절대값이 문자열 전체보다 크면 문자열의 0번째 인덱스부터 시작하여 2개 추출</span></span><br><span class="line"><span class="comment">// expected output:'he'</span></span><br><span class="line">str.substr(<span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// start가 양수이나 문자열 전체 길이보다 크기 때문에 빈 문자열 반환</span></span><br><span class="line"><span class="comment">// expected output:''</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h2><p>시작 인덱스로 부터 종료 인덱스 전 까지 문자열의 부분 문자열을 반환</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// expected output: "el"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// expected output: "llo"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>str.substring(indexStart[, indexEnd])<br>str.substring(시작 인덱스, 마지막 인덱스(포함하지 않음))<br>return 값: 기존문자열의 부분 문자열</p>
</blockquote>
<ul>
<li>시작 인덱스부터 문자를 추출하여 <em>마지막 인덱스가 포함되지 않아도 된다.</em></li>
<li>indexEnd가 생략되었다면 문자열 끝까지 모든 문자를 추출한다.</li>
<li>indexStart, indexEnd가 같을 경우 빈 문자열을 반환한다.</li>
<li>indexStart가 indexEnd보다 클 경우 두 개의 인자를 바꾼 것처럼 작동한다.</li>
<li>0보다 작은 인자 값을 가지면 0, stringName.length보다 큰 인자값을 가지면 stringName.length로 처리된다.</li>
<li>NaN 값은 0으로 처리된다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> anyString = <span class="string">'helloworld'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Displays 'h'</span></span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//indexStart가 indexEnd보다 클 경우 substring(0, 1)처럼 두 개의 인자를 바꾼듯이 작동한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Displays 'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">0</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Displays 'world'</span></span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Displays 'wo'</span></span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">4</span>, <span class="number">7</span>))</span><br><span class="line"><span class="comment">//indexStart가 indexEnd보다 클 경우 substring(4, 7)처럼 두 개의 인자를 바꾼듯이 작동한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">7</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Displays 'helloworld'</span></span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment">//stringName.length보다 큰 인자값을 가지면 stringName.length로 처리된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(anyString.substring(<span class="number">0</span>, <span class="number">15</span>))</span><br></pre></td></tr></table></figure>
<h3 id="substring-와-length-속성을-같이-사용하기"><a href="#substring-와-length-속성을-같이-사용하기" class="headerlink" title="substring()와 length 속성을 같이 사용하기"></a>substring()와 length 속성을 같이 사용하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Displays 'orld' the last 4 characters</span></span><br><span class="line"><span class="keyword">const</span> anyString = <span class="string">'helloworld'</span></span><br><span class="line"><span class="keyword">const</span> anyString4 = anyString.substring(anyString.length - <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(anyString4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Displays 'world' the last 5 characters</span></span><br><span class="line"><span class="keyword">const</span> anyString = <span class="string">'helloworld'</span></span><br><span class="line"><span class="keyword">const</span> anyString5 = anyString.substring(anyString.length - <span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(anyString5)</span><br></pre></td></tr></table></figure>
<p>substring 메서드와 length 송성을 사용하여 특정 문자열의 마지막 문자를 추출할 수 있다. 이 방법을 사용하면 <code>anyString.substring(4, 7)</code>과 같이 시작인덱스와 마지막인덱스를 알지 않아도 된다.</p>
<h3 id="substring-와-substr-의-차이점"><a href="#substring-와-substr-의-차이점" class="headerlink" title="substring()와 substr()의 차이점"></a>substring()와 substr()의 차이점</h3><p><strong>substring()와 substr()에는 미묘한 차이가 있으므로 주의해야 한다.</strong> substring()은 시작과 마지막 인덱스를 의미하는데, substr()은 시작인덱스와 반환된 문자열에 포함할 문자 수를 나타낸다.</p>
<ul>
<li>str.substring(indexStart[, indexEnd])</li>
<li>str.substr(start[, length])</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'helloworld'</span></span><br><span class="line"><span class="comment">//2번째 인덱스에서 시작하여 5번째 인덱스 전까지 추출</span></span><br><span class="line"><span class="built_in">console</span>.log(text.substring(<span class="number">2</span>, <span class="number">5</span>)) <span class="comment">// =&gt; "llo"</span></span><br><span class="line"><span class="comment">//2번째 인덱스에서 시작하여 3개까지 추출</span></span><br><span class="line"><span class="built_in">console</span>.log(text.substr(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// =&gt; "llo"</span></span><br></pre></td></tr></table></figure>
<h3 id="substring-와-slice-의-차이점"><a href="#substring-와-slice-의-차이점" class="headerlink" title="substring()와 slice()의 차이점"></a>substring()와 slice()의 차이점</h3><p>substring()와 slice()는 거의 똑같은데, 미묘하게 다른 점이 존재한다. <em>특히 부정적인 인수를 처리하는 방식에 차이가 있다.</em></p>
<ul>
<li>substring(): indexStart가 indexEnd보다 클 경우 <em>두 가지 인수를 바꾼듯이 작동한다.</em></li>
<li>slice(): indexStart가 indexEnd보다 클 경우 <em>빈 문자열을 반환한다.</em></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'helloworld'</span></span><br><span class="line"><span class="comment">//indexStart가 indexEnd보다 크기 때문에 text.substring(2,5)처럼 작동한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(text.substring(<span class="number">5</span>, <span class="number">2</span>)) <span class="comment">// =&gt; "llo"</span></span><br><span class="line"><span class="comment">//indexStart가 indexEnd보다 크기 때문에 빈문자열을 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(text.slice(<span class="number">5</span>, <span class="number">2</span>)) <span class="comment">// =&gt; ""</span></span><br></pre></td></tr></table></figure>
<p>두 가지 인수 모두 음수거나 NaN인 경우, substring()</p>
<ul>
<li>substring(): 두 가지 인수 모두 음수거나 NaN인 경우 <em>인수가 0인 것처럼 처리한다.</em></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//substring(0, 2)인 것처럼 처리</span></span><br><span class="line"><span class="built_in">console</span>.log(text.substring(<span class="number">-5</span>, <span class="number">2</span>)) <span class="comment">// =&gt; "he"</span></span><br><span class="line"><span class="comment">//substring(0)인 것처럼 처리</span></span><br><span class="line"><span class="built_in">console</span>.log(text.substring(<span class="number">-5</span>, <span class="number">-2</span>)) <span class="comment">// =&gt; ""</span></span><br></pre></td></tr></table></figure>
<ul>
<li>slice(): 두 가지 인수 모두 음수거나 NaN인 경우 <em>NaN인수는 0처럼 취급하지만, 음수일 때는 문자열 끝에서 역방향으로 계산한다.</em></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//text.slice(0,0)처럼 취급</span></span><br><span class="line"><span class="built_in">console</span>.log(text.slice(<span class="number">-5</span>, <span class="number">2</span>)) <span class="comment">// =&gt; ""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// indexStart가 -5이므로 문자열 길이 10 - 5의 5번째에서 시작</span></span><br><span class="line"><span class="comment">// indexEnd가 -2이므로 문자열 길이 10에서 10 - 2의 8번째에서 추출 종료.</span></span><br><span class="line"><span class="comment">// text.slice(5, 8)과 같은 결과</span></span><br><span class="line"><span class="built_in">console</span>.log(text.slice(<span class="number">-5</span>, <span class="number">-2</span>)) <span class="comment">// =&gt; "wor"</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>문자열의 일부를 추출하면서 새로운 문자열을 반환하기 때문에 다른 문자열에 영향을 미치지 않으며, 마지막 인덱스 직전까지 추출한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'The quick brown fox jumps over the lazy dog.'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">31</span>))</span><br><span class="line"><span class="comment">// expected output: "the lazy dog."</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">4</span>, <span class="number">19</span>))</span><br><span class="line"><span class="comment">// expected output: "quick brown fox"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">-4</span>))</span><br><span class="line"><span class="comment">// expected output: "dog."</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">-9</span>, <span class="number">-5</span>))</span><br><span class="line"><span class="comment">// expected output: "lazy"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>str.slice(beginIndex[, endIndex])<br>str.slice(추출시작점 인덱스[, 종료인덱스, 주어진 인덱스 직전까지 추출])<br>return 값 : 추출된 부분을 담는 새로운 문자열</p>
</blockquote>
<ul>
<li>beginIndex<ul>
<li>음수가 올 경우, strLength(문자열 길이) + beginIndex로 취급 (e.g. beginIndex가 -3이면 시작점은 strLength -3)</li>
<li>beginIndex가 strLength보다 크면 <em>빈 문자열 반환</em></li>
</ul>
</li>
<li>endIndex<ul>
<li>추출 종료점 인덱스 위치의 문자는 추출에 포함되지 않고, <em>그 직전까지 추출된다.</em></li>
<li>endIndex가 생략되었다면 문자열 마지막까지 추출한다.</li>
<li>음수라면 endIndex는 strLength + endIndex로 취급된다. (e.g. endInedx가 -3이면 종료점은 strLength -3)</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">'The morning is upon us.'</span>, <span class="comment">// the length of str1 is 23.</span></span><br><span class="line">  str2 = str1.slice(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">  str3 = str1.slice(<span class="number">4</span>, <span class="number">-2</span>),</span><br><span class="line">  str4 = str1.slice(<span class="number">12</span>),</span><br><span class="line">  str5 = str1.slice(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str2) <span class="comment">// OUTPUT: he morn</span></span><br><span class="line"><span class="built_in">console</span>.log(str3) <span class="comment">// OUTPUT: morning is upon u</span></span><br><span class="line"><span class="built_in">console</span>.log(str4) <span class="comment">// OUTPUT: is upon us.</span></span><br><span class="line"><span class="built_in">console</span>.log(str5) <span class="comment">// OUTPUT: ""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//slice는 새로운 문자열은 반환하기 때문에 str1은 그대로이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(str1) <span class="comment">// OUTPUT: The morning is upon us.</span></span><br></pre></td></tr></table></figure>
<h3 id="음수-인덱스로-slice-사용"><a href="#음수-인덱스로-slice-사용" class="headerlink" title="음수 인덱스로 slice()사용"></a>음수 인덱스로 slice()사용</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'The morning is upon us.'</span></span><br><span class="line">str.slice(<span class="number">-3</span>) <span class="comment">// returns 'us.'</span></span><br><span class="line">str.slice(<span class="number">-3</span>, <span class="number">-1</span>) <span class="comment">// returns 'us'</span></span><br><span class="line">str.slice(<span class="number">0</span>, <span class="number">-1</span>) <span class="comment">// returns 'The morning is upon us'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>beginIndex가 음수일 때<br>beginIndex는 문자열의 끝에서부터 역방향으로 11개를 세고, endIndex는 시작점부터 순방향으로 16개를 센다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">-11</span>, <span class="number">16</span>)) <span class="comment">// =&gt; "is u";</span></span><br></pre></td></tr></table></figure>
<ul>
<li>endIndex가 음수일 때<br>beginIndex는 문자열의 시작점부터 순방향으로 11개를 세고, endIndex는 끝에서부터 역방향으로 7개를 센다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">11</span>, <span class="number">-7</span>)) <span class="comment">// =&gt; "is u";</span></span><br></pre></td></tr></table></figure>
<ul>
<li>beginIndex, endIndex 모두 음수일 때<br>beginIndex는 끝에서부터 5까지 역순으로 계산하여 시작인덱스를 찾았고, 끝에서부터 1까지 역순으로 계산하여 마지막 인덱스를 찾는다. beginIndex가 -5이므로 문자열 길이 23 - 5의 18번째에서 시작한다. endIndex는 -1이므로 문자열 길이 23에서 23 - 1의 22번째에서 추출을 종료한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">-5</span>, <span class="number">-1</span>)) <span class="comment">// =&gt; "n us";</span></span><br></pre></td></tr></table></figure>
<hr>
<p><em>References</em><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/substr" target="_blank" rel="noopener">String.prototype.substr()</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/substring" target="_blank" rel="noopener">String.prototype.substring()</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice" target="_blank" rel="noopener">String.prototype.slice()</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2021/12/19/211220_mui/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/19/211220_mui/" class="post-title-link" itemprop="url">MUI v4에서 v5로 마이그레이션 하기</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-12-20T00:00:00+09:00">2021-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-21 23:10:05" itemprop="dateModified" datetime="2022-03-21T23:10:05+09:00">2022-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>원문 링크: <a href="https://mui.com/guides/migration-v4/" target="_blank" rel="noopener">https://mui.com/guides/migration-v4/</a></p>
</blockquote>
<h2 id="v4-에서-v5로-마이그레이션하기"><a href="#v4-에서-v5로-마이그레이션하기" class="headerlink" title="v4 에서 v5로 마이그레이션하기"></a>v4 에서 v5로 마이그레이션하기</h2><aside>
💡 왜 마이그레이션 해야할까 ? ➡️   [https://mui.com/blog/mui-core-v5/](https://mui.com/blog/mui-core-v5/)

</aside>

<aside>
💡 문제 발생시 여기로  ➡️  [https://mui.com/guides/migration-v4/#troubleshooting](https://mui.com/guides/migration-v4/#troubleshooting)

</aside>

<hr>
<h2 id="마이그레이션-해야-하는-이유"><a href="#마이그레이션-해야-하는-이유" class="headerlink" title="마이그레이션 해야 하는 이유"></a>마이그레이션 해야 하는 이유</h2><p>버그 수정 및 새로운 스타일링 엔진과 같은 여러 개선사항의 이점을 얻으려면 마이그레이션 해야한다.</p>
<h2 id="마이그레이션-단계"><a href="#마이그레이션-단계" class="headerlink" title="마이그레이션 단계"></a>마이그레이션 단계</h2><h2 id="React-또는-TypeScript-버전-업데이트"><a href="#React-또는-TypeScript-버전-업데이트" class="headerlink" title="React 또는 TypeScript 버전 업데이트"></a>React 또는 TypeScript 버전 업데이트</h2><ul>
<li>React 최소지원버전: v16.8.0 to v17.0.0.</li>
<li>TypeScript 최소지원버전: v3.2 to v3.5.</li>
</ul>
<h2 id="ThemeProvider-setup"><a href="#ThemeProvider-setup" class="headerlink" title="ThemeProvider setup"></a>ThemeProvider setup</h2><p>v5로 업그레이드 전에 <code>ThemeProvider</code> 가 당신의 어플리케이션의 root에 정의되어 있고(default theme를 사용한다고 하더라도) <code>useStyles</code> 가 <code>&lt;ThemeProvider&gt;</code> 전에 호출되진 않았는지 확인해 본다. 그 이유는 임시로 <code>@mui/styles</code> (JSS style-engine)을 사용해야 하는데, 이것이 <code>ThemeProvider</code> 를 요구한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ThemeProvider,</span><br><span class="line">  createMuiTheme,</span><br><span class="line">  makeStyles</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@material-ui/core/styles'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> theme = createMuiTheme()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useStyles = makeStyles(<span class="function"><span class="params">theme</span> =&gt;</span> &#123;</span><br><span class="line">  root: &#123;</span><br><span class="line">    <span class="comment">// some CSS that access to theme</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> classes = useStyles() <span class="comment">// ❌ If you have this, consider moving it inside a component that wrapped with &lt;ThemeProvider&gt;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MUI-버전-업데이트"><a href="#MUI-버전-업데이트" class="headerlink" title="MUI 버전 업데이트"></a>MUI 버전 업데이트</h2><p>v5 버전의 MUI core를 사용하려면 먼저 패키지 네임을 업데이트해야 한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install @mui/material @mui/styles</span><br><span class="line"></span><br><span class="line"><span class="comment">// or with `yarn`</span></span><br><span class="line">yarn add @mui/material @mui/styles</span><br></pre></td></tr></table></figure>
<p>만약 아래와 같은 패키지가 이미 있는 경우 새 패키지를 별도로 설치해라</p>
<ul>
<li><code>@material-ui/lab</code> →  <code>@mui/lab</code></li>
<li><p><code>@material-ui/icons</code> → <code>@mui/icons-material</code></p>
</li>
<li><p>모든 변경된 패키지 리스트 보기</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@material-ui/core -&gt; @mui/material</span><br><span class="line">@material-ui/system -&gt; @mui/system</span><br><span class="line">@material-ui/unstyled -&gt; @mui/base</span><br><span class="line">@material-ui/styles -&gt; @mui/styles</span><br><span class="line">@material-ui/icons -&gt; @mui/icons-material</span><br><span class="line">@material-ui/lab -&gt; @mui/lab</span><br><span class="line">@material-ui/types -&gt; @mui/types</span><br><span class="line">@material-ui/styled-engine -&gt; @mui/styled-engine</span><br><span class="line">@material-ui/styled-engine-sc -&gt;@mui/styled-engine-sc</span><br><span class="line">@material-ui/private-theming -&gt; @mui/private-theming</span><br><span class="line">@material-ui/codemod -&gt; @mui/codemod</span><br><span class="line">@material-ui/docs -&gt; @mui/docs</span><br><span class="line">@material-ui/envinfo -&gt; @mui/envinfo</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>org 또는 패키지 이름이 <code>@material-ui</code>에서 <code>@mui</code>로 변경된 것은 리브랜딩의 일환이다. 자세한 내용은 <a href="https://mui.com/blog/material-ui-is-now-mui/" target="_blank" rel="noopener">블로그</a> 포스트 또는 <a href="https://github.com/mui-org/material-ui/discussions/27803" target="_blank" rel="noopener">#27803</a>을 확인한다.</p>
<p>그 다음으로는 새로운 종속 디펜던시인 이모션 패키지를 설치해야 한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install @emotion/react @emotion/styled</span><br><span class="line"></span><br><span class="line"><span class="comment">// or with `yarn`</span></span><br><span class="line">yarn add @emotion/react @emotion/styled</span><br></pre></td></tr></table></figure>
<p>만약 MUI Core v5를 emotion 대신 styled-components와 함께 사용하고 싶다면 <a href="https://mui.com/getting-started/installation/#npm" target="_blank" rel="noopener">설치 가이드</a>를 확인한다.</p>
<p>만약 <code>@material-ui/pickers</code>를 사용중이라면 이것은 <code>@mui/lab</code>으로 이동했다. <a href="https://mui.com/guides/migration-v4/#material-ui-pickers" target="_blank" rel="noopener">이 링크</a>를 통해 <code>@mui/lab</code>으로 마이그레이션 하는 다음 단계를 확인할 수 있다.</p>
<p>지금쯤 <code>@mui/styles</code>를 설치했어야 한다. 여기에는 emotion을 복제하는 JSS를 포함하고 있다. 이는 v5로의 점진적인 마이그레이션을 허용하기 위한 것이다. <a href="https://mui.com/guides/migration-v4/#migrate-from-jss" target="_blank" rel="noopener">다음 단계</a>에 따라 종속성을 제거할 수 있도록 한다.</p>
<blockquote>
<p>어플리케이션이 에러없이 잘 실행되고 있는지 확인하고, 다음 단계를 이어가기 전에 변경 사항을 커밋하도록 한다.</p>
</blockquote>
<p>어플리케이션이 완전히 MUI v5로 마이그레이션 되면 이전의 <code>@material-ui/*</code> 패키지를 <code>yarn remove</code> 또는 <code>npm install</code>로 제거할 수 있다.</p>
<hr>
<h2 id="codemod-실행"><a href="#codemod-실행" class="headerlink" title="codemod 실행"></a>codemod 실행</h2><p>마이그레이션을 쉽게 할 수 있도록 codemod를 준비했다.</p>
<h3 id="preset-safe"><a href="#preset-safe" class="headerlink" title="preset-safe"></a>preset-safe</h3><p>이 codemod에는 마이그레이션에 유용한 대부분의 transformer가 포함되어 있다. (이 codemod는 폴더당 한 번만 적용될 수 있도록 한다.)</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx @mui/codemod v5<span class="number">.0</span><span class="number">.0</span>/preset-safe &lt;path&gt;</span><br></pre></td></tr></table></figure>
<p>이 codemode를 일대일로 하나씩 실행하려면 <a href="https://github.com/mui-org/material-ui/blob/master/packages/mui-codemod/README.md#-preset-safe" target="_blank" rel="noopener">preset-safe codemod</a>에서 상세 내용을 확인한다.</p>
<h3 id="variant-prop"><a href="#variant-prop" class="headerlink" title="variant-prop"></a>variant-prop</h3><p>어떠한 variant도 정의되지 않았다면 (default variant는 v4 standard에서 v5 outlined로 변경되었다.)<code>&lt;TextField/&gt;</code>, <code>&lt;FormControl/&gt;</code>, <code>&lt;Select/&gt;</code> 등의 컴포넌트에 variant=”standard”를 적용하여 변환할 수 있다.</p>
<aside>
💡 이미 default로 variant:”outlined”를 theme에 사용했다면 이 codemode를 사용해서는 안된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if you have theme setup like this, ❌ don't run this codemod.</span></span><br><span class="line"><span class="comment">// these default props can be removed later because `outlined` is the default value in v5</span></span><br><span class="line">createMuiTheme(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    MuiTextField: &#123;</span><br><span class="line">      defaultProps: &#123;</span><br><span class="line">        variant: <span class="string">'outlined'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>만약 variant=”standard” 를 컴포넌트에서 유지하고 싶다면, 이 codemod를 실행하거나 theme default props를 구성한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx @mui/codemod v5<span class="number">.0</span><span class="number">.0</span>/variant-prop &lt;path&gt;</span><br></pre></td></tr></table></figure>
<p>자세한 내용은 <a href="https://github.com/mui-org/material-ui/blob/master/packages/mui-codemod/README.md#variant-prop" target="_blank" rel="noopener">variant-prop codemod</a>를 확인한다.</p>
<h3 id="link-underline-hover"><a href="#link-underline-hover" class="headerlink" title="link-underline-hover"></a>link-underline-hover</h3><p>underliner prop이 정의되지 않았다면 <Link/> 컴포넌트에 underline=”hover”를 적용하면 변환할 수 있다. (default underline은 v4 “hover”에서 v5 “always”로 변경되었다.)</p>
<aside>
💡 이미 default로 underline:”always”를 theme에 사용했다면 이 codemode를 사용해서는 안된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if you have theme setup like this, ❌ don't run this codemod.</span></span><br><span class="line"><span class="comment">// this default props can be removed later because `always` is the default value in v5</span></span><br><span class="line">createMuiTheme(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    MuiLink: &#123;</span><br><span class="line">      defaultProps: &#123;</span><br><span class="line">        underline: <span class="string">'always'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>만약 variant=”hover” 를 컴포넌트에서 유지하고 싶다면, 이 codemod를 실행하거나 theme default props를 구성한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx @mui/codemod v5<span class="number">.0</span><span class="number">.0</span>/link-underline-hover &lt;path&gt;</span><br></pre></td></tr></table></figure>
<p>자세한 내용은 <a href="https://github.com/mui-org/material-ui/blob/master/packages/mui-codemod/README.md#link-underline-hover" target="_blank" rel="noopener">link-underline-hover codemod</a>에서 확인한다.</p>
<p>codemod 단계를 일단 완료했다면 어플리케이션을 다시 실행해본다. 이때 에러없이 실행되어야 한다. 그렇지 않을 경우 <a href="https://mui.com/guides/migration-v4/#troubleshooting" target="_blank" rel="noopener">troubleshooting</a> 섹션을 확인해본다. 다음 단계는 각 컴포넌트의 주요 변경사항을 처리하는 것이다.</p>
<hr>
<h2 id="Handling-breaking-changes"><a href="#Handling-breaking-changes" class="headerlink" title="Handling breaking changes"></a>Handling breaking changes</h2><h3 id="지원되는-브라우저-및-노드-버전"><a href="#지원되는-브라우저-및-노드-버전" class="headerlink" title="지원되는 브라우저 및 노드 버전"></a>지원되는 브라우저 및 노드 버전</h3><p>default 번들의 타겟이 변경되었다. 정확한 버전은 browserslist query가 릴리즈 될 때 고정된다.</p>
<p><code>&quot;&gt; 0.5%, last 2 versions, Firefox ESR, not dead, not IE 11, maintained node versions&quot;</code></p>
<p>기존 번들은 아래와 같은 최소 버전을 지원한다.</p>
<ul>
<li>Node 12 (up from 8)</li>
<li>Chrome 90 (up from 49)</li>
<li>Edge 91 (up from 14)</li>
<li>Firefox 78 (up from 52)</li>
<li>Safari 14 (macOS) and 12.5 (iOS) (up from 10)</li>
<li>and more (see <a href="https://github.com/mui-org/material-ui/blob/HEAD/.browserslistrc#L11" target="_blank" rel="noopener">.browserslistrc (<code>stable</code> entry)</a>)</li>
</ul>
<p>더이상 IE 11을 지원하지 않기 때문에 IE 11을 지원해야 하는 경우는 <a href="https://mui.com/guides/minimizing-bundle-size/#legacy-bundle" target="_blank" rel="noopener">lagacy bundle</a>를 확인한다.</p>
<h3 id="non-ref-forwarding-class-components"><a href="#non-ref-forwarding-class-components" class="headerlink" title="non-ref-forwarding class components"></a>non-ref-forwarding class components</h3><p>component prop의 non-ref-forwarding class components 또는 immediate children의 지원이 중단되었다. 만약 unstable_createStrictModeTheme를 사용하고 있거나 React.StrictMode의 <code>findDOMNode</code> 과 관련된 어떠한 경고도 표시되지 않았다면 아무런 작업도 수행할 필요가 없다. 그렇지 않다면 <a href="https://mui.com/guides/composition/#caveat-with-refs" target="_blank" rel="noopener">Caveat with refs</a> 섹션에서 어떻게 마이그레이션 해야하는지 알아볼 필요가 있다. 이 변경 사항은 component prop를 사용하는 곳이나 children을 element로 필요로 하기 때문에 children을 components에 전달해야 하는 거의 모든 components에 영향을 미친다. (예를 들어, <MenuList><CustomMenuItem /></MenuList>)</p>
<h3 id="style-library"><a href="#style-library" class="headerlink" title="style library"></a>style library</h3><p>v5에서 default로 사용하는 스타일 라이브러리는 <code>[emotion](https://github.com/emotion-js/emotion)</code>이다. JSS에서 emotion으로 마이그레이션 하는 동안 components에 JSS style을 사용하여 override하는 경우 (예를 들자면 makeStyles 통해 override하는 경우) CSS 삽입 순서 (CSS injection order)를 신경써야 한다. 이렇게 하려면 <code>StyledEngineProvider</code> 와 <code>injectFirst</code> 옵션이 <strong>컴포넌트 tree의 가장 최상단에 위치해야 한다.</strong></p>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//예시</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; StyledEngineProvider &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">GlobalCssPriority</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &#123;<span class="comment">/* Inject emotion before JSS */</span>&#125;</span><br><span class="line">    &lt;StyledEngineProvider injectFirst&gt;</span><br><span class="line">      &#123;<span class="comment">/* Your component tree. Now you can override MUI's styles. */</span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/StyledEngineProvider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<aside>
💡 emotion을 통해 app에 스타일을 지정하고, 커스텀 캐시가 있는 경우에 MUI에 의해 제공되는 캐시는 무시된다. injection order를 올바르게 하려면 `prepend` 옵션을 `createCache`에 추가해야 한다.  
이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//예시</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> <span class="keyword">import</span> &#123; CacheProvider &#125; <span class="keyword">from</span> <span class="string">'@emotion/react'</span>;</span><br><span class="line"> <span class="keyword">import</span> createCache <span class="keyword">from</span> <span class="string">'@emotion/cache'</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> cache = createCache(&#123;</span><br><span class="line">   key: <span class="string">'css'</span>,</span><br><span class="line">+  prepend: <span class="literal">true</span>,</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">PlainCssPriority</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;CacheProvider value=&#123;cache&#125;&gt;</span><br><span class="line">       &#123;<span class="comment">/* Your component tree. Now you can override MUI's styles. */</span>&#125;</span><br><span class="line">     &lt;<span class="regexp">/CacheProvider&gt;</span></span><br><span class="line"><span class="regexp">   );</span></span><br><span class="line"><span class="regexp"> &#125;</span></span><br></pre></td></tr></table></figure>
<p>styled-components를 사용 중이고, 커스텀 타겟이 있는 StyleSheetManager를 사용중이라면 타겟이 HTML <head> 엘리먼트의 첫번 째 요소인지 확인한다. 어떻게 이것을 수행하는지 확인하려면 <code>@mui/styled-engine-sc</code> package에 있는 <code>[StyledEngineProvider</code> implementation](<a href="https://github.com/mui-org/material-ui/blob/master/packages/mui-styled-engine-sc/src/StyledEngineProvider/StyledEngineProvider.js)을" target="_blank" rel="noopener">https://github.com/mui-org/material-ui/blob/master/packages/mui-styled-engine-sc/src/StyledEngineProvider/StyledEngineProvider.js)을</a> 살펴본다.</p>
<h3 id="Theme-structure"><a href="#Theme-structure" class="headerlink" title="Theme structure"></a>Theme structure</h3><p>theme 구조는 v5에서 변경되었기 때문에 변경된 형태로 업데이트 해야 한다. 원활한 전환을 위해서 <code>adaptV4Theme</code>를 사용해서 일부 테마의 변경된 사항을 새로운 테마 구조로 반복적으로 업그레이드 할 수 있다.</p>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; createMuiTheme &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; createTheme, adaptV4Theme &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line"></span><br><span class="line">-<span class="keyword">const</span> theme = createMuiTheme(&#123;</span><br><span class="line">+<span class="keyword">const</span> theme = createTheme(adaptV4Theme(&#123;</span><br><span class="line">   <span class="comment">// v4 theme</span></span><br><span class="line">-&#125;);</span><br><span class="line">+&#125;));</span><br></pre></td></tr></table></figure>
<aside>
💡 이 adapter는 creatTheme의 input arguements만 처리하기 때문에 테마 생성 후 구조를 수정하고자 할 때는 수동으로 업데이트 해야한다.

</aside>

<p>adapther는 다음의 변경 사항을 지원한다.</p>
<ul>
<li>“gutters” abstraction은 가치가 있다고 생각될 만큼 자주 사용되지 않는다고 입증되었다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-theme.mixins.gutters(),</span><br><span class="line">+paddingLeft: theme.spacing(<span class="number">2</span>),</span><br><span class="line">+paddingRight: theme.spacing(<span class="number">2</span>),</span><br><span class="line">+[theme.breakpoints.up(<span class="string">'sm'</span>)]: &#123;</span><br><span class="line">+  paddingLeft: theme.spacing(<span class="number">3</span>),</span><br><span class="line">+  paddingRight: theme.spacing(<span class="number">3</span>),</span><br><span class="line">+&#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li><code>theme.spacing</code> 은 이제 default로 px 유닛과 단일 값을 반환한다. 이는 styled-compontnts와 emotion의 통합을 개선한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">이는 &#96;theme.spacing&#96;이 template string로 호출되던 것으로부터 &#39;px&#39; 접미사를 제거해서</span><br><span class="line">[preset-safe codemod](https:&#x2F;&#x2F;mui.com&#x2F;guides&#x2F;migration-v4&#x2F;#preset-safe)에서 처리된다.</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line">theme.spacing(<span class="number">2</span>) =&gt; <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//after</span></span><br><span class="line">theme.spacing(<span class="number">2</span>) =&gt; <span class="string">'16px'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>이 기능을 설명하는 데 일반적으로 사용되는 “dark mode”라는 용어를 더 잘 따르기 위해서 <code>theme.palette.type</code> 키는 <code>theme.palette.mode</code> 로 이름이 변경되었다.</li>
</ul>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createTheme &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">-<span class="keyword">const</span> theme = createTheme(&#123;<span class="attr">palette</span>: &#123; <span class="attr">type</span>: <span class="string">'dark'</span> &#125;&#125;),</span><br><span class="line">+<span class="keyword">const</span> theme = createTheme(&#123;<span class="attr">palette</span>: &#123; <span class="attr">mode</span>: <span class="string">'dark'</span> &#125;&#125;),</span><br></pre></td></tr></table></figure>
<ul>
<li>default <code>[theme.palette.info](http://theme.palette.info)</code> 색상은 라이트, 다크 모드 모두에서 AA 표준 명암비를 통과하도록 변경되었다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">-  main: cyan[<span class="number">500</span>],</span><br><span class="line">+  main: lightBlue[<span class="number">700</span>], <span class="comment">// lightBlue[400] in "dark" mode</span></span><br><span class="line"></span><br><span class="line">-  light: cyan[<span class="number">300</span>],</span><br><span class="line">+  light: lightBlue[<span class="number">500</span>], <span class="comment">// lightBlue[300] in "dark" mode</span></span><br><span class="line"></span><br><span class="line">-  dark: cyan[<span class="number">700</span>],</span><br><span class="line">+  dark: lightBlue[<span class="number">900</span>], <span class="comment">// lightBlue[700] in "dark" mode</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>default <code>theme.palette.succeess</code> 색상은 색상은 라이트, 다크 모드 모두에서 AA 표준 명암비를 통과하도록 변경되었다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">success = &#123;</span><br><span class="line">-  main: green[<span class="number">500</span>],</span><br><span class="line">+  main: green[<span class="number">800</span>], <span class="comment">// green[400] in "dark" mode</span></span><br><span class="line"></span><br><span class="line">-  light: green[<span class="number">300</span>],</span><br><span class="line">+  light: green[<span class="number">500</span>], <span class="comment">// green[300] in "dark" mode</span></span><br><span class="line"></span><br><span class="line">-  dark: green[<span class="number">700</span>],</span><br><span class="line">+  dark: green[<span class="number">900</span>], <span class="comment">// green[700] in "dark" mode</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>default <code>theme.palette.warning</code> 색상은 색상은 라이트, 다크 모드 모두에서 AA 표준 명암비를 통과하도록 변경되었다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">warning = &#123;</span><br><span class="line">-  main: orange[<span class="number">500</span>],</span><br><span class="line">+  main: <span class="string">"#ED6C02"</span>, <span class="comment">// orange[400] in "dark" mode</span></span><br><span class="line"></span><br><span class="line">-  light: orange[<span class="number">300</span>],</span><br><span class="line">+  light: orange[<span class="number">500</span>], <span class="comment">// orange[300] in "dark" mode</span></span><br><span class="line"></span><br><span class="line">-  dark: orange[<span class="number">700</span>],</span><br><span class="line">+  dark: orange[<span class="number">900</span>], <span class="comment">// orange[700] in "dark" mode</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>default <code>theme.palette.text.hint</code> 키는 MUI components에서는 사용되지 않기 때문에 제거되었다. 만약 dependency를 가지고 있다면 뒤에 아래 예시와 같은 내용을 덧붙이도록 한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createTheme &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line"></span><br><span class="line">-<span class="keyword">const</span> theme = createTheme(),</span><br><span class="line">+<span class="keyword">const</span> theme = createTheme(&#123;</span><br><span class="line">+  palette: &#123; <span class="attr">text</span>: &#123; <span class="attr">hint</span>: <span class="string">'rgba(0, 0, 0, 0.38)'</span> &#125; &#125;,</span><br><span class="line">+&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>theme의 components 정의는 어떠한 관련된 component에서도 정의를 쉽게 찾아볼 수 있도록 compontns key 아래에 새롭게 구성되었다.</li>
</ul>
<ol>
<li><code>prop</code></li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createTheme &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> theme = createTheme(&#123;</span><br><span class="line">-  props: &#123;</span><br><span class="line">-    MuiButton: &#123;</span><br><span class="line">-      disableRipple: <span class="literal">true</span>,</span><br><span class="line">-    &#125;,</span><br><span class="line">-  &#125;,</span><br><span class="line">+  components: &#123;</span><br><span class="line">+    MuiButton: &#123;</span><br><span class="line">+      defaultProps: &#123;</span><br><span class="line">+        disableRipple: <span class="literal">true</span>,</span><br><span class="line">+      &#125;,</span><br><span class="line">+    &#125;,</span><br><span class="line">+  &#125;,</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>overrides</code></li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createTheme &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> theme = createTheme(&#123;</span><br><span class="line">-  overrides: &#123;</span><br><span class="line">-    MuiButton: &#123;</span><br><span class="line">-      root: &#123; <span class="attr">padding</span>: <span class="number">0</span> &#125;,</span><br><span class="line">-    &#125;,</span><br><span class="line">-  &#125;,</span><br><span class="line">+  components: &#123;</span><br><span class="line">+    MuiButton: &#123;</span><br><span class="line">+      styleOverrides: &#123;</span><br><span class="line">+        root: &#123; <span class="attr">padding</span>: <span class="number">0</span> &#125;,</span><br><span class="line">+      &#125;,</span><br><span class="line">+    &#125;,</span><br><span class="line">+  &#125;,</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Styles"><a href="#Styles" class="headerlink" title="Styles"></a>Styles</h3><ul>
<li>기능을 더 잘 나타내기 위해 <code>fade</code> 에서 <code>alpha</code> 로 이름이 변경되었다. 이전의 이름은 입력 색상 값에 이미 alpha값이 있을 때 혼동을 야기했다. helper는 색상의 alpha 값을 override 한다.</li>
</ul>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">import</span> &#123; fade &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+ <span class="keyword">import</span> &#123; alpha &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> classes = makeStyles(<span class="function"><span class="params">theme</span> =&gt;</span> (&#123;</span><br><span class="line">-  backgroundColor: fade(theme.palette.primary.main, theme.palette.action.selectedOpacity),</span><br><span class="line">+  backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<ul>
<li><code>createStyles</code> 함수는 <code>@mui/material/styles</code> 에서 export 되는 것에서 <code>@mui/styles</code> 에서 export되는 것으로 변경되었다. 디펜던시를 core 패키지의 <code>@mui/styles</code> 로 이동시키는 것이 필요하다.</li>
</ul>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; createStyles &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; createStyles &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="mui-styles"><a href="#mui-styles" class="headerlink" title="@mui/styles"></a>@mui/styles</h3><h3 id="ThemeProvider"><a href="#ThemeProvider" class="headerlink" title="ThemeProvider"></a>ThemeProvider</h3><p><code>@mui/styles</code> 와 <code>@mui/material</code>를 함께 사용한다면, <code>ThemeProvider</code> 를 <code>@mui/material/styles</code>에서 export 되던 것을 <code>@mui/styles</code>에서 export 되도록 변경해야 한다. 이 방법은 <code>@mui/styles</code>에서 export된 스타일링 유틸리티인 makeStyles, withStyles 등과 MUI component에서 context에서 제공되는 theme가 모두 사용되도록 할 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; ThemeProvider &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; ThemeProvider &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Default-Theme-TypeScript"><a href="#Default-Theme-TypeScript" class="headerlink" title="Default Theme (TypeScript)"></a>Default Theme (TypeScript)</h3><p><code>@mui/styles</code> 패키지는 더이상 <code>@mui/material/styles</code> 의 일부가 아니다. <code>@mui/styles</code>를 <code>@mui/material</code> 과 함께 사용하는 경우에 DefaultTheme에 대해 모듈을 추가하여 적용해야 한다.</p>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in the file where you are creating the theme (invoking the function `createTheme()`)</span></span><br><span class="line"><span class="keyword">import</span> &#123; Theme &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line"></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">'@mui/styles'</span> &#123;</span><br><span class="line">  interface DefaultTheme extends Theme &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mui-material-colors"><a href="#mui-material-colors" class="headerlink" title="@mui/material/colors"></a>@mui/material/colors</h3><ul>
<li>1 레벨 이상의 중첩된 import는 private이다. <code>@mui/material/colors/red</code> 에서 색상을 가져올 수 없다.</li>
</ul>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> red <span class="keyword">from</span> <span class="string">'@mui/material/colors/red'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; red &#125; <span class="keyword">from</span> <span class="string">'@mui/material/colors'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="mui-material-styles"><a href="#mui-material-styles" class="headerlink" title="@mui/material/styles"></a>@mui/material/styles</h3><h3 id="createGenerateClassName"><a href="#createGenerateClassName" class="headerlink" title="createGenerateClassName"></a>createGenerateClassName</h3><p><code>createGenerateClassName</code> 함수는 더이상 <code>@mui/material/styles</code>에서 export되지 않는다. <code>@mui/styles</code>에서 직접 import해야 한다.</p>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; createGenerateClassName &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; createGenerateClassName &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span>;</span><br></pre></td></tr></table></figure>
<p>@mui/styles를 사용하지 않고 커스텀 클래스네임을 생성하려면 <a href="https://mui.com/guides/classname-generator/" target="_blank" rel="noopener">ClassNameGenerator</a>에서 세부내용을 확인한다.</p>
<h3 id="createMuiTheme"><a href="#createMuiTheme" class="headerlink" title="createMuiTheme"></a>createMuiTheme</h3><p><code>createMuiTheme</code> 함수는 <code>ThemeProvider</code>를 좀더 직관적으로 사용할 수 있도록 하기 위해서 <code>createTheme</code>로 이름이 변경되었다.</p>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; createMuiTheme &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; createTheme &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line"></span><br><span class="line">-<span class="keyword">const</span> theme = createMuiTheme(&#123;</span><br><span class="line">+<span class="keyword">const</span> theme = createTheme(&#123;</span><br></pre></td></tr></table></figure>
<h3 id="jssPreset"><a href="#jssPreset" class="headerlink" title="jssPreset"></a>jssPreset</h3><ul>
<li><code>jssPreset</code> 객체는 더이상 <code>@mui/material/styles</code> 에서 export되지 않는다. <code>@mui/styles</code>에서 바로 import해서 사용해야 한다.</li>
</ul>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; jssPreset &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; jssPreset &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="makeStyles"><a href="#makeStyles" class="headerlink" title="makeStyles"></a>makeStyles</h3><ul>
<li><code>makeStyles</code> JSS 유틸리티는 더이상 <code>@mui/material/styles</code> 에서 export되지 않기 때문에 대신 <code>@mui/styles/makeStyles</code>를 사용해야 한다. <code>defaultTheme</code> 를 더이상 사용할 수 없기 때문에 <code>ThemeProvider</code>를 어플리케이션의 루트에 추가하도록 한다. 만약 <code>@mui/material</code>와 함께 사용하고 있다면 <code>@mui/material/styles</code>에 있는 ThemeProvider 컴포넌트를 사용하는 것을 추천한다.</li>
</ul>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; makeStyles &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; makeStyles &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; createTheme, ThemeProvider &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="keyword">const</span> theme = createTheme();</span><br><span class="line"> <span class="keyword">const</span> useStyles = makeStyles(<span class="function">(<span class="params">theme</span>) =&gt;</span> (&#123;</span><br><span class="line">   background: theme.palette.primary.main,</span><br><span class="line"> &#125;));</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> classes = useStyles();</span><br><span class="line">   <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;classes.root&#125;</span> /&gt;</span></span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// In the root of your app</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">-  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span>;</span><br><span class="line">+  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span><span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="MuiThemeProvider"><a href="#MuiThemeProvider" class="headerlink" title="MuiThemeProvider"></a>MuiThemeProvider</h3><p><code>MuiThemeProvider</code> 컴포넌트는 더이상 <code>@mui/material/styles</code>에서 export되지 않으므로 <code>ThemeProvider</code>를 대신 사용한다.</p>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; MuiThemeProvider &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; ThemeProvider &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="serverStyleSheets"><a href="#serverStyleSheets" class="headerlink" title="serverStyleSheets"></a>serverStyleSheets</h3><p><code>ServerStyleSheets</code> 컴포넌트는 더이상 <code>@mui/material/styles</code>에서 export되지 않으므로 <code>@mui/styles</code>에서 직접 import하도록 한다.</p>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; ServerStyleSheets &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; ServerStyleSheets &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Styles-1"><a href="#Styles-1" class="headerlink" title="Styles"></a>Styles</h3><p><code>styled</code> JSS utility는 더이상 <code>@mui/material/styles</code>에서 export되지 않으므로 대신 <code>@mui/styles</code>에서 export된 것을 사용하도록 한다. <code>defaultTheme</code> 를 더이상 사용할 수 없기 때문에 <code>ThemeProvider</code>를 어플리케이션의 루트에 추가하도록 한다. 만약 <code>@mui/material</code>와 함께 사용하고 있다면 <code>@mui/material/styles</code>에 있는 ThemeProvider 컴포넌트를 사용하는 것을 추천한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; styled &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; styled &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; createTheme, ThemeProvider &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="keyword">const</span> theme = createTheme();</span><br><span class="line"> <span class="keyword">const</span> MyComponent = styled(<span class="string">'div'</span>)(<span class="function">(<span class="params">&#123; theme &#125;</span>) =&gt;</span> (&#123; <span class="attr">background</span>: theme.palette.primary.main &#125;));</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">-  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>;</span><br><span class="line">+  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">MyComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span><span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="StylesProvider"><a href="#StylesProvider" class="headerlink" title="StylesProvider"></a>StylesProvider</h3><ul>
<li><code>StylesProvider</code> 컴포넌트는 더이상 <code>@mui/material/styles</code>에서 export되지 않으므로 <code>@mui/styles</code>에서 바로 export하여 사용하도록 한다.</li>
</ul>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; StylesProvider &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; StylesProvider &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="useThemeVariants"><a href="#useThemeVariants" class="headerlink" title="useThemeVariants"></a>useThemeVariants</h3><ul>
<li><code>useThemeVariants</code> hook은 더이상 <code>@mui/material/styles</code> 에서 export 되지 않기 때문에 <code>@mui/styles</code> 에서 즉시 import하여 사용하도록 한다.</li>
</ul>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; useThemeVariants &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; useThemeVariants &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="withStyles"><a href="#withStyles" class="headerlink" title="withStyles"></a>withStyles</h3><p><code>innerRef</code> prop은 <code>ref</code> prop으로 교체한다. Refs는 이제 자동으로 inner 컴포넌트에 전달된다.</p>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> <span class="keyword">import</span> &#123; withStyles &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> MyComponent = withStyles(&#123;</span><br><span class="line">   root: &#123;</span><br><span class="line">     backgroundColor: <span class="string">'red'</span>,</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;)(<span class="function">(<span class="params">&#123; classes &#125;</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;classes.root&#125;</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">MyOtherComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> ref = React.useRef();</span><br><span class="line">-  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">innerRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">+  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>withStyles</code> JSS utility는 더이상 <code>@mui/material/styles</code> 에서 export 되지 않기 때문에 <code>@mui/styles/withStyles</code> 를 대신 쓰도록 한다. <code>defaultTheme</code> 를 더이상 사용할 수 없기 때문에 <code>ThemeProvider</code>를 어플리케이션의 루트에 추가하도록 한다. 만약 <code>@mui/material</code>와 함께 사용하고 있다면 <code>@mui/material/styles</code>에 있는 ThemeProvider 컴포넌트를 사용하는 것을 추천한다.</p>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; withStyles &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; withStyles &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; createTheme, ThemeProvider &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="keyword">const</span> defaultTheme = createTheme();</span><br><span class="line"> <span class="keyword">const</span> MyComponent = withStyles(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; classes, className, ...other &#125; = props;</span><br><span class="line">   <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;clsx(className,</span> <span class="attr">classes.root</span>)&#125; &#123;<span class="attr">...other</span>&#125; /&gt;</span></span></span><br><span class="line"> &#125;)(<span class="function">(<span class="params">&#123; theme &#125;</span>) =&gt;</span> (&#123; <span class="attr">root</span>: &#123; <span class="attr">background</span>: theme.palette.primary.main &#125;&#125;));</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">-  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>;</span><br><span class="line">+  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">theme</span>=<span class="string">&#123;defaultTheme&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span><span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="withTheme"><a href="#withTheme" class="headerlink" title="withTheme"></a>withTheme</h3><p><code>withTheme</code> HOC utility는 <code>@mui/material/styles</code> 패키지에서 제거되었기 때문에 대신 <code>@mui/styles/withTheme</code>를 사용할 수 있다. <code>defaultTheme</code> 를 더이상 사용할 수 없기 때문에 <code>ThemeProvider</code>를 어플리케이션의 루트에 추가하도록 한다. 만약 <code>@mui/material</code>와 함께 사용하고 있다면 <code>@mui/material/styles</code>에 있는 ThemeProvider 컴포넌트를 사용하는 것을 추천한다.</p>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">import</span> &#123; withTheme &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; withTheme &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span>;</span><br><span class="line">+<span class="keyword">import</span> &#123; createTheme, ThemeProvider &#125; <span class="keyword">from</span> <span class="string">'@mui/material/styles'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="keyword">const</span> theme = createTheme();</span><br><span class="line"> <span class="keyword">const</span> MyComponent = withTheme(<span class="function">(<span class="params">&#123; theme &#125;</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.theme.direction&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">-  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>;</span><br><span class="line">+  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">MyComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span><span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>innerRef</code> prop를 ref prop으로 바꾼다. Ref는 이제 자동으로 내부 컴포넌트에 전달된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; withTheme &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = withTheme(<span class="function">(<span class="params">&#123; theme &#125;</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.theme.direction&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyOtherComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = React.useRef();</span><br><span class="line">- <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">innerRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">+ <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="withWidth"><a href="#withWidth" class="headerlink" title="withWidth"></a>withWidth</h3><p>이 HOC는 제거되었고, 대안으로 <code>[useMediaQuery</code> hook](<a href="https://mui.com/components/use-media-query/#migrating-from-withwidth)을" target="_blank" rel="noopener">https://mui.com/components/use-media-query/#migrating-from-withwidth)을</a> 쓸 수 있다.</p>
<aside>
💡 이는 응용 프로그램이 충돌하는 것을 방지하기 위해 하드 코딩된 기능을 적용하여 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<h3 id="mui-icons-matetial"><a href="#mui-icons-matetial" class="headerlink" title="mui/icons-matetial"></a>mui/icons-matetial</h3><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>Github icon은 24px에서 22px로 크기가 감소되었다.</p>
<h3 id="material-ui-pickers"><a href="#material-ui-pickers" class="headerlink" title="@material-ui/pickers"></a><strong>@material-ui/pickers</strong></h3><p><code>@material-ui/pickers</code>를 마이그레이션 하는 방법은 <a href="https://mui.com/guides/pickers-migration/" target="_blank" rel="noopener">다음 페이지</a>를 참조하도록 한다.</p>
<hr>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>다음의 system function 및 속성은 사용되지 않는 css로 간주되어 이름이 변경되었다.</p>
<ul>
<li><code>gridGap</code> to <code>gap</code></li>
<li><code>gridRowGap</code> to <code>rowGap</code></li>
<li><code>gridColumnGap</code> to <code>columnGap</code></li>
</ul>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<p>간격을 조정하는 unit인 <code>gap</code>, <code>rowGap</code>, <code>columnGap</code> 등을 사용할 때, 이전에 숫자로 사용하고 있었다면 theme.spacing과 더불어 새롭게 변환되기 위해 px를 덧붙여서 사용해야 한다.</p>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Box</span><br><span class="line">-  gap=&#123;<span class="number">2</span>&#125;</span><br><span class="line">+  gap=<span class="string">"2px"</span></span><br><span class="line"> &gt;</span><br></pre></td></tr></table></figure>
<p>css prop은 styled-components와 emotion의 css prop이 충돌되는 것을 막기 위해 <code>sx</code>로 변경한다.</p>
<aside>
💡 이는 [preset-safe codemod](https://mui.com/guides/migration-v4/#preset-safe)에서 처리된다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;-(<span class="xml"><span class="tag">&lt;<span class="name">Box</span> <span class="attr">css</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> '<span class="attr">primary.main</span>' &#125;&#125; /&gt;</span></span>) +</span><br><span class="line">&lt;Box sx=&#123;&#123; <span class="attr">color</span>: <span class="string">'primary.main'</span> &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Core-components"><a href="#Core-components" class="headerlink" title="Core components"></a>Core components</h3><p>core components는 스타일 엔진으로 emotion을 사용하기 때문에 emotion에 의해 사용되는 props들은 전파되지 않는다. 아래의 코드 스니펫처럼 props <code>as</code>는 <code>SomeOtherComponent</code>로 전파되지 않는다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MuiComponent component=&#123;SomeOtherComponent&#125; <span class="keyword">as</span>=<span class="string">'button'</span> /&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p><em>References</em><br><a href="https://mui.com/guides/migration-v4/" target="_blank" rel="noopener">Migration from v4 to v5 - MUI</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2021/10/03/211004_tsOmitExclude/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/03/211004_tsOmitExclude/" class="post-title-link" itemprop="url">A difference between TypeScript Omit and exclude</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-04 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-04T00:00:00+09:00">2021-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-21 23:10:05" itemprop="dateModified" datetime="2022-03-21T23:10:05+09:00">2022-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Keyof-Type-Operator"><a href="#Keyof-Type-Operator" class="headerlink" title="Keyof Type Operator"></a>Keyof Type Operator</h2><p>Keyof Type Operator는 객체타입을 취하여 key인 stirng 또는 numeric 리터럴 유니언을 생성한다. 아래 예시에서 <code>type P</code>는 <code>“x” | “y”</code>인 타입과 같다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point = &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> P = keyof Point;</span><br><span class="line"><span class="comment">//type P = “x” | “y”</span></span><br></pre></td></tr></table></figure>
<p>type이 string, 또는 number 인덱스 시그니처가 있으면 keyof가 이 types를 대신 반환한다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Arrayish = &#123; [n: <span class="built_in">number</span>]: unknown &#125;;</span><br><span class="line"><span class="keyword">type</span> A = keyof Arrayish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A = <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mapish = &#123; [k: <span class="built_in">string</span>]: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> M = keyof Mapish;</span><br></pre></td></tr></table></figure>
<p>이 예시에서 <code>M</code>은 <code>string | number</code>이다. 이는 JavaScript object keys가 언제나 string로 강제전환되기 때문이다. <strong>그래서 <code>obj[0]</code>은 언제나 <code>obj[&quot;0&quot;]</code>과 같다.</strong> <code>keyof</code>타입은 <code>mapped types</code>와 결합해서 사용할 때 특히 유용하다.</p>
<hr>
<h2 id="Omit-lt-Type-Keys-gt"><a href="#Omit-lt-Type-Keys-gt" class="headerlink" title="Omit&lt;Type, Keys&gt;"></a><code>Omit&lt;Type, Keys&gt;</code></h2><p><code>Type</code>에서 type을 구성하는 모든 속성을 선택하여 <code>keys</code>에 의해 제거될 수 있도록 한다. (key는 string 리터럴이거나 string 리터럴의 유니언이다.)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  description: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">  createdAt: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoPreview = Omit&lt;Todo, <span class="string">'description'</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview = &#123;</span><br><span class="line">  title: <span class="string">'Clean room'</span>,</span><br><span class="line">  completed: <span class="literal">false</span>,</span><br><span class="line">  createdAt: <span class="number">1615544252770</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">todo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoInfo = Omit&lt;Todo, <span class="string">'completed'</span> | <span class="string">'createdAt'</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoInfo: TodoInfo = &#123;</span><br><span class="line">  title: <span class="string">'Pick up kids'</span>,</span><br><span class="line">  description: <span class="string">'Kindergarten closes at 5pm'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">todoInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoInfo: TodoInfo;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Exclude-lt-Type-ExcludedUnion-gt"><a href="#Exclude-lt-Type-ExcludedUnion-gt" class="headerlink" title="Exclude&lt;Type, ExcludedUnion&gt;"></a><code>Exclude&lt;Type, ExcludedUnion&gt;</code></h2><p><code>Type</code>으로부터 type을 제외하고 모든 union 멤버가 <code>ExcludedUnion</code>으로 할당될 수 있도록 한다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = Exclude&lt;<span class="string">'a'</span> | <span class="string">'b'</span> | <span class="string">'c'</span>, <span class="string">'a'</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T0 = <span class="string">'b'</span> | <span class="string">'c'</span>;</span><br><span class="line"><span class="keyword">type</span> T1 = Exclude&lt;<span class="string">'a'</span> | <span class="string">'b'</span> | <span class="string">'c'</span>, <span class="string">'a'</span> | <span class="string">'b'</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T1 = <span class="string">'c'</span>;</span><br><span class="line"><span class="keyword">type</span> T2 = Exclude&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="function">(<span class="params">(<span class="params"></span>) =&gt; <span class="built_in">void</span></span>), <span class="params">Function</span>&gt;;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T2</span> = <span class="params">string</span> | <span class="params">number</span>;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Omit-vs-Exclude"><a href="#Omit-vs-Exclude" class="headerlink" title="Omit vs Exclude"></a>Omit vs Exclude</h2><p>아래 <code>StudentInfo</code>에 대해 Omit과 Exclude를 사용해보면 어떻게 될까?</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StudentInfo &#123;</span><br><span class="line">  isStudent: <span class="built_in">boolean</span>;</span><br><span class="line">  firstName?: <span class="built_in">string</span>;</span><br><span class="line">  lastName?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StudentInfo라는-type에-Omit을-사용해보면-다음과-같다"><a href="#StudentInfo라는-type에-Omit을-사용해보면-다음과-같다" class="headerlink" title="StudentInfo라는 type에 Omit을 사용해보면 다음과 같다."></a>StudentInfo라는 type에 Omit을 사용해보면 다음과 같다.</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> OmitStudentData &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  studentName: keyof Omit&lt;StudentInfo, <span class="string">'lastName'</span>&gt;;</span><br><span class="line">  memo: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>type Omit&lt;T, K extends string | number | symbol&gt; = { [P in Exclude&lt;keyof T, K&gt;]: T[P];}</code></p>
</blockquote>
<p>Omit은 object type인 <code>StudentInfo</code>를 취해서 type 중 특정한 타입을 제거한다. 여기서 StudentInfo의 속성 <code>{ isStudent: boolean, firstName?: string, lastName?: string }</code>중 key가 ‘lastName’인 속성을 제거하고자 했다. 따라서 결과는 아래와 같다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StudentInfo &#123;</span><br><span class="line">  isStudent: <span class="built_in">boolean</span>;</span><br><span class="line">  firstName?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="StudentInfo라는-type에-Exclude를-사용해보면-다음과-같다"><a href="#StudentInfo라는-type에-Exclude를-사용해보면-다음과-같다" class="headerlink" title="StudentInfo라는 type에 Exclude를 사용해보면 다음과 같다."></a>StudentInfo라는 type에 Exclude를 사용해보면 다음과 같다.</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ExcludeStudentData &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  studentName: Exclude&lt;keyof StudentInfo, <span class="string">'lastName'</span>&gt;;</span><br><span class="line">  memo: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>type Exclude&lt;T, U&gt; = T extends U ? never : T</code></p>
</blockquote>
<p>Exclude는 union 멤버의 구성요소를 제거한다. 여기서 Exclude는 Union Type을 취해서 StudentInfo의 Union Type은 <code>Exclude&lt;&#39;isStudent&#39; | &#39;firstName&#39; | &#39;lastName&#39; | &#39;lastName&#39;&gt;</code>와 같은 형태가 되는데, <code>&#39;lastName&#39;</code>을 제외한 나머지 <code>&lt;&#39;isStudent&#39; | &#39;firstName&#39;&gt;</code>이 union 멤버가 된다. 따라서 결과는 아래와 같다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StudentInfo &#123;</span><br><span class="line">  isStudent: <span class="built_in">boolean</span>;</span><br><span class="line">  firstName?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>Omit, Exclude를 쓴 결과는 동일하지만 과정상 Omit은 특정 속성을 제거한 결과를 제공한다는 점, Exclude는 속성을 제거하는 것이 아니라 특정 Union Type을 제외한 나머지 Union Type을 제거한다는 차이가 있다.</em></strong></p>
<hr>
<p><em>References</em><br><a href="https://www.typescriptlang.org/docs/handbook/2/keyof-types.html#the-keyof-type-operator" target="_blank" rel="noopener">The keyof type operator</a><br><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys" target="_blank" rel="noopener">Omit<Type, Keys></a><br><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#excludetype-excludedunion" target="_blank" rel="noopener">Exclude<Type, ExcludedUnion></a><br><a href="https://stackoverflow.com/questions/56916532/difference-b-w-only-exclude-and-omit-pick-exclude-typescript" target="_blank" rel="noopener">Difference b/w only Exclude and Omit (Pick &amp; Exclude) Typescript</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2021/09/25/210926_muiCssInjectionOrder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/25/210926_muiCssInjectionOrder/" class="post-title-link" itemprop="url">MUI CSS injection order 원문 축약</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-26 00:00:00" itemprop="dateCreated datePublished" datetime="2021-09-26T00:00:00+09:00">2021-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-21 23:10:05" itemprop="dateModified" datetime="2022-03-21T23:10:05+09:00">2022-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>원문 링크: <a href="https://mui.com/styles/advanced/#string-templates" target="_blank" rel="noopener">https://mui.com/styles/advanced/#string-templates</a></p>
</blockquote>
<h2 id="CSS-injection-order"><a href="#CSS-injection-order" class="headerlink" title="CSS injection order"></a>CSS injection order</h2><blockquote>
<p>CSS가 어떻게 브라우저에 의해 계산되는지 이해하는 것은 언제 스타일 오버라이딩이 되는지 알기 위한 키포인트이기 때문에 매우 중요하다. 이와 관련하여 MDN의 <a href="https://developer.mozilla.org/ko/docs/Web/CSS/Specificity" target="_blank" rel="noopener">어떻게 계산되는가?</a>를 읽어보는 것을 추천한다.</p>
</blockquote>
<p>기본적으로 style 태그는 페이지의 <code>&lt;head&gt;</code> 엘리먼트의 가장 마지막에 주입된다. 이 style 태그는 페이지의 다른 어떤 style 태그 (e.g. CSS module, styled components) 보다도 특수함을 가진다.</p>
<h2 id="injectFirst"><a href="#injectFirst" class="headerlink" title="injectFirst"></a>injectFirst</h2><p><code>StylesProvider</code> 컴포넌트는 <code>injectFirst</code> prop를 가지고 있어서 head(낮은 우선순위)에서 가장 먼저 주입되는 style tag이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StylesProvider &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span></span><br><span class="line"></span><br><span class="line">;<span class="xml"><span class="tag">&lt;<span class="name">StylesProvider</span> <span class="attr">injectFirst</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &#123;/* Your component tree.</span></span><br><span class="line"><span class="xml">      Styled components can override MUI's styles. */&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">StylesProvider</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="makeStyles-withStyles-styled"><a href="#makeStyles-withStyles-styled" class="headerlink" title="makeStyles / withStyles / styled"></a>makeStyles / withStyles / styled</h2><p>주입되는 style tag는 makeStyles / withStyles / styled가 발생하는 같은 순위에서 발생한다. 예를 들어 color red가 아래 예시에서 우세하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> clsx <span class="keyword">from</span> <span class="string">'clsx'</span></span><br><span class="line"><span class="keyword">import</span> &#123; makeStyles &#125; <span class="keyword">from</span> <span class="string">'@mui/styles'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useStylesBase = makeStyles(&#123;</span><br><span class="line">  root: &#123;</span><br><span class="line">    color: <span class="string">'blue'</span> <span class="comment">// 🔵</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useStyles = makeStyles(&#123;</span><br><span class="line">  root: &#123;</span><br><span class="line">    color: <span class="string">'red'</span> <span class="comment">// 🔴</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Order doesn't matter</span></span><br><span class="line">  <span class="keyword">const</span> classes = useStyles()</span><br><span class="line">  <span class="keyword">const</span> classesBase = useStylesBase()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Order doesn't matter</span></span><br><span class="line">  <span class="keyword">const</span> className = clsx(classes.root, classesBase.root)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// color: red 🔴 wins.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hook의 호출 순서와 class name의 연속적인 순서는 상관 없다.</p>
<h2 id="insertionPoint"><a href="#insertionPoint" class="headerlink" title="insertionPoint"></a>insertionPoint</h2><p>JSS는 이러한 상황을 해결할 수 있는 <a href="https://github.com/cssinjs/jss/blob/master/docs/setup.md#specify-the-dom-insertion-point" target="_blank" rel="noopener">매커니즘</a>을 제공한다. HTML내에 삽입점을 추가하는 것으로 CSS 규칙이 components에 <a href="https://cssinjs.org/jss-api/?v=v10.8.0#attach-style-sheets-in-a-specific-order" target="_blank" rel="noopener">적용되는 순서를 제어할 수 있다.</a></p>
<hr>
<p><em>References</em><br><a href="https://mui.com/styles/advanced/#string-templates" target="_blank" rel="noopener">CSS injection order</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2021/09/24/210925_nextjsTypescript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/24/210925_nextjsTypescript/" class="post-title-link" itemprop="url">Next.js와 TypeScript 원문 번역</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-09-25T00:00:00+09:00">2021-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-21 23:10:05" itemprop="dateModified" datetime="2022-03-21T23:10:05+09:00">2022-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>원문링크: <a href="https://nextjs.org/docs/basic-features/typescript#incremental-type-checking" target="_blank" rel="noopener">https://nextjs.org/docs/basic-features/typescript#incremental-type-checking</a></p>
</blockquote>
<h2 id="create-next-app-support"><a href="#create-next-app-support" class="headerlink" title="create-next-app support"></a>create-next-app support</h2><p>TypeScript project를 <code>create-next-app</code>과 함께 <code>--ts</code>, <code>--typescript</code> 를 사용하여 아래와 같이 생성할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app --ts</span><br><span class="line"># or</span><br><span class="line">yarn create next-app --typescript</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Existing-projects"><a href="#Existing-projects" class="headerlink" title="Existing projects"></a>Existing projects</h2><p>이미 존재하는 project에 적용하려면 root folder에 빈 <code>tsconfig.json</code> file을 생성한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch tsconfig.json</span><br></pre></td></tr></table></figure>
<p>Next.js는 자동으로 이 파일 안에 default values를 설정한다. custom <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank" rel="noopener">complier options</a>로 <code>tsconfig.json</code>을 작성하는 것 또한 지원된다.</p>
<blockquote>
<p>Next.js는 TypeScript를 핸들링하기 위해 Babel을 사용하는데 몇가지 <a href="https://babeljs.io/docs/en/babel-plugin-transform-typescript#caveats" target="_blank" rel="noopener">주의사항</a>이 있고 <a href="https://babeljs.io/docs/en/babel-plugin-transform-typescript#typescript-compiler-options" target="_blank" rel="noopener">일부 컴파일러 옵션은 다르게 처리된다.</a></p>
</blockquote>
<p><code>next(npm run dev or yarn dev)</code>를 실행하면, Next.js가 setup을 완료하기 위해 설치가 필요한 패키지를 안내한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line"># You&#39;ll see instructions like these:</span><br><span class="line">#</span><br><span class="line"># Please install typescript, @types&#x2F;react, and @types&#x2F;node by running:</span><br><span class="line">#</span><br><span class="line">#         yarn add --dev typescript @types&#x2F;react @types&#x2F;node</span><br><span class="line">#</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>
<p>이렇게 하면 <code>.js</code> 파일을 <code>.tsx</code>로 전환할 준비가 완료되었고, TypeScript를 사용할 수 있게 된다.</p>
<hr>
<blockquote>
<p><code>next-env.d.ts</code>라는 이름의 파일이 프로젝트의 root에 생성된다. 이 파일은 TypeScript complier가 Next.js의 type을 선택하도록 한다. 이는 매번 변경되므로 <strong>임의로 삭제하거나 편집하지 않도록 한다.</strong></p>
<p>TypeScript <code>strict</code> 모드는 기본적으로 꺼져있다. TypeScript를 편하게 사용하려면 <code>tsconfig.json</code>파일 내에 이 모드를 켜도록 한다.</p>
<p><code>next-env.d.ts</code>를 편집하는 대신 <code>additional.d.ts</code>와 같은 새 파일을 추가한 다음, <code>tsconfig.json</code> 의 <a href="https://www.typescriptlang.org/tsconfig#include" target="_blank" rel="noopener">include</a> 배열에서 참조하여 새로운 타입 유형을 추가할 수 있다.</p>
</blockquote>
<p>기본적으로 Next.js는 <code>next build</code>의 일부로 type checking를 수행한다. 개발하는 동안에는 code editior를 이용하여 type checking을 할 것을 추천한다.</p>
<p>만약 error report를 무시하고 싶다면, <a href="https://nextjs.org/docs/api-reference/next.config.js/ignoring-typescript-errors" target="_blank" rel="noopener">Ignoring TypeScript errors</a>와 관련된 문서를 확인하도록 한다.</p>
<hr>
<h2 id="Static-Generation-and-Server-side-Rendering"><a href="#Static-Generation-and-Server-side-Rendering" class="headerlink" title="Static Generation and Server-side Rendering"></a>Static Generation and Server-side Rendering</h2><p><code>getStaticProps</code>, <code>getStaticPaths</code>, <code>getServerSideProps</code>을 위해 각각 <code>getStaticProps</code>, <code>getStaticPaths</code>, <code>getServerSideProps</code> type을 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; GetStaticProps, GetStaticPaths, GetServerSideProps &#125; <span class="keyword">from</span> <span class="string">'next'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getStaticProps: GetStaticProps = <span class="keyword">async</span> (context) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getStaticPaths: GetStaticPaths = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getServerSideProps: GetServerSideProps = <span class="keyword">async</span> (context) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>만약 <code>getInitialProps</code>를 사용하려면 <a href="https://nextjs.org/docs/api-reference/data-fetching/getInitialProps#typescript" target="_blank" rel="noopener">이 링크</a>를 참조한다.</p>
</blockquote>
<hr>
<h2 id="API-Routes"><a href="#API-Routes" class="headerlink" title="API Routes"></a>API Routes</h2><p>아래 예제는 API routes의 빌트인 타입을 사용하는 방법이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> type &#123; NextApiRequest, NextApiResponse &#125; <span class="keyword">from</span> <span class="string">'next'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (req: NextApiRequest, <span class="attr">res</span>: NextApiResponse) =&gt; &#123;</span><br><span class="line">  res.status(<span class="number">200</span>).json(&#123; <span class="attr">name</span>: <span class="string">'John Doe'</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>reponse data에 type을 사용할 수도 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> type &#123; NextApiRequest, NextApiResponse &#125; <span class="keyword">from</span> <span class="string">'next'</span>;</span><br><span class="line"></span><br><span class="line">type Data = &#123;</span><br><span class="line">  name: string,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (req: NextApiRequest, <span class="attr">res</span>: NextApiResponse&lt;Data&gt;) =&gt; &#123;</span><br><span class="line">  res.status(<span class="number">200</span>).json(&#123; <span class="attr">name</span>: <span class="string">'John Doe'</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Custom-App"><a href="#Custom-App" class="headerlink" title="Custom App"></a>Custom App</h2><p>만약 <a href="https://nextjs.org/docs/advanced-features/custom-app" target="_blank" rel="noopener">custom App</a>을 사용한다면 빌트인 타입인 <code>AppProps</code>를 사용할 수 있고 파일 이름을 <code>./pages/_app.tsx</code>와 같이 변경할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import App from "next/app";</span></span><br><span class="line"><span class="keyword">import</span> type &#123; AppProps <span class="comment">/*, AppContext */</span> &#125; <span class="keyword">from</span> <span class="string">'next/app'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params">&#123; Component, pageProps &#125;: AppProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only uncomment this method if you have blocking data requirements for</span></span><br><span class="line"><span class="comment">// every single page in your application. This disables the ability to</span></span><br><span class="line"><span class="comment">// perform automatic static optimization, causing every page in your app to</span></span><br><span class="line"><span class="comment">// be server-side rendered.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// MyApp.getInitialProps = async (appContext: AppContext) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   // calls page's `getInitialProps` and fills `appProps.pageProps`</span></span><br><span class="line"><span class="comment">//   const appProps = await App.getInitialProps(appContext);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   return &#123; ...appProps &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyApp;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Path-aliases-and-baseUrl"><a href="#Path-aliases-and-baseUrl" class="headerlink" title="Path aliases and baseUrl"></a>Path aliases and baseUrl</h2><p>Next.js는 자동으로 tsconfig.json <code>paths</code>와 <code>baseUrl</code> 옵션을 제공한다. Module Path aliases와 관련된 특징을 더 알아보고 싶다면 <a href="https://nextjs.org/docs/advanced-features/module-path-aliases" target="_blank" rel="noopener">이 링크</a>를 참조한다.</p>
<h2 id="Type-checking-next-config-js"><a href="#Type-checking-next-config-js" class="headerlink" title="Type checking next.config.js"></a>Type checking next.config.js</h2><p><code>next.config.js</code> 파일은 반드시 JavaScript 파일이어야 하고, Babel이나 TypeScript로 parse되어서는 안된다.하지만 아래와 같이 JSDoc를 이용해서 IDE에서의 몇 가지 type checking를 추가할 수는 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @ts-check</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @type &#123;import(&#39;next&#39;).NextConfig&#125;</span><br><span class="line"> **&#x2F;</span><br><span class="line">const nextConfig &#x3D; &#123;</span><br><span class="line">  &#x2F;* config options here *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; nextConfig</span><br></pre></td></tr></table></figure>
<h2 id="Incremental-type-checking"><a href="#Incremental-type-checking" class="headerlink" title="Incremental type checking"></a>Incremental type checking</h2><p><code>v10.2.1</code>부터 Next.js는 <a href="https://www.typescriptlang.org/tsconfig#incremental" target="_blank" rel="noopener">incremental type checking</a>를 <code>tsconfig.json</code>에서 사용할 수 있도록 지원한다. 이는 대규모 application에서 type checking을 빠르게 할 수 있도록 돕는다. 최소한 <code>v4.3.2</code>이상의 TypeScript를 사용하고 있다면 최고의 성능을 경험하기 위해 이를 사용하는 것이 추천된다.</p>
<hr>
<p><em>References</em><br><a href="https://nextjs.org/docs/basic-features/typescript#incremental-type-checking" target="_blank" rel="noopener">Next.js - TypeScript</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Heejin Lee</p>
  <div class="site-description" itemprop="description">Today I Learned</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">119</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heejin Lee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
