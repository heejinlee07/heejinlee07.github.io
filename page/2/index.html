<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heejinlee07.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Today I Learned">
<meta property="og:type" content="website">
<meta property="og:title" content="Heejin">
<meta property="og:url" content="https://heejinlee07.github.io/page/2/index.html">
<meta property="og:site_name" content="Heejin">
<meta property="og:description" content="Today I Learned">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Heejin Lee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://heejinlee07.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Heejin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heejin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Front-end Development</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/08/23/200824_promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/23/200824_promise/" class="post-title-link" itemprop="url">Promise</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-24 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-24T00:00:00+09:00">2020-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-06 01:09:52" itemprop="dateModified" datetime="2021-01-06T01:09:52+09:00">2021-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="프로미스의-등장"><a href="#프로미스의-등장" class="headerlink" title="프로미스의 등장"></a>프로미스의 등장</h2><p>자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다. 하지만 전통적인 콜백 패턴은 콜백 헬로 인해 가독성이 나쁘고 비동기 처리 중 발생한 에러의 처리가 곤란하며 여러 개의 비동기 처리를 한번에 처리하는 데도 한계가 있다. ES6에서는 비동기 처리를 위한 또 다른 패턴으로 프로미스(Promise)를 도입했다. <strong>프로미스는 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다.</strong></p>
<h2 id="프로미스의-생성"><a href="#프로미스의-생성" class="headerlink" title="프로미스의 생성"></a>프로미스의 생성</h2><p>Promise 생성자 함수를 new 연산자와 함께 호출하면 프로미스(<code>Promise 객체: 비동기 처리 상태와 처리 결과를 관리</code>)를 생성한다. Promise 객체는 비동기 작업이 맞이할 미래의 완료 또는 실패, 그 결과 값을 나타낸다. 또한 비동기 액션이 종료된 이후, 성공했을 때의 value나 실패 이유를 처리하기 위한 handler를 연결할 수 있도록 한다. <strong>이처럼 프로미스를 사용하면 비동기 메서드에서도 동기 메서드처럼 최종 value를 반환할 수 있다.</strong> 다만 즉시 최종 value를 반환하지는 않고, 비동기 메서드가 프로미스를 반환하면 프로미스가 미래의 어떤 시점에 받을 value를 제공한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로미스 생성</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Promise 함수의 콜백 함수 내부에서 비동기 처리를 수행한다.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 비동기 처리 성공 */</span>) &#123;</span><br><span class="line">    resolve(<span class="string">'result'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 비동기 처리 실패 */</span></span><br><span class="line">    reject(<span class="string">'failure reason'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="프로미스의-상태"><a href="#프로미스의-상태" class="headerlink" title="프로미스의 상태"></a>프로미스의 상태</h2><p>프로미스가 생성된 후 기본적으로 pending 상태를 가지고, 비동기 처리 수행의 성공 또는 실패에 따라 아래와 같이 상태가 변경된다. 그리고 필연적으로 아래 상태에 따라 resolved 되거나 unresolved된다.</p>
<p><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt="promise"><br>[사진출처 - MDN]</p>
<ul>
<li>대기(pending): 비동기 처리가 이행하거나 거부되지 않은 초기 상태.</li>
<li>이행(fulfilled): 비동기 처리가 성공적으로 완료됨.</li>
<li>거부(rejected): 비동기 처리가 실패함.</li>
<li>settled: 비동기 처리가 수행되었고, pending이 아니면서 fulfilled 또는 rejected일 때를 말한다. <strong>settled는 상태가 아니다.</strong> 표현의 편의를 위한 언어적 표현일 뿐이다. 일단 settled 상태가 되면 더는 다른 상태로 변화할 수 없다.</li>
</ul>
<table>
<thead>
<tr>
<th align="center">states</th>
<th align="center">meaning</th>
<th align="center">value</th>
<th align="center">condition</th>
<th>fates</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fulfilled</td>
<td align="center">비동기 처리가 수행된 상태 (성공)</td>
<td align="center">처리결과값</td>
<td align="center">resolve 호출</td>
<td>resolved</td>
</tr>
<tr>
<td align="center">rejected</td>
<td align="center">비동기 처리가 수행된 상태 (실패)</td>
<td align="center">에러</td>
<td align="center">reject 호출</td>
<td>resolved</td>
</tr>
<tr>
<td align="center">pending</td>
<td align="center">비동기 처리 수행 전, fulfilled도 아니고, rejected도 아닌 상태</td>
<td align="center">undefined</td>
<td align="center">프로미스 생성직후 기본 상태</td>
<td>unresolved or resolved</td>
</tr>
</tbody></table>
<hr>
<h2 id="프로미스의-후속-처리-메서드"><a href="#프로미스의-후속-처리-메서드" class="headerlink" title="프로미스의 후속 처리 메서드"></a>프로미스의 후속 처리 메서드</h2><p>프로미스가 fulfilled 상태이거나 rejected 상태 일 때 이에 대한 후속 처리가 필요하다. 이처럼 프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수를 선택적으로 호출하고, <strong>모든 후속 처리 메서드는 프로미스를 반환하며 비동기로 동작한다.</strong></p>
<h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h3><p><strong>언제나 Promise를 return하고, 두 개의 콜백 함수를 인수로 전달받는다.</strong> 그리고 Promise가 이행하거나 거부했을 때, 각각에 해당하는 핸들러 함수(onFulfilled나 onRejected)가 비동기적으로 실행된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p.then(onFulfilled, onRejected);</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 이행</span></span><br><span class="line">    <span class="comment">// onFulfilled: Promise가 수행될 때 호출되는 Function</span></span><br><span class="line">    <span class="comment">// 인수: 이행 값(fulfillment value)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 거부</span></span><br><span class="line">    <span class="comment">// onRejected: Promise가 거부될 때 호출되는 Function</span></span><br><span class="line">    <span class="comment">// 인수: 거부 이유(rejection reason)</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><u>반환값</u></p>
<ul>
<li>① fulfilled 상태: 비동기 처리 성공(이행). 프로미스의 비동기 처리 결과를 콜백함수의 인수로 받음.</li>
<li>② rejected 상태: 비동기 처리 실패(거부). 프로미스의 에러를 인수로 전달받음.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fulfilled ①</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="string">"fulfilled"</span>)).then(</span><br><span class="line">  (v) =&gt; <span class="built_in">console</span>.log(v),</span><br><span class="line">  (e) =&gt; <span class="built_in">console</span>.error(e)</span><br><span class="line">); <span class="comment">// fulfilled</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rejected ②</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_, reject</span>) =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"rejected"</span>))).then(</span><br><span class="line">  (v) =&gt; <span class="built_in">console</span>.log(v),</span><br><span class="line">  (e) =&gt; <span class="built_in">console</span>.error(e)</span><br><span class="line">); <span class="comment">// Error: rejected</span></span><br></pre></td></tr></table></figure>

<p>Promise가 이행하거나 거부했을 때, 각각에 해당하는 핸들러 함수(onFulfilled나 onRejected)가 비동기적으로 실행되는 조건은 다음과 같다.</p>
<table>
<thead>
<tr>
<th align="center">반환조건</th>
<th align="center">반환값</th>
</tr>
</thead>
<tbody><tr>
<td align="center">함수가 값을 반환</td>
<td align="center">then에서 반환한 프로미스의 반환값</td>
</tr>
<tr>
<td align="center">값을 반환하지 않음</td>
<td align="center">undefined</td>
</tr>
<tr>
<td align="center">오류 발생</td>
<td align="center">then에서 반환한 프로미스의 오류값</td>
</tr>
<tr>
<td align="center">이미 이행한 프로미스 반환</td>
<td align="center">then에서 반환한 프로미스의 결과값</td>
</tr>
<tr>
<td align="center">이미 거부한 프로미스 반환</td>
<td align="center">then에서 반환한 프로미스의 결과값으로 거부</td>
</tr>
<tr>
<td align="center">대기 중인 프로미스 반환</td>
<td align="center">프로미스의 이행 여부와 결과값</td>
</tr>
</tbody></table>
<h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h3><p><strong>한 개의 콜백 함수를 인수로 전달받고, 프로미스가 <code>rejected</code>일 때만 호출된다.</strong> 그리고 언제나 프로미스를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p.catch(onRejected);</span><br><span class="line"></span><br><span class="line">p.catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// rejection</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// rejected</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_, reject</span>) =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"rejected"</span>))).catch(<span class="function">(<span class="params">e</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">); <span class="comment">// Error: rejected</span></span><br></pre></td></tr></table></figure>

<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h3><p>언제나 프로미스를 반환하고, <strong>한 개의 콜백함수를 인수로 전달받으며, 프로미스의 성공, 실패와 상관없이 무조건 한 번 호출된다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"finally"</span>)); <span class="comment">// finally</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="프로미스-체이닝"><a href="#프로미스-체이닝" class="headerlink" title="프로미스 체이닝"></a>프로미스 체이닝</h2><p>후속처리 메서드인 then, catch, finally는 언제나 프로미스를 반환하므로 연속적으로 호출할 수 있다. 이를 프로미스 체이닝이라 한다. 만약 후속 처리 메서드의 콜백 함수가 프로미스가 아닌 값을 반환하더라도 그 값을 암묵적으로 resolve 또는 reject하여 프로미스를 생성하여 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">"https://jsonplaceholder.typicode.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// id가 1인 post의 userId를 취득</span></span><br><span class="line">promiseGet(<span class="string">`<span class="subst">$&#123;url&#125;</span>/posts/1`</span>)</span><br><span class="line">  <span class="comment">// 취득한 post의 userId로 user 정보를 취득</span></span><br><span class="line">  <span class="comment">//userId: promiseGet 함수가 반환한 프로미스가 resolve한 값</span></span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; userId &#125;</span>) =&gt;</span> promiseGet(<span class="string">`<span class="subst">$&#123;url&#125;</span>/users/<span class="subst">$&#123;userId&#125;</span>`</span>))</span><br><span class="line">  <span class="comment">//return: 콜백 함수가 반환한 프로미스</span></span><br><span class="line">  <span class="comment">//userInfo: 첫 번째 then 메서드가 반한한 프로미스가 resolve한 값</span></span><br><span class="line">  .then(<span class="function">(<span class="params">userInfo</span>) =&gt;</span> <span class="built_in">console</span>.log(userInfo))</span><br><span class="line">  <span class="comment">//return: 콜백 함수가 반환한 값(undefined)을 resolve한 프로미스</span></span><br><span class="line">  <span class="comment">//err: promiseGet 함수 또는 앞선 후속 처리 메서드가 반환한 프로미스가 reject한 값</span></span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.error(err));</span><br><span class="line"><span class="comment">//return: 콜백 함수가 반환한 값(undefined)을 resolve한 프로미스</span></span><br></pre></td></tr></table></figure>

<hr>
<p><em>References</em><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">MDN</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener">MDN</a><br><a href="https://poiemaweb.com/fastcampus/promise" target="_blank" rel="noopener">poiemaweb</a><br><a href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md" target="_blank" rel="noopener">States and fates</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/08/23/200823_event_propa_del/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/23/200823_event_propa_del/" class="post-title-link" itemprop="url">이벤트 전파와 위임</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-23 13:00:00" itemprop="dateCreated datePublished" datetime="2020-08-23T13:00:00+09:00">2020-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-06 01:09:52" itemprop="dateModified" datetime="2021-01-06T01:09:52+09:00">2021-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="이벤트-전파"><a href="#이벤트-전파" class="headerlink" title="이벤트 전파"></a>이벤트 전파</h2><p>특정 요소를 클릭해서 클릭 이벤트가 발생했을 때 생성된 이벤트 객체가 이벤트를 발생시킨 DOM 요소인 이벤트 타겟을 중심으로 DOM 트리를 통해 전파되는 현상을 말한다. DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다.</p>
<ul>
<li>1️⃣캡처링 단계(capturing phase) : 이벤트가 <code>상위 요소(window)</code>에서 <code>하위 요소</code> 방향으로 전파</li>
<li>2️⃣타깃 단계(target phase) : 이벤트가 이벤트 타깃에 도달</li>
<li>3️⃣버블링 단계(bubbling phase) : 이벤트가 <code>하위 요소</code>에서 <code>상위 요소(window)</code> 방향으로 전파</li>
</ul>
<h3 id="이벤트-핸들러-어트리뷰트-프로퍼티-방식에서의-이벤트-전파"><a href="#이벤트-핸들러-어트리뷰트-프로퍼티-방식에서의-이벤트-전파" class="headerlink" title="이벤트 핸들러 어트리뷰트/프로퍼티 방식에서의 이벤트 전파"></a>이벤트 핸들러 어트리뷰트/프로퍼티 방식에서의 이벤트 전파</h3><p>이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록한 이벤트 핸들러는 <code>타깃 단계, 버블링 단계</code>의 이벤트만 캐치한다. 캡처링 단계는 캐치하지 못한다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $fruits = <span class="built_in">document</span>.getElementById(<span class="string">"fruits"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $banana = <span class="built_in">document</span>.getElementById(<span class="string">"banana"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// #fruits 요소의 하위 요소인 li 요소를 클릭한 경우 캡처링 단계의 이벤트를 캐치한다.</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 그러나 이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록하였기 때문에 캡처링 단계를 캡처하지 못한다.</span></span></span><br><span class="line"><span class="javascript">      $fruits.onclick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 단계: <span class="subst">$&#123;e.eventPhase&#125;</span>`</span>); <span class="comment">// 3: 버블링 단계</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 타깃: <span class="subst">$&#123;e.target&#125;</span>`</span>); <span class="comment">// [object HTMLLIElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`커런트 타깃: <span class="subst">$&#123;e.currentTarget&#125;</span>`</span>); <span class="comment">// [object HTMLUListElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.composedPath());</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 타깃 단계의 이벤트를 캐치한다.</span></span></span><br><span class="line"><span class="javascript">      $banana.onclick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 단계: <span class="subst">$&#123;e.eventPhase&#125;</span>`</span>); <span class="comment">// 2: 타깃 단계</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 타깃: <span class="subst">$&#123;e.target&#125;</span>`</span>); <span class="comment">// [object HTMLLIElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`커런트 타깃: <span class="subst">$&#123;e.currentTarget&#125;</span>`</span>); <span class="comment">// [object HTMLLIElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.composedPath());</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 버블링 단계의 이벤트를 캐치한다.</span></span></span><br><span class="line"><span class="javascript">      $fruits.onclick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 단계: <span class="subst">$&#123;e.eventPhase&#125;</span>`</span>); <span class="comment">// 3: 버블링 단계</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 타깃: <span class="subst">$&#123;e.target&#125;</span>`</span>); <span class="comment">// [object HTMLLIElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`커런트 타깃: <span class="subst">$&#123;e.currentTarget&#125;</span>`</span>); <span class="comment">// [object HTMLUListElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.composedPath());</span></span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="addEventListener-메서드-방식에서의-이벤트-전파"><a href="#addEventListener-메서드-방식에서의-이벤트-전파" class="headerlink" title="addEventListener 메서드 방식에서의 이벤트 전파"></a>addEventListener 메서드 방식에서의 이벤트 전파</h3><p><em>addEventListener 메서드 방식</em>으로 등록하면 <code>타깃 단계, 버블링 단계, 캡처링 단계를 선별적으로 캐치</code>할 수 있다. 캡처링 단계의 이벤트를 캐치하려면 addEventListener 메서드의 3번째 인수로 true를 전달한다. 3번째 인수를 생략하거나 false를 전달하면 타깃 단계와 버블링 단계의 이벤트만 캐치할 수 있다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $fruits = <span class="built_in">document</span>.getElementById(<span class="string">"fruits"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $banana = <span class="built_in">document</span>.getElementById(<span class="string">"banana"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// #fruits 요소의 하위 요소인 li 요소를 클릭한 경우 캡처링 단계의 이벤트를 캐치한다.</span></span></span><br><span class="line">      $fruits.addEventListener(</span><br><span class="line"><span class="actionscript">        <span class="string">"click"</span>,</span></span><br><span class="line">        (e) =&gt; &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">`이벤트 단계: <span class="subst">$&#123;e.eventPhase&#125;</span>`</span>); <span class="comment">// 1: 캡처링 단계</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">`이벤트 타깃: <span class="subst">$&#123;e.target&#125;</span>`</span>); <span class="comment">// [object HTMLLIElement]</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">`커런트 타깃: <span class="subst">$&#123;e.currentTarget&#125;</span>`</span>); <span class="comment">// [object HTMLUListElement]</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="literal">true</span></span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 타깃 단계의 이벤트를 캐치한다.</span></span></span><br><span class="line"><span class="actionscript">      $banana.addEventListener(<span class="string">"click"</span>, (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 단계: <span class="subst">$&#123;e.eventPhase&#125;</span>`</span>); <span class="comment">// 2: 타깃 단계</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 타깃: <span class="subst">$&#123;e.target&#125;</span>`</span>); <span class="comment">// [object HTMLLIElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`커런트 타깃: <span class="subst">$&#123;e.currentTarget&#125;</span>`</span>); <span class="comment">// [object HTMLLIElement]</span></span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 버블링 단계의 이벤트를 캐치한다.</span></span></span><br><span class="line"><span class="actionscript">      $fruits.addEventListener(<span class="string">"click"</span>, (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 단계: <span class="subst">$&#123;e.eventPhase&#125;</span>`</span>); <span class="comment">// 3: 버블링 단계</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 타깃: <span class="subst">$&#123;e.target&#125;</span>`</span>); <span class="comment">// [object HTMLLIElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`커런트 타깃: <span class="subst">$&#123;e.currentTarget&#125;</span>`</span>); <span class="comment">// [object HTMLUListElement]</span></span></span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>대부분의 이벤트는 캡처링과 버블링을 통해 전파되는데, 아래 이벤트는 버블링을 통해 전파되지 않는다. 필요할 가능성은 희박하지만 만약 아래 이벤트를 상위 요소에서 캐치해야 한다면 다른 이벤트를 통해 대체해야 한다.</p>
<ul>
<li>포커스 이벤트: focus/blur</li>
<li>리소스 이벤트: load/unload/abort/error</li>
<li>마우스 이벤트: mouseenter/mouseleave</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $fruits = <span class="built_in">document</span>.getElementById(<span class="string">"fruits"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $banana = <span class="built_in">document</span>.getElementById(<span class="string">"banana"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 1️⃣click</span></span></span><br><span class="line"><span class="actionscript">      $fruits.addEventListener(<span class="string">"click"</span>, (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 단계: <span class="subst">$&#123;e.eventPhase&#125;</span>`</span>); <span class="comment">// 3: 버블링 단계</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 타깃: <span class="subst">$&#123;e.target&#125;</span>`</span>); <span class="comment">// [object HTMLLIElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`커런트 타깃: <span class="subst">$&#123;e.currentTarget&#125;</span>`</span>); <span class="comment">// [object HTMLUListElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.bubbles); <span class="comment">//true</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.composedPath()); <span class="comment">//[li#orange, ul#fruits, body, html, document, Window]</span></span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 2️⃣mouseleave</span></span></span><br><span class="line"><span class="actionscript">      $fruits.addEventListener(<span class="string">"mouseleave"</span>, (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 단계: <span class="subst">$&#123;e.eventPhase&#125;</span>`</span>); <span class="comment">// 2: 타깃 단계</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 타깃: <span class="subst">$&#123;e.target&#125;</span>`</span>); <span class="comment">// [object HTMLLIElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`커런트 타깃: <span class="subst">$&#123;e.currentTarget&#125;</span>`</span>); <span class="comment">// [object HTMLUListElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.bubbles); <span class="comment">//false</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.composedPath()); <span class="comment">// [ul#fruits, body, html, document, Window]</span></span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">//3️⃣mouseover</span></span></span><br><span class="line"><span class="actionscript">      $fruits.addEventListener(<span class="string">"mouseover"</span>, (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 단계: <span class="subst">$&#123;e.eventPhase&#125;</span>`</span>); <span class="comment">// 3: 버블링 단계</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`이벤트 타깃: <span class="subst">$&#123;e.target&#125;</span>`</span>); <span class="comment">// [object HTMLLIElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`커런트 타깃: <span class="subst">$&#123;e.currentTarget&#125;</span>`</span>); <span class="comment">// [object HTMLUListElement]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.bubbles); <span class="comment">//true</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.composedPath()); <span class="comment">//[li#orange, ul#fruits, body, html, document, Window]</span></span></span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>event.bubbles: 버블링을 통해 이벤트를 전파하는지 여부를 불리언으로 나타냄.</li>
<li>event.composedPath(): 이벤트가 통과하는 DOM 트리 상의 경로 확인</li>
</ul>
</blockquote>
<ul>
<li>1️⃣click: 버블링 단계의 이벤트를 캐치한다. event.bubbles = true;</li>
<li>2️⃣mouseleave: 이 이벤트는 버블링을 통해 전파되지 않으므로 버블링 단계의 이벤트를 캐치하지 못한다. event.bubbles = false;</li>
<li>3️⃣mouseover: mouseleave를 mouseover로 변경하면 버블링 단계의 이벤트를 캐치할 수 있다. event.bubbles = true;</li>
</ul>
<hr>
<h2 id="이벤트-위임"><a href="#이벤트-위임" class="headerlink" title="이벤트 위임"></a>이벤트 위임</h2><p>이벤트는 전파되므로 이벤트 타깃은 물론 상위 DOM에서도 캐치할 수 있다. 이 점을 이용하여 여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법이다. 이렇게 하면 동적으로 하위 DOM 요소를 추가하더라도 여기에 이벤트 핸들러를 일일이 등록할 필요가 없다.</p>
<blockquote>
<p><u>이벤트 위임의 장점</u></p>
<ul>
<li>동적인 엘리먼트에 대한 이벤트 처리가 수월하다.</li>
<li>이벤트 핸들러 관리가 쉽다.</li>
<li>메모리 사용량이 줄어들고, 메모리 누수 가능성도 줄어든다.</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-id">#fruits</span> &#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">        list-style-type: none;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-id">#fruits</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">        width: 100px;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-id">#fruits</span> <span class="selector-class">.active</span> &#123;</span></span><br><span class="line">        color: red;</span><br><span class="line">        text-decoration: underline;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"apple"</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>선택된 내비게이션 아이템: <span class="tag">&lt;<span class="name">em</span> <span class="attr">class</span>=<span class="string">"msg"</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $fruits = <span class="built_in">document</span>.getElementById(<span class="string">"fruits"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $msg = <span class="built_in">document</span>.querySelector(<span class="string">".msg"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 사용자 클릭에 의해 선택된 내비게이션 아이템(li 요소)에 active 클래스를 추가하고</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 그 외의 모든 내비게이션 아이템의 active 클래스를 제거한다.</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">activate</span><span class="params">(&#123; target &#125;)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        [...$fruits.children].forEach(<span class="function">(<span class="params">$fruit</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">          $fruit.classList.toggle(<span class="string">"active"</span>, $fruit === target);</span></span><br><span class="line">          $msg.textContent = target.id;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="comment">// 모든 내비게이션 아이템(li 요소)에 이벤트 핸들러를 등록한다.</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">"apple"</span>).onclick = activate;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">"banana"</span>).onclick = activate;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">"orange"</span>).onclick = activate;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>만약 이벤트 위임을 하지 않으면 위와 같이 이벤트 핸들러 등록이 필요한 모든 요소에 일일이 이벤트 핸들러를 등록해주어야 한다. 이는 메모리 누수와 같은 성능 저하의 원인이 되고, 유지보수에도 적합하지 않다. 이벤트 위임의 장점은 같은 코드를 이벤트 위임으로 변경한 아래 예제에서 확인할 수 있다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// &#123;...위와 동일한 코드&#125;</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $fruits = <span class="built_in">document</span>.getElementById(<span class="string">"fruits"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $msg = <span class="built_in">document</span>.querySelector(<span class="string">".msg"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">     <span class="function"><span class="keyword">function</span> <span class="title">activate</span><span class="params">(&#123; target &#125;)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 이벤트를 발생시킨 요소(target)가 ul#fruits의 자식 요소가 아니라면 무시한다.</span></span></span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">      상위 요소에 이벤트 핸들러를 등록할 때, 이벤트 타깃이 내가 기대한 DOM요소가 아닐 수도 있기 때문에</span><br><span class="line">      matches로 해당하는 이벤트 타깃이 있는지 확인한다.</span><br><span class="line">      matches: 인수로 전달된 선택자에 의해 특정 노드가 탐색 가능한지 확인한다.</span><br><span class="line">      */</span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (!target.matches(<span class="string">'#fruits &gt; li'</span>)) <span class="keyword">return</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      [...$fruits.children].forEach(<span class="function"><span class="params">$fruit</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">        $fruit.classList.toggle(<span class="string">'active'</span>, $fruit === target);</span></span><br><span class="line">        $msg.textContent = target.id;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 이벤트 위임: 상위 요소(ul#fruits)는 하위 요소의 이벤트를 캐치할 수 있다.</span></span></span><br><span class="line">    /*</span><br><span class="line">    이벤트 객체의 currentTarget: 언제나 $fruits 요소</span><br><span class="line">    target 프로퍼티: 실제로 이벤트를 발생시킨 DOM 요소</span><br><span class="line">    두 가지가 서로 다른 DOM 요소를 가리킬 수도 있으므로 확실하게 하기 위해 $fruits에 이벤트를 바인딩한다.</span><br><span class="line">    */</span><br><span class="line">    $fruits.onclick = activate;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><em>References</em><br><a href="https://poiemaweb.com/fastcampus/event" target="_blank" rel="noopener">이벤트</a><br><a href="https://ui.toast.com/weekly-pick/ko_20160826/" target="_blank" rel="noopener">왜 이벤트 위임(delegation)을 해야 하는가?</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/08/20/200821_callback/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/20/200821_callback/" class="post-title-link" itemprop="url">콜백패턴의 문제점</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-21 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-21T00:00:00+09:00">2020-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-06 01:09:52" itemprop="dateModified" datetime="2021-01-06T01:09:52+09:00">2021-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>자바스크립트에서 비동기 처리 : 콜백함수<br>ES6에서 비동기 처리 : 프로미스</p>
</blockquote>
<h2 id="자바스크립트에서-비동기-처리-콜백함수의-단점"><a href="#자바스크립트에서-비동기-처리-콜백함수의-단점" class="headerlink" title="자바스크립트에서 비동기 처리 : 콜백함수의 단점"></a>자바스크립트에서 비동기 처리 : 콜백함수의 단점</h2><p>비동기 함수 내부에서 비동기로 동작하는 코드가 있다면 코드가 완료되지 않았더라도 기다리지 않고 즉시 종료된다. 즉, 비동기 함수 내부의 비동기로 동작하는 코드는 비동기 함수가 종료된 후에 완료된다.<strong>따라서 비동기 함수 내부의 비동기로 동작하는 코드는 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당해도 기대한 대로 동작하지 않는다.</strong></p>
<h3 id="서버의-응답-결과를-콘솔에-출력하는-get-함수-✅"><a href="#서버의-응답-결과를-콘솔에-출력하는-get-함수-✅" class="headerlink" title="서버의 응답 결과를 콘솔에 출력하는 get 함수 ✅"></a>서버의 <code>응답 결과를 콘솔에 출력</code>하는 get 함수 ✅</h3><ul>
<li>get 함수: 비동기 함수 (비동기로 동작하는 코드인 이벤트 핸들러 <code>onload</code>를 포함하고 있음.)</li>
<li>onload: 비동기로 동작</li>
<li>처리 순서: <code>get 함수 호출</code> -&gt; <code>GET 요청을 서버에 전송</code> -&gt; <code>onload 이벤트 핸들러 등록</code> -&gt;<u><code>undefined반환</code></u> -&gt; <u><code>즉시 종료</code></u></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 서버의 응답 결과를 콘솔에 출력하는 코드 ✅</span></span><br><span class="line"><span class="comment">// GET 요청을 위한 비동기 함수</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = (url) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">"GET"</span>, url);</span><br><span class="line">  xhr.send();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 비동기로 동작하는 onload</span></span><br><span class="line">  xhr.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// 서버의 응답을 콘솔에 출력한다.</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(xhr.response));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`<span class="subst">$&#123;xhr.status&#125;</span> <span class="subst">$&#123;xhr.statusText&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// id가 1인 post를 취득</span></span><br><span class="line"><span class="keyword">get</span>("https://jsonplaceholder.typicode.com/posts/1");</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="서버의-응답-결과를-반환하는-get-함수-✅"><a href="#서버의-응답-결과를-반환하는-get-함수-✅" class="headerlink" title="서버의 응답 결과를 반환하는 get 함수 ✅"></a>서버의 <code>응답 결과를 반환</code>하는 get 함수 ✅</h3><ul>
<li>get 함수: 비동기 함수 (비동기로 동작하는 코드인 이벤트 핸들러 <code>onload</code>를 포함하고 있음.)</li>
<li>onload: 비동기로 동작</li>
<li>처리순서: <code>get 함수 호출</code> -&gt; <code>GET 요청을 서버에 전송</code> -&gt; <code>onload 이벤트 핸들러 등록</code> -&gt; <u><code>종료</code> -&gt; <code>undefined반환</code></u></li>
</ul>
<p>반환문인 <code>return JSON.parse(xhr.response);</code>은 <em>onload 이벤트 핸들러의 반환문이지 get 함수의 반환문이 아니다.</em> 따라서 get 함수에 대한 명시적인 반환문이 없으므로 <code>undefined</code>를 반환한다. 즉 onload 이벤트 핸들러의 반환값은 캐치할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 서버의 응답 결과를 반환하는 코드 ✅</span></span><br><span class="line"><span class="comment">// GET 요청을 위한 비동기 함수</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = (url) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">"GET"</span>, url);</span><br><span class="line">  xhr.send();</span><br><span class="line"></span><br><span class="line">  xhr.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// ① 서버의 응답을 반환한다.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(xhr.response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`<span class="subst">$&#123;xhr.status&#125;</span> <span class="subst">$&#123;xhr.statusText&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ② id가 1인 post를 취득</span></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">get</span>("https://jsonplaceholder.typicode.com/posts/1");</span><br><span class="line">console.log(response); // undefined</span><br></pre></td></tr></table></figure>

<p>만약 get 함수의 상위에 변수를 선언한 후 onload 이벤트 내부에서 서버의 응답 결과를 할당하더라도 여전히 결과는 <code>undefined</code>이다. 그 이유는 처리 순서가 보장되지 않기 때문이다.</p>
<h3 id="서버의-응답을-상위-스코프-변수에-할당한다면-✅"><a href="#서버의-응답을-상위-스코프-변수에-할당한다면-✅" class="headerlink" title="서버의 응답을 상위 스코프 변수에 할당한다면? ✅"></a>서버의 응답을 <code>상위 스코프 변수에 할당</code>한다면? ✅</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET 요청을 위한 비동기 함수</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = (url) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">"GET"</span>, url);</span><br><span class="line">  xhr.send();</span><br><span class="line"></span><br><span class="line">  xhr.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// ① 서버의 응답을 상위 스코프의 변수에 할당한다.✅</span></span><br><span class="line">      todos = <span class="built_in">JSON</span>.parse(xhr.response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`<span class="subst">$&#123;xhr.status&#125;</span> <span class="subst">$&#123;xhr.statusText&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// id가 1인 post를 취득</span></span><br><span class="line"><span class="keyword">get</span>("https://jsonplaceholder.typicode.com/posts/1");</span><br><span class="line">console.log(todos); // ② undefined</span><br></pre></td></tr></table></figure>

<p>위와 같이 get 함수의 상위에 전역 변수가 있고, onload 이벤트 내에서 서버의 응답 결과를 할당한 경우 처리과정은 아래와 같다.</p>
<blockquote>
<p><code>get 함수 호출</code>-&gt; <code>get 함수 평가 및 실행 컨텍스트 생성</code> -&gt; <code>콜 스택에 push</code> -&gt; <code>코드 실행</code> -&gt; <code>xhr.onload에 이벤트 핸들러 바인딩</code> -&gt; <code>get 함수 종료</code> -&gt; <code>get 함수 콜 스텍에서 pop</code> -&gt; <code>②console.log 호출 및 실행</code> -&gt; <code>console.log의 실행 컨텍스트 생성</code> -&gt; <code>콜 스택에 push</code> -&gt; <u><code>서버로부터 응답 도착</code></u> -&gt; <code>load 이벤트 발생</code> -&gt;</p>
</blockquote>
<p><strong>xhr.onload의 이벤트 핸들러는 즉시 실행되지 않는다.</strong> load 이벤트 발생 시 태스크 큐에서 대기하가다 콜 스텍이 비었을 때 콜 스텍으로 push 되어 실행된다. 즉 console.log가 종료된 후에야 실행되므로 예상했던 서버의 응답결과가 console.log에 출력되지 않고, <code>undefined</code>가 호출된다.</p>
<p><code>xhr.onload에 이벤트 핸들러 task Queue에 push</code> -&gt; <code>콜 스텍에 있는 모든 실행 컨텍스트 pop됨</code> -&gt; <code>이벤트 루프</code> -&gt; <code>콜 스텍에 push</code>-&gt; <code>이벤트 핸들러 실행</code></p>
<hr>
<p>위와 같이 비동기 함수는 세 가지 문제가 있다.</p>
<ol>
<li><strong>비동기 처리 결과를 외부에 반환할 수 없다.</strong></li>
<li><strong>상위 스코프의 변수에 할당할 수 없다.</strong></li>
<li><strong>서버로부터 데이터를 받아오기 전에 데이터를 화면에 표시하려고 하면 오류가 발생</strong></li>
</ol>
<p>따라서 서버에 대한 응답을 처리하는 비동기 함수의 처리 결과는 비동기 함수 내부에서 수행해야 하고, 이를 위해 비동기 함수에 <code>콜백 함수</code>를 전달해서 처리한다. 그러나 콜백 패턴도 <code>비동기 함수 처리 결과</code> -&gt; <code>비동기 함수 호출</code>과 같은 패턴이 반복된다면 콜백 함수가 중첩되어 복잡해지는 다음과 같은 문제점을 가지고 있다.</p>
<ol>
<li><strong>콜백 헬</strong></li>
<li><strong>에러 처리의 한계</strong></li>
</ol>
<h3 id="콜백-헬"><a href="#콜백-헬" class="headerlink" title="콜백 헬"></a>콜백 헬</h3><p>비동기 처리를 위해 콜백 함수를 연달아 사용할 경우 콜백 헬이 발생하여 가독성을 떨어뜨리고, 유지 보수를 어렵게 한다. 다음과 같이 서버로부터 응답받은 데이터를 활용하여 연속으로 get 요청을 보낼 경우 콜백 헬이 발생한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>("/step1", (a) =&gt; &#123;</span><br><span class="line">  <span class="keyword">get</span>(`/step2/$&#123;a&#125;<span class="string">`, (b) =&gt; &#123;</span></span><br><span class="line"><span class="string">    get(`</span>/step3/$&#123;b&#125;<span class="string">`, (c) =&gt; &#123;</span></span><br><span class="line"><span class="string">      get(`</span>/step4/$&#123;c&#125;<span class="string">`, (d) =&gt; &#123;</span></span><br><span class="line"><span class="string">        console.log(d);</span></span><br><span class="line"><span class="string">      &#125;);</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>

<h3 id="에러-처리의-한계"><a href="#에러-처리의-한계" class="headerlink" title="에러 처리의 한계"></a>에러 처리의 한계</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Error!"</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 에러를 캐치하지 못한다</span></span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">"캐치한 에러"</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try 구문에서 콜백함수가 에러를 발생 시키는데 이 에러는 catch 블록에서 캐치되지 않는다. 에러는 호출자 방향으로 전파되는데, setTimeout 함수의 콜백함수를 호출한 것은 setTimeout이 아니기 때문에 이 함수의 콜백함수가 발생시킨 에러는 캐치되지 않는다.</p>
<hr>
<p><em>References</em><br><a href="https://poiemaweb.com/fastcampus/promise" target="_blank" rel="noopener">poiemaweb</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/08/19/200820_restApi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/19/200820_restApi/" class="post-title-link" itemprop="url">REST API</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-20T00:00:00+09:00">2020-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-06 01:09:52" itemprop="dateModified" datetime="2021-01-06T01:09:52+09:00">2021-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="REST-Representational-State-Transfer"><a href="#REST-Representational-State-Transfer" class="headerlink" title="REST(Representational State Transfer)"></a>REST(Representational State Transfer)</h2><p>2000년도에 로이 필딩 (Roy Fielding)의 박사학위 논문에서 최초로 소개된 개념</p>
<ul>
<li>REST: <code>HTTP를 기반</code>으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처</li>
<li>REST API: REST를 기반으로 서비스 API를 구현한 것</li>
</ul>
<h2 id="REST-API의-구성"><a href="#REST-API의-구성" class="headerlink" title="REST API의 구성"></a>REST API의 구성</h2><ul>
<li>자원(RESOURCE) - URI</li>
<li>행위(Verb) - HTTP METHOD</li>
<li>표현(Representations) - 페이로드</li>
</ul>
<h2 id="REST-API-설계-원칙"><a href="#REST-API-설계-원칙" class="headerlink" title="REST API 설계 원칙"></a>REST API 설계 원칙</h2><ol>
<li><strong>자원의 위치를 나타내는 URI는 리소스를 표현해야 한다. 리소스를 식별할 수 있는 이름은 <code>명사형</code>으로 사용한다.</strong></li>
<li><strong>리소스에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다. 클라이언트가 서버에게 요청의 종류와 목적(리소스에 대한 행위)를 알리는 방법을 말한다.</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">URI는 리소스를 표현하는 데 중점을 두고 있으므로 명사형으로 명시</span><br><span class="line">&#96;delete&#96;처럼 리소스에 대한 행위를 표현하면 안된다.</span><br><span class="line"></span><br><span class="line">GET &#x2F;weathers&#x2F;delete&#x2F;1 -&gt; X</span><br><span class="line"></span><br><span class="line">리소스에 대한 행위는 가장 앞에 있는 &#96;GET&#96;과 같은 HTTP Method로</span><br><span class="line">어떠한 행위를 할 것인지를 표현한다.</span><br><span class="line">GET &#x2F;weathers&#x2F;1 -&gt; O</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>HTTP Method(GET, POST, PUT, DELETE)<br>리소스에 대한 정의는 다음의 HTTP 요청 메소드를 이용하여 CRUD를 한다. CRUD는 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 <em>Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말</em>이다. 사용자 인터페이스가 갖추어야 할 기능(정보의 참조/검색/갱신)을 가리키는 용어로서도 사용된다.</p>
<table>
<thead>
<tr>
<th align="center">HTTP Method</th>
<th align="center">종류</th>
<th align="center">목적</th>
<th align="center">페이로드</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET</td>
<td align="center">index/retrieve</td>
<td align="center">리소스 조회/취득</td>
<td align="center"><strong>X</strong></td>
</tr>
<tr>
<td align="center">POST</td>
<td align="center">create</td>
<td align="center">리소스 생성</td>
<td align="center"><strong>O</strong></td>
</tr>
<tr>
<td align="center">PUT</td>
<td align="center">replace</td>
<td align="center">리소스 전체교체</td>
<td align="center"><strong>O</strong></td>
</tr>
<tr>
<td align="center">PATCH</td>
<td align="center">update</td>
<td align="center">리소스 일부 수정</td>
<td align="center"><strong>O</strong></td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">delete</td>
<td align="center">리소스 삭제</td>
<td align="center"><strong>X</strong></td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="URI-설계-시-주의사항"><a href="#URI-설계-시-주의사항" class="headerlink" title="URI 설계 시 주의사항"></a>URI 설계 시 주의사항</h2><ol>
<li>슬래시(/)는 계층 관계를 나타낼 때 사용</li>
<li>URI 마지막 문자로 슬래시(/)를 포함하지 않는다.</li>
<li>하이픈(-)은 URI 가독성을 높이는데 사용</li>
<li>밑줄(_)은 URI에 사용하지 않는다.</li>
<li>URI 경로에는 소문자가 적합하다.</li>
<li>파일 확장자는 URI에 포함시키지 않는다.</li>
</ol>
<h3 id="리소스-간의-관계를-표현"><a href="#리소스-간의-관계를-표현" class="headerlink" title="리소스 간의 관계를 표현"></a>리소스 간의 관계를 표현</h3><p>/리소스명/리소스 ID/관계가 있는 다른 리소스명</p>
<p>ex) GET : /users/{userid}/devices<br>(일반적으로 소유 ‘has’의 관계를 표현할 때)</p>
<p>서브 리소스에 명시적으로 표현<br>ex) GET : /users/{userid}/likes/devices<br>(관계명이 애매하거나 구체적 표현이 필요할 때)</p>
<h3 id="자원을-표현"><a href="#자원을-표현" class="headerlink" title="자원을 표현"></a>자원을 표현</h3><p>컬렉션과 도큐먼트로 URI에 표현</p>
<ul>
<li>Collection: 문서 또는 객체들의 집합. <u>컬렉션은 복수형으로 사용</u></li>
<li>Document: 문서</li>
</ul>
<p>ex) http_://restapi.example.com/sports(<strong>collection</strong>)/soccer(<strong>Document</strong>)/players(<strong>collection</strong>)/13(<strong>Document</strong>)</p>
<h2 id="HTTP-응답-상태-코드"><a href="#HTTP-응답-상태-코드" class="headerlink" title="HTTP 응답 상태 코드"></a>HTTP 응답 상태 코드</h2><ol>
<li>정상적인 수행<br>200: 클라이언트의 요청을 정상적으로 수행함.</li>
<li>클라이언트 에러 응답<br>404: 요청받은 리소스를 찾을 수 없음.</li>
<li>서버 에러 응답<br>500: 서버가 처리 방법을 모르는 상황. 서버에 문제가 있다.</li>
<li>리다이렉션<br>301: 요청한 리소스의 URI가 변경되었음</li>
</ol>
<hr>
<p><em>References</em><br><a href="https://meetup.toast.com/posts/92" target="_blank" rel="noopener">TOAST</a><br><a href="https://ko.wikipedia.org/wiki/CRUD" target="_blank" rel="noopener">CRUD</a><br><a href="https://developer.mozilla.org/ko/docs/Glossary/URI" target="_blank" rel="noopener">MDN</a><br><a href="https://poiemaweb.com/fastcampus/rest-api" target="_blank" rel="noopener">poiemaweb</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/08/18/200819_ajax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/18/200819_ajax/" class="post-title-link" itemprop="url">Ajax</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-19 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-19T00:00:00+09:00">2020-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-06 01:09:52" itemprop="dateModified" datetime="2021-01-06T01:09:52+09:00">2021-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Ajax-Asynchronous-Javascript-And-XML"><a href="#Ajax-Asynchronous-Javascript-And-XML" class="headerlink" title="Ajax(Asynchronous Javascript And XML)"></a>Ajax(Asynchronous Javascript And XML)</h2><blockquote>
<p>자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식. 서버와 통신하기 위해 XMLHttpRequest 객체를 사용하는 것.</p>
</blockquote>
<p>이전 웹페이지는 완전한 HTML을 서버로부터 전송받아 웹페이지 전체를 처음부터 렌더링하는 방식으로 동작했다. 따라서 화면이 전환되면 또 웹페이지 전체를 처음부터 다시 렌더링하게 된다. <strong>이렇게 되면 굳이 변경할 필요가 없는 부분도 서버로부터 전달받는 불필요한 데이터 통신이 발생하고, 화면의 순간적으로 깜빡거리는 현상이 발생한다. 또한 서버로부터 응답을 받기 전까지 블로킹되는 문제가 발생한다.</strong> Ajax가 등장하면서 굳이 데이터를 변경하지 않아도 되는 부분은 그대로 두고, 서버에서 필요한 데이터만 전송받아 변경이 필요한 부분만 렌더링할 수 있고, 화면의 전환도 부드러워졌다.</p>
<h2 id="JSON-JavaScript-Object-Notation"><a href="#JSON-JavaScript-Object-Notation" class="headerlink" title="JSON(JavaScript Object Notation)"></a>JSON(JavaScript Object Notation)</h2><p>javascript 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기반 표준 포맷으로 <code>웹 어플리케이션에서 데이터를 전송할 때</code> 일반적으로 사용한다.</p>
<blockquote>
<p>클라이언트와 서버 간의 HTTP 통신을 위한 텍스트 데이터 포맷<br>객체 리터럴처럼 키와 값으로 구성된 순수한 텍스트</p>
</blockquote>
<ul>
<li>키는 반드시 <code>큰따옴표</code>로 묶어야 한다.</li>
<li>값도 문자열인 경우 반드시 <code>큰따옴표</code>로 묶어야 한다.</li>
<li>순수한 데이터 포맷이므로 프로퍼티만 담을 수 있고, 메서드는 담을 수 없다.</li>
</ul>
<h2 id="JSON-parse-stringify"><a href="#JSON-parse-stringify" class="headerlink" title="JSON parse() / stringify()"></a>JSON parse() / stringify()</h2><blockquote>
<p>request.responseType = ‘json’;</p>
</blockquote>
<p>위와 같이 응답 타입이 json이면 편리하지만 json 문자열을 그대로 받아서 객체로 변환시키거나, 네트워크에 전송할 때 객체를 JSON 타입으로 변환시켜야 하는 경우가 흔하다. 이는 아래와 같은 방법으로 변환한다.</p>
<h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h2><blockquote>
<p><code>서버</code> -&gt; JSON 데이터(<strong>문자열</strong>) -&gt; <code>클라이언트</code> -&gt; <em>JSON.parse(역직렬화)</em> -&gt; 객체(화)</p>
</blockquote>
<p>JSON 문자열을 매개변수로서 수용하고, 일치하는 자바스크립트 객체로서 변환.</p>
<h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h2><blockquote>
<p><code>클라이언트</code> -&gt; 객체 -&gt; <em>JSON.stringify(직렬화)</em> -&gt; 문자열 -&gt; <code>서버</code></p>
</blockquote>
<p>stringify(): 객체를 매개변수로서 수용하고, JSON 문자열 형태로 변환.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">"lee"</span>, <span class="attr">job</span>: <span class="string">"web developer"</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체를 문자로 변환</span></span><br><span class="line"><span class="keyword">const</span> objToJson = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objToJson, objToJson);</span><br><span class="line"><span class="comment">// string &#123;"name":"lee","job":"web developer"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = objToJson;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objToJson, objToJson);</span><br><span class="line"><span class="comment">// string &#123;"name":"lee","job":"web developer"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//문자를 객체로 변환</span></span><br><span class="line"><span class="keyword">const</span> jsonToObj = <span class="built_in">JSON</span>.parse(objToJson);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> jsonToObj, jsonToObj);</span><br><span class="line"><span class="comment">// object &#123;name: "lee", job: "web developer"&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><blockquote>
<p><code>XMLHttpRequest</code> -&gt; XMLHttpRequestEventTarget -&gt; EventTarget</p>
</blockquote>
<p>브라우저는 주소창이나 HTML의 form 태그 또는 a 태그를 통해 HTTP 요청 전송 기능을 기본 제공한다. 자바스크립트를 사용하여 HTTP 요청을 전송하려면 XMLHttpRequest 객체를 사용한다. XHR 객체는 서버와 상호작용하기 위해 사용되므로, 전체 페이지의 새로고침 없이도 URL로부터 데이터를 받아 올 수 있다.</p>
<ol>
<li>XMLHttpRequest 객체 생성</li>
</ol>
<blockquote>
<p>const xhr = new XMLHttpRequest();</p>
</blockquote>
<p>생성자는 XMLHttpRequest 를 초기화하며, 다른 모든 메소드 호출 이전에 호출되어야 한다.</p>
<ol start="2">
<li>HTTP 요청 전송</li>
</ol>
<blockquote>
<p>XMLHttpRequest.prototype.open</p>
</blockquote>
<ul>
<li>xhr.open(요청메서드, 요청을 전송할 url, 비동기요청여부 - 기본값 true)</li>
<li>XMLHttpRequest.prototype.open 메서드로 HTTP 요청을 초기화한다.</li>
<li>필요에 따라 XMLHttpRequest.prototype.setRequestHeader 메서드로 특정 HTTP 요청의 헤더 값을 설정한다.</li>
</ul>
<blockquote>
<p>XMLHttpRequest.prototype.send</p>
</blockquote>
<p>XMLHttpRequest.prototype.send 메서드로 HTTP 요청을 전송한다.</p>
<ul>
<li>GET: 데이터를 URL의 일부분인 쿼리 문자열(query string)로 서버에 전송</li>
<li>POST: 데이터(페이로드)를 요청 몸체(request body)에 담아 전송</li>
<li>GET, DELETE는 <code>페이로드 X</code></li>
<li>POST, PUT, PATCH는 <code>페이로드 O</code></li>
<li>페이로드가 개체일 경우 반드시 <code>JSON.stringify</code>를 사용한 후 전달한다.</li>
</ul>
<blockquote>
<p>XMLHttpRequest.prototype.setRequestHeader</p>
</blockquote>
<p>특정 HTTP 요청의 헤더 값을 설정한다. setRequestHeader 메서드는 반드시 open 메서드를 호출한 이후에 호출</p>
<ol start="3">
<li>HTTP 응답 처리<br>XMLHttpRequest 객체가 발생시키는 이벤트를 캐치하여 처리하는데, send 메서드를 통해 서버에 전달된 HTTP 요청이 서버로부터 클라이언트에 언제 도달할 지 알 수 없으므로 이벤트를 캐치하여 현재 상태를 확인해야 한다.<ul>
<li><code>readystatechange 이벤트</code>: HTTP 요청의 현재 상태를 나타내는 readyState 프로퍼티 값이 변경된 경우 발생</li>
<li><code>onload 이벤트</code>: HTTP 요청이 성공적으로 완료된 경우 발생한다. 따라서 load 이벤트를 캐치하는 경우 xhr.readyState가 XMLHttpRequest.DONE인지 확인할 필요가 없다.</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;...&#125;</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// readyState 프로퍼티는 HTTP 요청의 현재 상태를 나타낸다.</span></span><br><span class="line">  <span class="comment">// readyState 프로퍼티 값이 4(XMLHttpRequest.DONE)가 아니면 서버 응답이 완료되지 상태다.</span></span><br><span class="line">  <span class="comment">// 만약 서버 응답이 아직 완료되지 않았다면 아무런 처리를 하지 않는다.</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState !== XMLHttpRequest.DONE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// status 프로퍼티는 응답 상태 코드를 나타낸다.</span></span><br><span class="line">  <span class="comment">// status 프로퍼티 값이 200이면 정상적으로 응답된 상태이고</span></span><br><span class="line">  <span class="comment">// status 프로퍼티 값이 200이 아니면 에러가 발생한 상태다.</span></span><br><span class="line">  <span class="comment">// 정상적으로 응답된 상태라면 response 프로퍼티에 서버의 응답 결과가 담겨 있다.</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(xhr.response));</span><br><span class="line">    <span class="comment">// &#123;userId: 1, id: 1, title: "delectus aut autem", completed: false&#125;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"Error"</span>, xhr.status, xhr.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// load 이벤트는 HTTP 요청이 성공적으로 완료된 경우 발생한다.</span></span><br><span class="line">xhr.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// status 프로퍼티는 응답 상태 코드를 나타낸다.</span></span><br><span class="line">  <span class="comment">// status 프로퍼티 값이 200이면 정상적으로 응답된 상태이고</span></span><br><span class="line">  <span class="comment">// status 프로퍼티 값이 200이 아니면 에러가 발생한 상태다.</span></span><br><span class="line">  <span class="comment">// 정상적으로 응답된 상태라면 response 프로퍼티에 서버의 응답 결과가 담겨 있다.</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(xhr.response));</span><br><span class="line">    <span class="comment">// &#123;userId: 1, id: 1, title: "delectus aut autem", completed: false&#125;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'Error'</span>, xhr.status, xhr.statusText);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><em>References</em><br><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/JSON" target="_blank" rel="noopener">MDN</a><br><a href="https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">MDN</a><br><a href="https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest" target="_blank" rel="noopener">MDN</a><br><a href="https://poiemaweb.com/fastcampus/ajax#3-xmlhttprequest" target="_blank" rel="noopener">poiemaweb</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/08/17/200818_timer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/17/200818_timer/" class="post-title-link" itemprop="url">timer</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-18 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-18T00:00:00+09:00">2020-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-06 01:09:52" itemprop="dateModified" datetime="2021-01-06T01:09:52+09:00">2021-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="호출-스케줄링"><a href="#호출-스케줄링" class="headerlink" title="호출 스케줄링"></a>호출 스케줄링</h2><p>함수를 명시적으로 호출하지 않고, 일정 시간이 경과된 이후 호출되도록 타이머 함수를 사용하여 함수 호출을 예약한다.</p>
<ul>
<li>타이머를 생성할 수 있는 함수: setsetTimeout,setInterval<ul>
<li>일정 시간이 경과된 이후 콜백 함수가 호출되도록 타이머 생성. 생성된 타이머가 만료되면 콜백함수가 호출됨.</li>
<li>setTimeout: 이 함수가 생성한 타이머는 <code>단 한번</code>동작. 타이머 만료시 <code>단 한번</code>호출.</li>
<li>setInterval: 이 함수가 생성한 타이머는 반복 동작. 타미어 만료될 때마다 <code>반복</code>호출.</li>
</ul>
</li>
<li>타이머를 제거할 수 있는 함수: clearTimeout, clearInterval</li>
</ul>
<h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h2><p>지정된 시간이 경과 한 후 특정 코드 블록을 <code>한 번</code> 실행.</p>
<ul>
<li><p>필요한 파라미터</p>
<ul>
<li>실행할 함수 또는 다른 곳에 정의 된 함수 참조.</li>
<li>코드를 실행하기 전에 대기 할 밀리세컨드 단위의 시간 간격 (1000밀리세컨드는 1 초)을 나타내는 숫자. 값을 0으로 지정하면(혹은 이 값을 모두 생략하면) 함수가 즉시 실행된다.</li>
<li>함수가 실행될 때 함수에 전달해야할 파라미터를 나타내는 0이상의 값.</li>
</ul>
</li>
<li><p>매개변수<br>setTimeout () 내에서 실행되는 함수에 전달하려는 모든 매개변수는 setTimeout () 매개변수 목록 끝에 추가하여 전달해야 한다.</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 익명함수 실행</span></span><br><span class="line"><span class="keyword">let</span> myGreeting = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello, Mr. Universe!"</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout()에 함수 참조를 전달.</span></span><br><span class="line"><span class="comment">// timeout 함수와 이벤트에 의해 중복 호출되는 함수를 사용하려면 이 방법이 유용할 수 있다.</span></span><br><span class="line"><span class="comment">// 이 방법은 코드라인을 깔끔하게  정리하는 데 도움을 준다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// With a named function</span></span><br><span class="line"><span class="keyword">let</span> myGreeting = setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello, Mr. Universe!"</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// With a function defined separately</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello Mr. Universe!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGreeting = setTimeout(sayHi, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="clearTimeout"><a href="#clearTimeout" class="headerlink" title="clearTimeout()"></a>clearTimeout()</h2><p>타임아웃이 생성되면(setTimeout()이 실행되면) 특정시간이 경과하기 전에 clearTimeout()을 호출하여 타임아웃을 취소할 수 있다. clearTimeout()은 setTimeout()콜의 식별자를 매개변수로 setTimeout()에 전달한다.</p>
<hr>
<h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h2><p>지정된 시간이 경과 후, 두 번째 매개 변수에 주어진 시간까지 <code>반복적</code>으로 실행됨.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">let</span> time = date.toLocaleTimeString();</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).textContent = time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createClock = setInterval(displayTime, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="clearInterval"><a href="#clearInterval" class="headerlink" title="clearInterval()"></a>clearInterval()</h2><p>위와 같이 별다른 중지 사항을 명시하지 않으면 계속 반복해서 실행됨. 아래와 같이 setInterval()에 의해 반환된 식별자를 clearInterval()에 전달하여 작업을 취소할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">let</span> time = date.toLocaleTimeString();</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">".clock"</span>).textContent = time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">displayTime();</span><br><span class="line"><span class="keyword">const</span> createClock = setInterval(displayTime, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// clearInterval 사용 시 setInterval 작업 취소</span></span><br><span class="line">clearInterval(createClock);</span><br></pre></td></tr></table></figure>

<hr>
<p><em>Preferences</em><br><a href="https://poiemaweb.com/fastcampus/timer#22-setinterval--clearinterval" target="_blank" rel="noopener">poiemaweb</a><br><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Timeouts_and_intervals" target="_blank" rel="noopener">MDN</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/08/04/0804_rubberduck/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/04/0804_rubberduck/" class="post-title-link" itemprop="url">200804 러버덕 정리</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-04 15:00:00" itemprop="dateCreated datePublished" datetime="2020-08-04T15:00:00+09:00">2020-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-06 01:09:52" itemprop="dateModified" datetime="2021-01-06T01:09:52+09:00">2021-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="프로그래밍"><a href="#프로그래밍" class="headerlink" title="프로그래밍"></a>프로그래밍</h2><p>컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션</p>
<p>프로그래밍 언어: 컴퓨터가 이해할 수 있는 언어(기계어)</p>
<blockquote>
<p>사람 -&gt; 프로그래밍 언어 -&gt; 기계어 -&gt; 컴퓨터<br>리터럴 -&gt; 자바스크립트 -&gt; 인터프리터(정적언어는 컴파일러)-&gt; 2진수 변환 -&gt; 메모리에 저장</p>
</blockquote>
<h2 id="자바스크립트"><a href="#자바스크립트" class="headerlink" title="자바스크립트"></a>자바스크립트</h2><p>시작: 넷스케이프 커뮤니케이션즈가 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어를 개발 -&gt; 브랜던 아이크의 자바스크립트: 모카로 명명</p>
<p><strong>표준화</strong><br>MS에서도 자바스크립트의 파생버전 JScript를 개발하면서 넷스케이프와 경쟁구도. 자사 브라우저에서만 작동하는 기능을 추가하기 시작하면서 호환되지 않는 문제가 생겨남(크로스 브라우징 이슈). 따라서 표준화에 대한 필요성 대두.</p>
<p><strong>ECMAScript</strong><br>1997: 표준화된 자바스크립트 초판(ECMAScript 1) 사양(specification)이 완성되었고, 상표권 문제로 자바스크립트는 ECMAScript로 명명<br>1999: ECMAScript 3(ES3)<br>2009: ECMAScript 5(ES5)는 HTML5와 함께 출현한 표준 사양<br>2015: ECMAScript 6(ECMAScript 2015, ES6)는 let/const 키워드, 화살표 함수, 클래스, 모듈 등과 같이 범용 프로그래밍 언어로서 갖춰야 할 기능들을 대거 도입</p>
<hr>
<p><strong>자바스크립트의 발전 과정</strong></p>
<blockquote>
<p>렌더링 -&gt; AJAX(XMLHttpRequest) -&gt; jQuery -&gt; V8 -&gt; Node.js -&gt; 프레임 워크</p>
</blockquote>
<p>초창기는 웹페지이의 보조기능을 수행하면서 브라우저에 단순 렌더링하는 역할, AJAX의 등장으로 비동기 처리가 가능해지면서 성능이 빨라지고 화면전환이 부드러워짐.</p>
<p><strong>HOW?</strong></p>
<ul>
<li><p>기존방식: <code>&lt;html&gt;&lt;/html&gt;</code>의 완전한 html을 서버에서 전송받아 웹페이지 전체를 렌더링, 화면 전환 시 이 과정이 처음부터 다시 이루어지면서 화면이 깜빡이는 현상이 발생.<br>불필요한 데이터 통신, 성능도 좋지 않음.</p>
</li>
<li><p>AJAX: 변경필요 없는 부분은 그대로 두고, 서버에서 필요한 데이터만 전송받아 변경이 필요한 부분만 렌더링.</p>
</li>
</ul>
<p><strong>JQuery</strong><br>DOM을 쉽게 제어할 수 있고, 크로스 브라우징 이슈도 해결. 배우기 쉽고 직관적.</p>
<p><strong>V8 자바스크립트 엔진</strong><br>구글에서 개발. 자바스크립트가 웹 어플리케이션 개발 프로그래밍 언어로 정착하게 함. 웹 서버에서 수행되던 로직이 클라이언트 사이드로 이동.</p>
<p><strong>Node.js</strong><br>라이언 달. V8로 빌드된 자바스크립트 런타임 환경. 브라우저의 자바스크립트 엔진에서만 동작하던 js를 다른 환경에서도 동작할 수 있도록 함.</p>
<p><strong>프레임워크</strong><br>Angular, React, Vue.js, Svelte 등</p>
<p>ECMAScript: 자바스크립트의 표준 사양인 ECMA-262를 말하며, 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체(standard built-in object) 등 핵심 문법을 규정</p>
<p>javascript: 웹 브라우저에서 동작하는 유일한 프로그래밍 언어. 인터프리터 언어.</p>
<hr>
<ul>
<li>ECMAScript: core역할, 표준화, spec관리 등등.</li>
<li>Node.js: host APIs(server-side javascript). 브라우저 외부에서 js 개발 환경을 제공하는 것이 주된 목적. DOM api 제공 안함. 파일을 create/read/update/delete할 수 있는 파일 시스템을 기본 제공.</li>
<li>javascript: client-side. 화면 렌더링이 주된 목적. DOM api 제공. 파일을 create/read/update/delete할 수 있는 파일 시스템을 기본 제공안함.</li>
</ul>
<hr>
<h2 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h2><ul>
<li>변수 선언: 값을 저장하기 위한 메모리 공간을 할당, 주소값을 연결하여 값을 저장할 수 있도록 한다.</li>
<li>초기화: 선언 후 값을 할당하지 않았을 때 undefined가 암묵적으로 할당된다.</li>
</ul>
<p><strong>변수 호이스팅</strong><br>변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작. 런타임 이전에 변수 선언문을 찾아 실행한 후 런타임 때 할당이 이루어짐.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> result;</span><br></pre></td></tr></table></figure>

<p>할당 할 때, undefined로 초기화 된 값을 지운 후 그 자리에 값을 할당하는 것이 아니라, 새로운 메모리 공간을 확보한 후 그 곳에 값을 저장한다. 재할당의 경우도 마찬가지이다. 재할당이 이루어지면 기존의 변수는 가비지 컬렉터에 의해 언젠가 메모리 해제된다.</p>
<p><strong>식별자 네이밍 규칙</strong></p>
<ul>
<li>변수나 함수의 이름: 카멜 케이스를 사용. (ex. var firstName;)</li>
<li>생성자 함수, 클래스의 이름: 파스칼 케이스를 사용 (ex. var FirstName;)</li>
</ul>
<hr>
<h2 id="표현식과-문"><a href="#표현식과-문" class="headerlink" title="표현식과 문"></a>표현식과 문</h2><p><strong>표현식</strong><br>값으로 평가될 수 있는 문. 표현식이 평가되면 값을 생성하거나 참조한다.<br>become a value. 값이 생성되거나 문의 일부가 될 수 있다.</p>
<p><strong>문</strong><br>perform action. 값이 생성되지 않고, 실행문이나 코드블록의 action을 컨트롤할 뿐이다.<br>프로그램을 구성하는 기본 단위, 최소 실행 단위. 여러 토큰들로 구성된다. 특정 액션을 수행하는 역할을 한다.<strong>문은 반드시 세미콜론으로 끝나야 하는데, 중괄호로 묶은 코드 블록 뒤에는 세미콜론을 붙이지 않는다. ex. if문, for문, 함수 등)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">문: 실행되거나 특정한 action을 수행할 수 있는 코드의 조각을 말한다.</span><br><span class="line">표현식: 평가되어 값을 생성할 수 있는 코드의 조각을 말한다.</span><br><span class="line">표현식인 문: 값으로 평가될 수 있는 문. ex.변수 할당문</span><br><span class="line">표현식이 아닌 문: 값으로 평가될 수 없는 문 ex.변수 선언문</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="데이터-타입"><a href="#데이터-타입" class="headerlink" title="데이터 타입"></a>데이터 타입</h2><p>원시타입 / 객체 타입</p>
<p>데이터 타입은 메모리 공간을 확보하고 참조하기 위해 필요하다. 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정되기 때문이다.</p>
<ul>
<li><p>정적 타입: 명시적으로 어떤 타입인지 사전에 선언해야 하고, 컴파일 시점에 타입체크를 수행한다.</p>
</li>
<li><p>동적 타입: 값을 할당하는 런타임에 변수의 타입이 결정되고, 언제든지 변경할 수 있다.</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/07/27/200728_arrayMethods/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/27/200728_arrayMethods/" class="post-title-link" itemprop="url">algorithm에 필요한 method 정리</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-28 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-28T00:00:00+09:00">2020-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-06 01:09:52" itemprop="dateModified" datetime="2021-01-06T01:09:52+09:00">2021-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="reverseString-Pseudocode"><a href="#reverseString-Pseudocode" class="headerlink" title="reverseString Pseudocode"></a>reverseString Pseudocode</h2><ol>
<li>string를 배열로 만든다.</li>
<li>배열 method를 사용하면 array 내부의 요소의 순서를 뒤집는다.</li>
<li>순서가 뒤집힌 배열을 다시 string로 변환한다.</li>
</ol>
<blockquote>
<p>example<br>“hello” -&gt; [‘h’, ‘e’, ‘l’, ‘l’, ‘o’] -&gt; [‘o’, ‘l’, ‘l’, ‘e’, ‘h’] -&gt; ‘olleh’</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(str); <span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> splits = str.split(<span class="string">""</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(splits); <span class="comment">// ["h", "e", "l", "l", "o"]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reversed = splits.reverse();</span><br><span class="line">  <span class="built_in">console</span>.log(reversed); <span class="comment">// ["o", "l", "l", "e", "h"]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = reversed.join(<span class="string">""</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">//olleh</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h2><blockquote>
<p>str.split([separator[, limit]])</p>
</blockquote>
<p>string을 구분자를 이용하여 여러 개의 문자열로 나눈다.</p>
<ul>
<li><p>매개변수: separator, limit 두 가지를 전달할 수 있다.</p>
<ul>
<li>separator: 끊어야 할 부분을 나타내는 문자열로 실제 문자열이나 정규표현식을 받을 수 있다.</li>
<li>limit: 끊어진 문자열의 최대 개수를 나타낸다. limit이 존재하면, 배열의 원소가 limit개가 되었을 때 split메소드가 중지된다.</li>
</ul>
</li>
<li><p>반환값: 원본 문자열을 separator마다 끊은 <code>문자열의 결과를 담은 배열을 반환</code>한다.</p>
<ul>
<li>separator가 빈문자열(‘’)일 때: 원본 문자열을 한 글자씩 분리한 배열이 반환됨.</li>
<li>separator가 공백이 있는 문자열(‘ ‘)일 때: 원본 문자열을 공백으로 구분한 배열이 반환됨.</li>
<li>separator로 아무것도 주어지지 않았을 때: 원본 문자열 전체를 담은 배열이 반환됨.</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hi = <span class="string">"hello there"</span>;</span><br><span class="line">hi.split(); <span class="comment">// ['hello there']</span></span><br><span class="line">hi.split(<span class="string">""</span>); <span class="comment">// ['h', 'e', 'l', 'o', 'o', 't', 'h', 'e', 'r', 'e']</span></span><br><span class="line"><span class="keyword">const</span> result = hi.split(<span class="string">" "</span>); <span class="comment">// ['hello', 'there']</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>]); <span class="comment">// there</span></span><br><span class="line">hi.split(<span class="string">" "</span>, <span class="number">3</span>); <span class="comment">// ['h', 'e', 'l']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 정규 표현식 사용</span></span><br><span class="line"><span class="keyword">var</span> myString = <span class="string">"Hello 1 word. Sentence number 2."</span>;</span><br><span class="line"><span class="keyword">var</span> splits = myString.split(<span class="regexp">/(\d)/</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(splits); <span class="comment">// [ "Hello ", "1", " word. Sentence number ", "2", "." ]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h2><blockquote>
<p>a.reverse()</p>
</blockquote>
<p>배열의 순서를 반전하고, <code>반환값은 순서가 반전된 배열</code>이다.</p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>배열의 모든 요소를 하나의 문자열로 만든다.</p>
<blockquote>
<p>arr.join([separator])</p>
</blockquote>
<ul>
<li>매개변수: separator. 배열의 각 요소를 구분할 문자열을 지정한다.<ul>
<li>separator가 빈문자열(‘’)일 때: 공백이 구분되지 않은 문자열이 반환됨.</li>
<li>separator가 공백이 있는 문자열(‘ ‘)일 때: 단어 간 공백이 있는 문자열이 반환됨.</li>
<li>separator로 아무것도 주어지지 않았을 때: 쉼표(,)로 구분된 문자열이 반환됨.</li>
<li>separator로 특정 문자가 주어졌을 때: 특정 문자가 삽입된 문자열이 반환됨.</li>
</ul>
</li>
<li>반환값: 배열의 모든 요소를 연결한 하나의 문자열 반환. arr.length가 0이면 빈 문자열 반환되고, 요소가 undefined나 null이면 빈 문자열로 변환됨.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> elements = [<span class="string">"Fire"</span>, <span class="string">"Air"</span>, <span class="string">"Water"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(elements.join());</span><br><span class="line"><span class="comment">// expected output: "Fire,Air,Water"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(elements.join(<span class="string">""</span>));</span><br><span class="line"><span class="comment">// expected output: "FireAirWater"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(elements.join(<span class="string">" "</span>));</span><br><span class="line"><span class="comment">// expected output: "Fire Air Water"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(elements.join(<span class="string">"-"</span>));</span><br><span class="line"><span class="comment">// expected output: "Fire-Air-Water"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> emptyArray = [];</span><br><span class="line">emptyArray.join(); <span class="comment">//''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nullInArray = [<span class="literal">null</span>];</span><br><span class="line">nullInArray.join(); <span class="comment">//''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> undefinedInArray = [<span class="literal">undefined</span>];</span><br><span class="line">undefinedInArray.join(); <span class="comment">//''</span></span><br></pre></td></tr></table></figure>

<h2 id="method-chaining"><a href="#method-chaining" class="headerlink" title="method chaining"></a>method chaining</h2><p>return str.split(“”).reverse().join(“”);</p>
<p>이렇게 method를 연결하여 한줄로 구현할 수도 있지만, 문자열에 grapheme clusters가 있을 경우, 유니코드 플래그를 설정해도 오류를 일으킬 수 있어서 esrever 등의 라이브러리를 쓰는 것이 권장된다.</p>
<hr>
<h2 id="만약-reverse-를-쓰지-않고-reverseString를-구현해야-한다면"><a href="#만약-reverse-를-쓰지-않고-reverseString를-구현해야-한다면" class="headerlink" title="만약 reverse()를 쓰지 않고 reverseString를 구현해야 한다면?"></a>만약 reverse()를 쓰지 않고 reverseString를 구현해야 한다면?</h2><ol>
<li>for문을 이용</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> char = str[i];</span><br><span class="line">    res = char + res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">reverse(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>

<p>argument로 전달된 ‘hello’의 length는 5이고, 총 5번 반복문을 돈다. 원리는 다음과 같다. ‘hello’가 있다면, h를 캐치하여 res의 첫번째 요소로 보내고, 그 다음 e를 캐치하여 res의 첫 번째 요소로 보낸다. 이를 구현하기 위해 <code>res = char + res;</code>로 코드를 구현한다. 이 코드에 따라 hello가 ‘olleh’가 될 때까지 반복문을 돈다.</p>
<blockquote>
<p>‘hello’ + ‘’<br>‘ello’ + ‘h’<br>‘llo’ + ‘eh’<br>‘lo’ + ‘leh’<br>‘o’ + ‘lleh’<br>‘’ + ‘olleh’</p>
</blockquote>
<ul>
<li>1회차<br>char = h;<br>res = h + ‘’ -&gt; h가 된다.</li>
<li>2회차<br>char = e;<br>res = e + h -&gt; eh가 된다.</li>
<li>3회차<br>char = l;<br>res = l + eh -&gt; leh가 된다.</li>
<li>4회차<br>char = l;<br>res = l + leh -&gt; lleh가 된다.</li>
<li>5회차<br>char = o;<br>res = lleh + 0 -&gt; olleh가 된다.</li>
</ul>
<ol start="2">
<li>reduce method 이용하기</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">""</span>).reduce(<span class="function">(<span class="params">output, char</span>) =&gt;</span> &#123;</span><br><span class="line">    output = char + output;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h2><blockquote>
<p>arr.reduce(callback[, initialvalue])<br>[0,1,2,3,4].reduce(function(accumulator, currentValue, currentIndex, array) {<br>return accumulator + currentValue;<br>});</p>
</blockquote>
<p>배열의 각 요소에 대해 주어진 reduce 함수를 실행하고, 결과값을 반환한다. reduce함수는 아래와 같이 네 개의 인자를 가지는데, 함수의 반환 값은 누산기에 할당되고, 누산기는 순회 중 유지되고, 최종 결과는 하나의 값이 된다. 이때 원본 배열은 변경되지 않는다. accumulator, currentValue를 제외한 나머지 매개변수는 option이다.</p>
<blockquote>
<ol>
<li>누산기 accumulator (acc)<br>콜백의 반환값을 누적한다.</li>
<li>현재 값 currentValue (cur)<br>처리가 필요한 현재 요소</li>
<li>현재 인덱스 currentIndex (idx)<br>처리할 현재 요소의 인덱스. initialValue가 있으면 0 혹은 1로 시작.</li>
<li>원본 배열 array (src)<br>reduce()를 호출한 배열.</li>
</ol>
</blockquote>
<ul>
<li>initialValue</li>
</ul>
<p>callback의 최초 호출에서 첫 번째 인수에 제공하는 값. <em>빈 배열에서 초기값 없이 reduce()를 호출하면 오류가 발생한다.</em></p>
<ul>
<li><p>initialValue가 <em>있는</em> 경우: <code>인덱스 0</code>에서 시작. accumulator = initialValue(콜백의 최초 호출 시)</p>
</li>
<li><p>initialValue가 <em>없는</em> 경우: <code>인덱스 1</code>에서 시작, 첫 번째 인덱스는 건너뛴다.</p>
<ul>
<li>accumulator !== initialValue</li>
<li>accumulator = array[1]</li>
<li>accumulator = currentValue의 두 번째 값</li>
</ul>
</li>
<li><p>반환 값: 누적 계산의 결과 값이다.</p>
<ul>
<li>initialValue가 <em>없는</em> 경우 반환값<ul>
<li>빈 배열에서 reduce()를 사용하면 TypeError 발생</li>
<li>배열의 요소가 1개: 위치와 상관없이 단독 값을 callback 호출 없이 반환</li>
</ul>
</li>
<li>initialValue가 <em>있는</em> 경우 반환값<ul>
<li>initialValue가 있는데 빈 배열이 주어졌을 때 단독 값을 callback 호출 없이 반환</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxCallback = <span class="function">(<span class="params">acc, cur</span>) =&gt;</span> <span class="built_in">Math</span>.max(acc.x, cur.x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialValue 없이 reduce()</span></span><br><span class="line">[].reduce(maxCallback); <span class="comment">// TypeError</span></span><br><span class="line">[&#123; <span class="attr">x</span>: <span class="number">22</span> &#125;].reduce(maxCallback); <span class="comment">// &#123; x: 22 &#125;</span></span><br><span class="line">[&#123; <span class="attr">x</span>: <span class="number">22</span> &#125;, &#123; <span class="attr">x</span>: <span class="number">42</span> &#125;].reduce(maxCallback); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h3 id="reduce-작동-방식"><a href="#reduce-작동-방식" class="headerlink" title="reduce() 작동 방식"></a>reduce() 작동 방식</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentValue,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">  array</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 화살표 함수를 사용</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev + curr);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">""</span>).reduce(<span class="function">(<span class="params">output, char</span>) =&gt;</span> &#123;</span><br><span class="line">    output = char + output;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>

<p>위의 함수는 아래의 구조와 같고, 아래와 같이 작동한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> array = str.split(<span class="string">""</span>); <span class="comment">// ["h", "e", "l", "l", "o"]</span></span><br><span class="line">  <span class="keyword">return</span> array.reduce(<span class="function">(<span class="params">output, char</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// return ["h", "e", "l", "l", "o"].reduce((output, char) =&gt; &#123;</span></span><br><span class="line">    output = char + output;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>구체적인 작동방식을 살펴보면 아래와 같다.</p>
<ol>
<li>initialValue:””가 주어져 있으므로, index 0에서 시작한다.</li>
<li>주어진 array는 [“h”, “e”, “l”, “l”, “o”]이다.</li>
<li>callback은 주어진 array의 length만큼 호출된다. 예제인 [“h”, “e”, “l”, “l”, “o”]의 경우 length는 5이다.</li>
<li>반환값은 accumulator에 할당 되고 순회하면서 <code>accumulator + currentValue</code>의 연산이 이루어진 최종값이 반환된다. 예제의 경우 최종적으로 반환되는 값은 <code>olleh</code>이다.</li>
</ol>
<table>
<thead>
<tr>
<th>callback</th>
<th align="center">accumulator</th>
<th align="center">currentValue</th>
<th align="center">currentIndex</th>
<th align="center">return</th>
</tr>
</thead>
<tbody><tr>
<td>1번 째</td>
<td align="center">“”</td>
<td align="center">h</td>
<td align="center">0</td>
<td align="center">h</td>
</tr>
<tr>
<td>2번 째</td>
<td align="center">h</td>
<td align="center">e</td>
<td align="center">1</td>
<td align="center">eh</td>
</tr>
<tr>
<td>3번 째</td>
<td align="center">eh</td>
<td align="center">l</td>
<td align="center">2</td>
<td align="center">leh</td>
</tr>
<tr>
<td>4번 째</td>
<td align="center">leh</td>
<td align="center">l</td>
<td align="center">3</td>
<td align="center">lleh</td>
</tr>
<tr>
<td>5번 째</td>
<td align="center">lleh</td>
<td align="center">o</td>
<td align="center">4</td>
<td align="center">olleh</td>
</tr>
</tbody></table>
<hr>
<p><em>Preferences</em><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="noopener">Array.protorype.split()/MDN</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank" rel="noopener">Array.prototype.reverse()/MDN</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/join" target="_blank" rel="noopener">Array.prototype.join()/MDN</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">Array.prototype.reduce()/MDN</a><br><a href="https://youtu.be/LmHHip-RpGw" target="_blank" rel="noopener">KodingKevin</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/07/23/200724_browserRendering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/23/200724_browserRendering/" class="post-title-link" itemprop="url">브라우저의 렌더링 과정</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-24 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-24T00:00:00+09:00">2020-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-06 01:09:52" itemprop="dateModified" datetime="2021-01-06T01:09:52+09:00">2021-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="브라우저-structure"><a href="#브라우저-structure" class="headerlink" title="브라우저 structure"></a>브라우저 structure</h2><p><img src="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/layers.png" alt="browser components"><br>[사진출처 - html5rocks]</p>
<ol>
<li><p>user interface: 유저가 볼 수 있는 모든 것. 요청한 페이지가 표시되는 창을 제외한 모든 부분(주소창, 책갈피 메뉴 등)을 말한다. 유저는 함부로 조작할 수 없고, ui backend와 함꼐 일한다.</p>
</li>
<li><p>browser engine: 유저 인터페이스와 렌더링 엔진 사이의 mediator</p>
<ul>
<li>브라우저에서 새로고침을 누르면 브라우저 엔진은 명령을 실행하고 웹페이지를 새로 렌더링한다.</li>
</ul>
</li>
<li><p>rendering engine: 요청된 컨텐츠를 parse하여 화면에 렌더링한다.</p>
</li>
</ol>
<ul>
<li>networking: https나 http 요청을 하는 부분으로 networking layer 리소스가 로드되어 있는지 확인한다.</li>
<li>javasscript interpreter: javascript 코드를 parse하고 실행한다.</li>
<li>ul backend: basic widgets를 그리는 데 사용된다.</li>
</ul>
<ol start="4">
<li>data persistence: 자료를 저장하는 layer이다. 쿠키와 같은 모든 종류의 데이터를 로컬에 저장하거나 localStorage, IndexedDB, WebSQL 및 FileSystem과 같은 스토리지 메커니즘을 지원한다.</li>
</ol>
<p>이처럼 브라우저는 굉장히 많은 layer로 구성되어 있으나 <code>렌더링 엔진</code>에만 주목하여 렌더링 과정을 살펴보려 한다. 기본 렌더링 엔진 플로우는 다음과 같다.</p>
<h2 id="브라우저의-렌더링-flow"><a href="#브라우저의-렌더링-flow" class="headerlink" title="브라우저의 렌더링 flow"></a>브라우저의 렌더링 flow</h2><blockquote>
<p>parsing -&gt; render tree -&gt; layout -&gt; paint</p>
</blockquote>
<p>유저가 웹사이트를 열면 렌더링 엔진이 먼저 시작되고 파싱된다. 파싱이 끝나면 트리가 렌더되고, 트리도 렌더링이 끝나면 레이아웃이 실행된다. (브라우저에 따라서 레이아웃 혹은 리플로우라고 부른다.) 참고로 렌더 트리는 <code>rectangles</code>을 포함하는데 이는 색상, 치수 등의 visual attributes를 포함하는 것이며, 화면에 표시되는 올바른 순서를 의미한다. 레이아웃은 각 노드에게 화면에 표시 될 정확한 좌표를 제공한다는 의미이다. 이 단계를 거쳐 마지막으로 paint라는 단계에서 렌더 트리가 순회되고, 각 노드가 ul backend layer를 사용하여 painting된다. 이렇게 모든 단계를 거치면 일종의 색칠 된 object가 나오는 것이다.</p>
<h3 id="parsing"><a href="#parsing" class="headerlink" title="parsing"></a>parsing</h3><p>만약 parser를 개발한다면 이는 두 가지 타입으로 구성된다.</p>
<ol>
<li>conventional : css and javascript<br>파싱은 document를 code가 사용할 수 있는 structure로 해석하는 것을 의미한다.</li>
</ol>
<blockquote>
<p>1 + 2 *3 -&gt; parsing -&gt; someting like tree structure</p>
</blockquote>
<p>documents를 코드가 사용할 수 있는 structure로 translate한다.</p>
<ol start="2">
<li>unconventional: html<br>html document type definition(DOCTYPE)</li>
</ol>
<h3 id="render-tree"><a href="#render-tree" class="headerlink" title="render tree"></a>render tree</h3><p>돔트리가 생성되는 동안 생성된다.</p>
<ul>
<li>visual elements in the order which they are going to be displayed.</li>
<li>elements in the render tree are called renderer or render objects.<br>브라우저에 따라서 renderer 혹은 render object라고 불릴 수 있는데 이는 트리를 구성하는 작은 요소이다. 중요한 것은 렌더 오브젝트가 rectangle이라는 것이다.</li>
<li>render object is a rectangle.</li>
</ul>
<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><ul>
<li><p>calculates position and size</p>
</li>
<li><p>most of the time possible to compute geometry in one path</p>
</li>
<li><p>recursive process begins at the root object(<html>)</p>
</li>
<li><p>dirty bit system<br>html 태그에 있는 루트 객체가 가지고 있는 것.<br>a system that makes sure that browsers don’t need to do the full<br>layout on every interaction.<br>노드나 돔 엘리먼트를 수정했을 때 전체 트리를 모두 다 리렌더 하는 것이 아니라, 수정이 발생한 그 부분만 리렌더 되는 것. 하지만 글로벌 또는 incremental layout도 존재한다.</p>
</li>
<li><p>global and incremental layout</p>
<ul>
<li>global : affects all renders(font size), screen size</li>
<li>incremental layout: 기본적으로 dirty bit system을 사용하여 일부를 렌더링한다.</li>
</ul>
</li>
</ul>
<h3 id="paint"><a href="#paint" class="headerlink" title="paint"></a>paint</h3><p>Render object인 rectangles를 색상으로 채우면 페인트 레이어가 페인트를 하는 것이다.</p>
<p>render tree is being traversed and the paint() method is used to display content on the page.</p>
<p>페인트는 렌더 트리를 통해 기본적으로 페인트 메소드를 재귀적으로 실행한다. 페인트도 역시 lobal and incremental paint로 구성된다. 글로벌 페인팅이 필요하다면 전체페이지가 리페인팅 되고, incremental painting도 같은 dirty bit system으로 진행하되 일부 필요한 부분에 대해서만 리페인팅을 진행하는 것.</p>
<p>reduce the effort of painting the while thing.(dirty bit system)</p>
<ul>
<li>painting order</li>
</ul>
<ol>
<li>backgroud color</li>
<li>background image</li>
<li>border</li>
<li>children</li>
<li>outline</li>
</ol>
<hr>
<h2 id="브라우저의-렌더링-과정"><a href="#브라우저의-렌더링-과정" class="headerlink" title="브라우저의 렌더링 과정"></a>브라우저의 렌더링 과정</h2><p>브라우저의 핵심 기능은 필요한 리소스를 서버에 요청하고 서버의 응답을 받아 응답받은 리소스를 파싱하여 브라우저에 시각적으로 렌더링 하는 것이다. 위에서 살펴본 브라우저 렌더링 flow를 핵심기능에 따라 다시 분류하자면 아래와 같다.</p>
<ul>
<li>Fetch: network layer</li>
<li>Process<ul>
<li>렌더링 엔진</li>
<li>자바스크립트 엔진</li>
<li>ui backend</li>
</ul>
</li>
<li>display<ul>
<li>user interface</li>
<li>브라우저 엔진</li>
</ul>
</li>
<li>storage: data persistence</li>
</ul>
<p>브라우저의 렌더링 과정은 다음과 같다.</p>
<ol>
<li>html, css, javascript 등 렌더링에 필요한 리소스를 요청, 서버로부터 응답을 받는다.</li>
<li>서버로부터 응답된 html과 css를 파싱, dom과 cssom을 생성하여 이를 결합한 render tree를 형성한다.</li>
<li>javascript는 서버로부터 응답된 javascript를 파싱, AST(abstract syntax tree)를 생성하고 바이트 코드로 변환하여 실행한다. <em>이때 javascript는 DOM API를 통해 dom과 cssom을 변경할 수 있고, 변경된 사항이 다시 render tree에 결합된다.</em></li>
<li>render tree를 기반으로 html 요소의 레이아웃을 계산하고, 브라우저 화면에 html 요소를 페인팅한다.</li>
</ol>
<p>브라우저의 렌더링 과정은 다음과 같은 경우 반복해서 레이아웃 계산과 페인팅이 재차 실행되는 리렌더링이 발생한다. 이는 성능에 악영향을 주는 것이므로 리렌더링이 자주 발생하지 않도록 주의해야한다.</p>
<ul>
<li>자바스크립트에 의한 노드 추가 또는 삭제</li>
<li>브라우저 윈도우의 리사이징에 의한 뷰포트(viewport) 크기 변경</li>
<li>HTML 요소의 레이아웃(위치, 크기)에 변경을 발생시키는 width/height, margin, padding, border, display, position, top/right/bottom/left 등의 스타일 변경</li>
</ul>
<h2 id="요청과-응답-주소창을-통해-요청"><a href="#요청과-응답-주소창을-통해-요청" class="headerlink" title="요청과 응답 (주소창을 통해 요청)"></a>요청과 응답 (주소창을 통해 요청)</h2><p>요청: 브라우저의 주소창에 url을 입력하고 엔터를 누르면 루트 요청이 서버로 전송되는데, 루트 요청시 명확히 리소스를 요청하지 않으면 암묵적으로 <code>index.html</code>을 응답하도록 기본 설정되어 있다. 이때 url의 호스트 이름은 dns를 통해 ip주소로 변환되고 이 ip 주소를 갖는 서버에게 요청을 전송한다.</p>
<h3 id="HTTP-1-1과-HTTP-2-0"><a href="#HTTP-1-1과-HTTP-2-0" class="headerlink" title="HTTP 1.1과 HTTP 2.0"></a>HTTP 1.1과 HTTP 2.0</h3><p>HTTP: 웹에서 브라우저와 서버가 통신을 하기 위한 프로토콜(규약)이다.</p>
<ul>
<li>HTTP 1.1: 커넥션 당 하나의 요청과 응답만을 처리하는 <code>단방향 구조</code>이다. 따라서 여러 개의 리소스를 요청해도 개별적으로 전송되고, 응답 역시 마찬가지로 개별적으로 전달된다.</li>
<li>HTTP 2.0: <code>다중 요청/응답</code>이 가능하여 커넥션 당 여러 개의 요청과 응답을 전송할 수 있다. 따라서 1.1에 비해 페이지 로드 속도가 빠르다.</li>
</ul>
<h2 id="HTML-파싱과-DOM-생성"><a href="#HTML-파싱과-DOM-생성" class="headerlink" title="HTML 파싱과 DOM 생성"></a>HTML 파싱과 DOM 생성</h2><p>브라우저 요청에 의해 <em>서버가 응답한 HTML 문서는 문자열로 이루어진 순수한 텍스트이다.</em> 따라서 이를 브라우저에 시각적인 픽셀로 렌더링하려면 HTML 문서를 브라우저가 이해할 수 있는 자료구조인 객체로 변환하여 메모리에 저장해야 한다. 그러면 브라우저의 렌더링 엔진은 파싱된 HTML문서로 브라우저가 이해할 수 있는 자료구조인 DOM을 생성한다.</p>
<blockquote>
<p>HTML 파싱되어 DOM이 생성되는 과정(CSSOM을 생성하는 것을 제외하면 css 파싱과정도 동일하다.)<br>바이트 -&gt; 문자 -&gt; 토큰 -&gt; 노드 -&gt; DOM</p>
<ul>
<li>브라우저가 요청한 HTML파일을 읽어 들여 메모리에 저장한 후 메모리에 저장된 바이트(2진수)로 응답한다.</li>
<li>브라우저는 2진수 형태로 전달받은 HTML 문서를 문자열로 변환한다. 문자열로 변환시 html 파일 내부의 <code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>의 인코딩 방식을 따른다.</li>
<li>이렇게 문자열로 변환된 html 문서를 토큰으로 분해한다. 토큰은 문법적인 의미를 갖는 코드의 최소 단위를 의미한다.</li>
<li>각 토큰들을 객체로 변환하여 노드를 생성한다. 노드는 DOM을 구성하는 기본 요소이다.</li>
<li><em>html 문서는 html 요소들의 집합으로 이루어므로 중첩 관계를 갖는다.</em> 즉 부자 관계를 형성하고 이를 반영한 노드들은 <code>트리 자료구조</code>를 구성한다. 이를 DOM이라 한다.</li>
<li>즉 DOM은 html문서를 파싱한 결과물이다.</li>
</ul>
</blockquote>
<h2 id="렌더-트리-생성"><a href="#렌더-트리-생성" class="headerlink" title="렌더 트리 생성"></a>렌더 트리 생성</h2><p>렌더링 엔진은 서버로부터 응답받은 html과 css를 파싱하여 DOM과 CSSOM을 생성하는데, 이는 렌더링을 위해 <code>render tree</code>로 결합된다. 렌더링은 위한 자료구조이기 때문에 화면에 렌더링되지 않는 노드는 제외된다. 이 렌더 트리는 레이아웃의 위치와 크기를 계산하는 데 사용되고, 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력된다.</p>
<hr>
<h2 id="자바스크립트-파싱과-실행"><a href="#자바스크립트-파싱과-실행" class="headerlink" title="자바스크립트 파싱과 실행"></a>자바스크립트 파싱과 실행</h2><p>자바스크립트 코드에서 Dom이 제공하는 DOM API를 통해 <em>이미 생성된 DOM을 동적으로 조작할 수 있다.</em> 렌더링 엔진이 html 코드를 한 줄씩 순차적으로 parsing하며 dom을 생성하다가 자바스크립트 파일을 로드하는 script 태그나 자바스크립트 코드를 콘텐츠로 담은 script 태그를 만나면 dom 생성을 일시적으로 중단하고, 자바스크립트 엔진에게 제어권을 넘긴다. 제어권을 넘겨받으면 자바스크립트 엔진은 자바스크립트의 코드를 파싱하여 AST를 생성하고, 이를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행한다. 이렇게 자바스크립트 파싱과 실행이 종료되면 제어권은 다시 렌더링 엔진으로 넘겨지고 html 파싱이 중단된 지점부터 다시 파싱을 시작하여 dom 생성을 재개한다. 브라우저는 이처럼 순차적으로 html, css, 자바스크립트를 파싱하고 실행한다. 따라서 자바스크립트 엔진이 dom api를 사용하는데, dom이나 cssom이 생성되기 이전이라면 에러가 발생할 수 있다.<em>script 태그의 위치를 body 요소의 가장 아래에 위치시키면 예기치 못하게 발생할 수 있는 에러를 방지할 수 있다.</em></p>
<p>자바스크립트 파싱과 실행과정은 다음과 같다.</p>
<blockquote>
<p>자바스크립트 소스코드 -&gt; <code>토크나이징</code> - 토크나이저 -&gt; 토큰 -&gt; <code>파싱</code> - parser -&gt; AST -&gt; <code>bytecode generator</code> - 바이트코드 생성 -&gt; 바이트코드 -&gt; execution -&gt; 인터프리터</p>
</blockquote>
<ul>
<li>토크나이징: 문자열인 자바스크립트 소스코드를 문법적 의미를 갖는 코드의 최소 단위인 토큰들로 분해한다.</li>
<li>파싱: 토큰을 분석하여 AST(추상적 구문 트리)를 생성하는데 토큰에 문법적 의미와 구조를 반영한 트리 구조의 자료 구조를 말한다.</li>
<li>바이트 코드 생성과 실행: 파싱의 결과물로 생성된 AST가 인터프리터가 실행할 수 있는 중간 코드인 바이트코드로 변환되고 실행된다.</li>
</ul>
<h2 id="리플로우와-리페인트"><a href="#리플로우와-리페인트" class="headerlink" title="리플로우와 리페인트"></a>리플로우와 리페인트</h2><p>자바스크립트 코드에 DOM API가 사용되었다면 DOM이나 CSSOM이 변경된다. 이때 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링한다. 이를 리플로우(reflow), 리페인트(repaint)라 한다.</p>
<ul>
<li>리플로우: 레이아웃 계산을 다시 하는 것을 말하며, 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등 레이아웃에 영향을 주는 변경이 발생한 경우에 한하여 실행된다.</li>
<li>리페인트: 재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것을 말한다.</li>
</ul>
<hr>
<p><em>References</em></p>
<p><a href="https://medium.com/hackernoon/how-do-web-browsers-work-40cefd2cb1e1" target="_blank" rel="noopener">How Do Web Browsers Work?</a><br><a href="https://youtu.be/0IsQqJ7pwhw" target="_blank" rel="noopener">Kruno: How browsers work | JSUnconf 2017</a><br><a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">html5rocks</a><br><a href="https://poiemaweb.com/fastcampus/browser-rendering#9-script-%ED%83%9C%EA%B7%B8%EC%9D%98-async--defer-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8" target="_blank" rel="noopener">poiemaweb</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/07/22/200723_cssSpecificity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/22/200723_cssSpecificity/" class="post-title-link" itemprop="url">CSS CASCADE</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-23 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-23T00:00:00+09:00">2020-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-06 01:09:52" itemprop="dateModified" datetime="2021-01-06T01:09:52+09:00">2021-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="WHAT-HAPPENS-TO-CSS-WHEN-WE-LOAD-UP-A-WEBPAGE"><a href="#WHAT-HAPPENS-TO-CSS-WHEN-WE-LOAD-UP-A-WEBPAGE" class="headerlink" title="WHAT HAPPENS TO CSS WHEN WE LOAD UP A WEBPAGE?"></a>WHAT HAPPENS TO CSS WHEN WE LOAD UP A WEBPAGE?</h2><ol>
<li><p>LOAD HTML<br>user가 웹페이지를 오픈했을 때, html은 initial html file을 load하는 starting point가 된다.</p>
</li>
<li><p>parse HTML<br>이 단계에서 html head를 포함한 stylesheet를 찾아서 load하고 parse하기 시작한다. 즉 html 코드가 load되면 parse하기 시작하고, 코드를 line by line으로 decode한다. 그리고 css를 load하고 parse 한다.</p>
<ul>
<li>LOAD CSS &amp; PARSE CSS<ul>
<li>cascade: 충돌하는 css 선언을 해결한다. (resolving conflicting css declaractions)</li>
<li>process final css</li>
</ul>
</li>
</ul>
</li>
<li><p>RENDER TREE = DOM + CSSOM<br>위의 과정을 거쳐 브라우저는 <code>DOM</code>을 build하고 전체 web document가 생성된다.</p>
<ul>
<li>DOM(Document Object Model): decoding 된 전체 html code가 저장되는 곳이다.</li>
<li>CSSOM(Css Object Model): css parse가 끝나면 final css가 tree-like structure인 이 곳에 저장된다.</li>
</ul>
</li>
</ol>
<h2 id="CSS-PARSING-PHASE"><a href="#CSS-PARSING-PHASE" class="headerlink" title="CSS PARSING PHASE"></a>CSS PARSING PHASE</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.my-class</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>selector: .my-class 부분</li>
<li>Declaration Block: css rules. <code>color: blue;</code>와 같이 <code>Declaration</code>으로 구성되어 있다. <code>Declaration</code>은 <code>Property</code>인 <code>color</code>와 <code>Declared value</code>인 <code>20px</code>로 구성되어 있다.</li>
</ul>
<h2 id="CASCADE"><a href="#CASCADE" class="headerlink" title="CASCADE"></a>CASCADE</h2><p>서로 다른 stylesheets[different css sources: author, user, browser(user agent)]와 css rules와 declarations의 충돌을 해결하고 결합하는 과정으로 어떤 속성이 가중치가 있는지 체크하는 것이고, 특정 element에는 1가지 이상의 rule이 적용된다. cascade를 체크할 때 가장 중요한 것은 css rule이 어떠한 source를 기반으로 하는 것인지와 관련되어 있다.</p>
<h3 id="different-css-sources"><a href="#different-css-sources" class="headerlink" title="different css sources"></a>different css sources</h3><ul>
<li><p>User-Agent: 브라우저가 elemets에 제공하는 기본 스타일이며, 브라우저 마다 스타일이 다소 다르게 보여질 수 있다. css resets를 사용하여 user-agent styles를 override하는 방법을 쓰는 것이 이러한 차이를 상쇄시키는 방법 중 하나이다.</p>
</li>
<li><p>User: 브라우저 사용자에 의해 정의되고 제어된다. 보통 style을 override하거나 웹사이트 접근성을 추가하기 위한 것으로, 모든 사람이 가지고 있는 것은 아니다.</p>
</li>
<li><p>Author: HTML document에 선언된 css를 말한다. 일반적으로 프론트엔드 개발자가 작성하여 제어할 수 있는 것을 말한다.</p>
</li>
</ul>
<p><em>그런데 css rules와 declarations의 충돌을 어떻게 해결한다는 것일까?</em></p>
<blockquote>
<p>which one takes precedence?<br><code>importance(weight)</code>, <code>specificity</code>, <code>source order</code></p>
</blockquote>
<ul>
<li>importance(weight): 선언된 위치(css source)에 근거하여 각 선언(declaration)에 서로 다른 중요성을 부여하는 것으로 시작한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. user &#96;!important&#96; declarations</span><br><span class="line">2. author &#96;!important&#96; declarations</span><br><span class="line">3. author declarations</span><br><span class="line">4. user declarations</span><br><span class="line">5. default browser declarations</span><br></pre></td></tr></table></figure>

<p>그런데 만약 importance가 모두 같다면?</p>
<ul>
<li>specificity: 선언된 selector의 specificity를 비교하고 계산한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. inline styles</span><br><span class="line">2. IDs</span><br><span class="line">3. classes, pseudo-classes, attribute</span><br><span class="line">4. elements, pseudo-elements</span><br></pre></td></tr></table></figure>

<p>우선순위인 1번부터 차례로 다음과 같이 <code>(inline, IDs, classes, elements)</code>의 순서로 비교한다. 만약 비교한 결과가 (0,0,0,1), (0,1,0,1)이라면 전자가 specificity가 더 높은 것이다.</p>
<p><em>그런데 만약 specificity가 모두 동일하다면?</em></p>
<ul>
<li>source order: 코드의 마지막 선언은 다른 모든 선언을 override하고 적용된다. 만약 3rd-party stylesheets를 사용한다면 author stylesheet는 늘 가장 마지막에 위치해야한다.</li>
</ul>
<p>내가 React project를 했을 때의 경험을 예시로 들어보겠다. 당시 SlidingPane이라는 라이브러리를 사용하여 팝업창을 구성했는데, 기본 설정된 배경색을 다른 색으로 변경했어야 했다. 그러나 이 라이브러리는 몹시 간결한 것이어서 그러한 변경에 대한 방법이 따로 설명되어 있지 않았다. 그래서 선택한 방법은 css파일에 변경해야 할 부분을 작성한 후 원래 있던 코드를 <code>background: #D9DBE0;</code>로 작성한 후 override하는 것이다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 원래 코드: react-sliding-pane.css */</span></span><br><span class="line"><span class="selector-class">.slide-pane</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">8px</span> <span class="number">8px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.5s</span>;</span><br><span class="line">  <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 내가 작성한 author 코드: Cart.css */</span></span><br><span class="line"><span class="selector-class">.slide-pane</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#d9dbe0</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">8px</span> <span class="number">8px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.5s</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">will-change</span>: transform;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 작성 후 react로 작성된 Cart.js 파일의 상단에서 다음과 같은 순서로 import한다.</p>
<blockquote>
<p>import ‘react-sliding-pane/dist/react-sliding-pane.css’;<br>import ‘./Cart.css’;</p>
</blockquote>
<p>이렇게 하면 마지막에 import 된 <code>Cart.css</code>가 원래 존재하던 파일을 override하게 되기 때문에 배경색이 #fff에서 내가 설정한 #D9DBE0으로 변경된다.</p>
<h2 id="CSS-Selector-Specificity"><a href="#CSS-Selector-Specificity" class="headerlink" title="CSS Selector Specificity"></a>CSS Selector Specificity</h2><p>CSS Selector Specificity를 비교하는 과정을 예시를 통해 보다 자세히 알아보겠다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pull-right"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"button button-danger"</span> <span class="attr">href</span>=<span class="string">"link.html"</span>&gt;</span>Don't click here!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>예시에서 <code>.button</code>과 <code>a</code>는 specificity가 낮은 편이기 때문에 다른 속성에서 우선순위에 밀려 배경색이 나타나지 않는다. 하지만 specificity가 낮더라도 <code>!important</code>를 선언하면 다른 어떤 속성보다도 우선순위를 갖고, 즉각 배경색이 버튼에 표시된다. 하지만 <code>!important</code>는 최소 한 번 사용하거나 되도록 쓰지 않는 것이 권장된다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 클래스 1개. low specificity */</span></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 가장 specificity가 낮음 */</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* hover를 제외하면 이 선언이 세가지 중에 가장 우선순위가 높다. */</span></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-tag">div</span><span class="selector-class">.pull-right</span> <span class="selector-tag">a</span><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: orangered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-tag">a</span><span class="selector-class">.button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 코드에서 button에 마우스를 hover하면 색깔이 yellow로 바껴야 하지만, 아무런 변화가 없다. 그 이유는 pseudo class인 hover는 specificity에서 1으로 카운트되기 때문이다. 그러나 <code>#nav div.pull-right a.button</code> 이 경우 specificity는 id 1개, class 2개를 가지고 있다. <code>#nav a.button:hover</code>도 사실은 id 1개, class 2개를 가지고 있는 것인데, <code>hover</code>는 <em>class가 아니라 class인 것으로 여기는 pseudo class이다.</em> 따라서 전자는 2개의 elements를 가지고 있고, 후자는 1개의 elements를 가지고 있다. 결과적으로 <code>#nav div.pull-right a.button</code>가 훨씬 specificity가 높은 것이다. 따라서 hover는 적용되지 않는다. 만약 hover했을 때 색깔이 변경되도록 설정하고 싶다면 아래와 같이 코드를 바꾸어야 한다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#nav</span> <span class="selector-tag">div</span><span class="selector-class">.pull-right</span> <span class="selector-tag">a</span><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: orangered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-tag">div</span><span class="selector-class">.pull-right</span> <span class="selector-tag">a</span><span class="selector-class">.button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-tag">a</span><span class="selector-class">.button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 코드를 작성하면 <code>#nav div.pull-right a.button</code>에 pesudo class인 <code>hover</code>가 추가되어 <code>hover</code>가 붙지 않은 elements와 비교했을 때 specificity가 높아진다. 따라서 hover했을 때 색깔이 green으로 바뀌는 것이다.</p>
<hr>
<p><em>References</em><br><a href="https://blog.logrocket.com/how-css-works-understanding-the-cascade-d181cd89a4d8/" target="_blank" rel="noopener">How CSS works: Understanding the cascade</a><br><a href="https://www.udemy.com/course/advanced-css-and-sass/learn/lecture/8274402#content" target="_blank" rel="noopener">Advanced css and sass</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Heejin Lee</p>
  <div class="site-description" itemprop="description">Today I Learned</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heejin Lee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
