<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heejinlee07.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Today I Learned">
<meta property="og:type" content="website">
<meta property="og:title" content="Heejin">
<meta property="og:url" content="https://heejinlee07.github.io/page/11/index.html">
<meta property="og:site_name" content="Heejin">
<meta property="og:description" content="Today I Learned">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Heejin Lee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://heejinlee07.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Heejin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Heejin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Front-end Developer</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/02/25/200226_scope_ex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/200226_scope_ex/" class="post-title-link" itemprop="url">스코프 실습</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-26 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-26T00:00:00+09:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-02 18:20:24" itemprop="dateModified" datetime="2022-03-02T18:20:24+09:00">2022-03-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="다음과-같은-중첩함수가-있을-때-console-log에는-어떤-값이-출력될까"><a href="#다음과-같은-중첩함수가-있을-때-console-log에는-어떤-값이-출력될까" class="headerlink" title="다음과 같은 중첩함수가 있을 때, console.log에는 어떤 값이 출력될까?"></a>다음과 같은 중첩함수가 있을 때, console.log에는 어떤 값이 출력될까?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 중첩 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 외부 함수의 변수를 참조할 수 있다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(x + y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> content = outer();</span><br><span class="line">content();</span><br></pre></td></tr></table></figure>
<p>outer 함수는 변수 content의 이름으로 할당되었는데, 이 함수가 반환하는 값은 <code>let x = 3</code>이 아니라 inner이다. outer 내부의 inner 함수가 return값으로 설정되어 있기 때문이다. 따라서 inner 함수내부에서 실행한 <code>x+y의 값인 5</code>가 콘솔에 출력된다.</p>
<p><em>그런데 의아한 부분이 있다.</em></p>
<p>inner 함수 내부에는 <code>let y = 2</code>의 y값만 할당되어 있고, x값은 할당되어 있지 않다. 그런데 어떻게 두 값이 x+y로 연산되어 출력된 것일까?</p>
<p>가장 먼저 생성된 outer 함수가 호출되면 이 함수는 stack의 가장 아래에 쌓인다. (stack 가장 마지막에 들어온 것이 가장 먼저 나가는 구조이다.)<br>그 다음 inner 함수를 호출하면 이 함수는 outer의 위에 쌓인다. 그런데 변수 content에 outer 함수를 호출했을 때 반환하는 값은 inner 함수이다. 결국 content = inner 함수가 되는 셈이다.</p>
<p>그래서 실행 컨텍스트에 따라 inner함수를 살펴본다. inner 함수 내부에는 콘솔에 x+y의 값이 찍히도록 되어 있지만 y의 값만 존재한다. 그럼 이 함수는 바로 상위로 향하여 x값이 존재하는지를 살펴본다. 만약 존재한다면 그 값을 참조하여 x + y의 값을 출력한다. 하지만 만약 여기서도 x값이 존재하지 않는다면 그보다 상위 개념에 x값이 존재하는지를 살펴보았을 것이다. 이처럼 자바스크립트의 스코프는 함수의 중첩에 따라 계층적 구조를 가지기 때문에 하위 스코프인 inner 함수에 필요로 하는 식별자가 없다면 그보다 상위 스코프이자 outer environment인 outer 함수에 식별자가 있는지 확인하고 있다면 그 값을 참조한다.</p>
<p>그리고 모든 스코프의 가장 최상위에는 전역 스코프가 존재한다.</p>
<h2 id="그렇다면-전역-스코프에-변수가-할당되어-있다면-어떻게-될까"><a href="#그렇다면-전역-스코프에-변수가-할당되어-있다면-어떻게-될까" class="headerlink" title="그렇다면, 전역 스코프에 변수가 할당되어 있다면 어떻게 될까?"></a>그렇다면, 전역 스코프에 변수가 할당되어 있다면 어떻게 될까?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 중첩 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 외부 함수의 변수를 참조할 수 있다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(x + y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> content = outer();</span><br><span class="line">content();</span><br></pre></td></tr></table></figure>
<p>outer 함수의 상위인 전역 스코프에 <code>let x = 1</code>이라는 값이 할당되어 있다. 이때 x+y의 값은 콘솔에 어떻게 출력될까? stack의 구조와 상위 구조로 가면서 변수 식별자를 찾는 것에 따라 x + y의 값은 이제 1 + 3을 한 4라는 값이 찍힐까?</p>
<p>이 경우에는 함수가 한 번 호출되어 실행 컨텍스트를 한 번 돌아서 종료되면 stack에 저장되어 있는 값은 사라진다는 개념을 알아야한다. (해제된다는 개념이 더 정확할 것이다.) 만약 <code>let x = 1;</code>이 전역 스코프로 작성되고, outer 함수 내부에는 변수 x에 대한 할당이 따로 없었다면 3이라는 결과가 출력되었을 것이다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/02/25/200225_function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/200225_function/" class="post-title-link" itemprop="url">함수 / Function</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-26 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-26T00:00:00+09:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-02 18:20:24" itemprop="dateModified" datetime="2022-03-02T18:20:24+09:00">2022-03-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h2><p>input과 output이 이루어지는 일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것. 한 가지 일을 수행하는 코드가 블럭으로 묶여 있는 것.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 함수명(<span class="params">매개변수</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 반환값;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//함수를 정의하는 코드블록, 함수 정의로 함수생성</span></span><br><span class="line"></span><br><span class="line">함수명(인수); <span class="comment">//함수호출, 인수를 매개변수를 통해 함수에게 전달</span></span><br><span class="line"><span class="comment">//코드블록의 문을 실행하여 반환값 반환</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>함수명은 생략 가능(익명함수) 이름이 있다면 기명 함수</p>
</blockquote>
<ul>
<li>매개변수(parameter): 함수의 정의에서 전달받은 인수를 함수 내부로 전달하기 위해 사용하는 변수. 함수 몸체 내부에서만 참조 가능, 외부에서는 참조할 수 없다.</li>
<li>인수(argument): 함수가 호출될 때 함수로 값을 전달해주는 값. 인수를 매개변수를 통해 함수에게 전달. 값으로 평가될 수 있는 표현식이어야 한다.</li>
</ul>
<blockquote>
<p>인수 -&gt; 인수 전달 -&gt; 매개변수 -&gt; return 반환값 -&gt;함수 외부로 반환<br>매개변수와 인수의 개수가 일치하는지 여부는 체크하지 않는다.<br>매개변수의 이상적인 개수는 0개이며, 최대 3개 이상을 넘기지 않는 것을 권장한다.<br>만약 그 이상이 필요하다면 매개변수 선언 후 객체를 인수로 전달받는 것이 좋다.<br>매개 변수가 많아지면 함수 호출 시 전달해야 할 인수의 순서를 고려한다.</p>
</blockquote>
<h2 id="함수의-사용-이유"><a href="#함수의-사용-이유" class="headerlink" title="함수의 사용 이유"></a>함수의 사용 이유</h2><ul>
<li>코드의 재사용: 동일한 작업을 반복 수행할 때 코드를 여러번 작성하는 대신 호출하여 재사용</li>
<li>코드의 중복 억제: 중복된 코드를 여러 번 작성하면 수정도 여러 번 해야함.</li>
<li>코드의 가독성 향상: 함수 이름(식별자)을 통해 함수의 역할 파악</li>
</ul>
<h2 id="함수-리터럴"><a href="#함수-리터럴" class="headerlink" title="함수 리터럴"></a>함수 리터럴</h2><p>함수 리터럴로 함수를 생성한다. <em>함수의 이름을 생략할 수 있다.</em></p>
<p>함수 == 객체<br>함수 != 일반 객체</p>
<blockquote>
<p>함수 - 호출가능, 함수 객체 고유의 프로퍼티 가짐.<br>일반 객체 - 호출불가</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add라는 이름의 변수를 만들고 함수를 담는다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>함수 리터럴의 4가지 부분</code></p>
<ol>
<li>function이라는 예약어 (예시의 function)</li>
<li>function의 이름 (예시는 익명 함수)</li>
</ol>
<ul>
<li>기명함수: 함수 이름이 있음</li>
<li>익명 함수: 함수 이름이 없음.</li>
</ul>
<ol>
<li>function의 매개변수 (예시의 a,b)<blockquote>
<p>매개변수의 이름은 함수의 변수로 정의된다. 그러나 다른 변수와는 달리<br><code>undefined</code>로 초기화되는 대신 함수가 호출될 때의 <code>인수</code>로 초기화된다.</p>
</blockquote>
</li>
<li>중괄호({})로 감싸진 문(statement)</li>
</ol>
<ul>
<li>함수의 몸체</li>
<li>함수가 호출될 때 실행된다.</li>
</ul>
<hr>
<h2 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h2><p>함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것</p>
<h3 id="함수-선언문"><a href="#함수-선언문" class="headerlink" title="함수 선언문"></a>함수 선언문</h3><p>함수 리터럴과 형태는 같지만 그와 달리 함수 선언문에서는 함수 이름을 생략할 수 없다. <em>함수 선언문은 또한 표현식이 아닌 ‘문’이다.</em>(변수에 할당할 수 없다.) 따라서 함수 선언문을 실행하면 undefined가 출력된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coffee</span>(<span class="params">temp, menu</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> temp + menu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//함수명(예시에서 coffee)</span></span><br><span class="line"><span class="comment">//함수명을 생략하면 오류가 발생한다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(coffee(<span class="string">"iced"</span>, <span class="string">"americano"</span>));</span><br><span class="line"><span class="comment">//icedamericano가 출력된다.</span></span><br><span class="line"><span class="comment">//iced americano로 출력하고 싶다면</span></span><br><span class="line"><span class="comment">//retuen temp + ' ' + menu;로 반환값을 작성한다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//다음과 같이 함수를 선언할 수도 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coffee</span>(<span class="params">temp, menu</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(temp + <span class="string">" "</span> + menu);</span><br><span class="line">&#125;</span><br><span class="line">coffee(<span class="string">"iced"</span>, <span class="string">"americano"</span>);</span><br><span class="line"><span class="comment">//iced americano</span></span><br></pre></td></tr></table></figure>
<h3 id="함수-선언문-vs-함수리터럴-vs-함수-표현식"><a href="#함수-선언문-vs-함수리터럴-vs-함수-표현식" class="headerlink" title="함수 선언문 vs 함수리터럴 vs 함수 표현식"></a>함수 선언문 vs 함수리터럴 vs 함수 표현식</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>함수 리터럴</code>: 식별자는 옵션이므로 없어도 된다. 함수 리터럴은 함수 그 자체가 아니라 함수의 값이다. 따라서 함수는 함수 리터럴을 참조한다고 할 수 있다. <em>단, 자바스크립트 엔진은 상황에 따라 동일한 함수 리터럴에 대해 함수 선언문(표현식이 아닌 문) 또는 함수 리터럴 표현식(표현식인 문)으로 해석하기도 한다.</em></li>
<li><code>함수 선언문</code>: 표현식이 아닌 문이다. <em>단, 자바스크립트 엔진은 함수 선언문을 표현식으로 변환하여 함수 객체를 생성한다고 할 수 있다.</em></li>
<li><code>함수 표현식</code>: 표현식인 문이다.</li>
</ul>
<h3 id="함수-표현식"><a href="#함수-표현식" class="headerlink" title="함수 표현식"></a>함수 표현식</h3><blockquote>
<p>함수 리터럴로 생성한 함수 객체를 변수에 할당하는 것.</p>
</blockquote>
<p>함수는 일급객체이므로 함수를 값처럼 자유롭게 사용할 수 있다. 함수는 객체 타입의 값이기 때문에 변수에 할당할 수 있고, 프로퍼티 값이 될 수 있고, 배열의 요소가 될 수도 있다.</p>
<h3 id="함수-생성-시점과-함수-호이스팅"><a href="#함수-생성-시점과-함수-호이스팅" class="headerlink" title="함수 생성 시점과 함수 호이스팅"></a>함수 생성 시점과 함수 호이스팅</h3><p><code>함수 선언문</code>: 함수를 정의함. 함수 선언문 이전에 호출 및 참조 가능. 런타임 이전에 먼저 실행됨.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>함수 정의 -&gt; 함수 객체 생성 -&gt; 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당 -&gt; 런타임 -&gt; 런타임 때 평가되어 함수 리터럴이 함수 객체가 됨.</p>
<p><code>함수 호이스팅</code>: 위와 같이 함수 선언문이 선두로 끌어 올려진 것처럼 동작하는 것</p>
<p><code>변수 호이스팅 vs 함수 호이스팅</code></p>
<ul>
<li>공통점: 런타임 이전에 먼저 실행되어 식별자를 생성한다.</li>
<li><code>변수</code>: undefined로 초기화됨.</li>
<li><code>함수 선언문</code>: 함수 객체로 초기화됨.</li>
</ul>
<p><code>함수 표현식</code>: 변수 할당문의 값이 함수 리터럴인 문. 변수 선언문과 변수 할당문의 축약 표현과 동일하게 동작.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// TypeError: sub is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>함수 표현식의 함수 리터럴은 할당문이 실행되는 시점(런타임)에 평가되어 함수 객체가 됨.<br>이 경우 함수 호이스팅이 아니라 변수 호이스팅이 발생.</p>
<blockquote>
<p>함수 선언문은 함수 호출 전에 반드시 함수를 선언해야한다는 규칙을 무시하고, 선언문 이전에도 참조 및 호출이 가능하다. <em>따라서 가능한 함수 표현식을 쓰는 것이 권장된다.</em></p>
</blockquote>
<h3 id="function-생성자-함수"><a href="#function-생성자-함수" class="headerlink" title="function 생성자 함수"></a>function 생성자 함수</h3><p>객체를 생성하는 방법에는 factory함수와 생성자(constructor)함수가 있다.</p>
<p><code>factory 함수</code>: 객체를 반환하는 클래스나 생성자가 아닌 함수. 자바스크립트의 함수는 new 키워드가 없어도 객체를 반환다.</p>
<p><code>생성자 함수</code>: 객체를 생성하는 함수<br>step1. 생성자 함수를 작성하여 개체를 정의한다. (파스칼 케이스를 사용한다.)<br>step2. new 키워드를 사용하여 개체의 인스턴스를 만든다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">car</span>(<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.make = make;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  <span class="keyword">this</span>.year = year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//함수의 인자로 전달받은 값을 개체의 속성에 할당하기 위해 `this`를 사용한다.</span></span><br><span class="line"><span class="comment">//this는 코드블록이 실행될 때 빈 객체를 참조한다.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mycar = <span class="keyword">new</span> Car(<span class="string">"Eagle"</span>, <span class="string">"Talon TSi"</span>, <span class="number">1993</span>);</span><br><span class="line"><span class="comment">//new는 빈 객체를 만든다.</span></span><br><span class="line"><span class="comment">//위에 정의된 함수에서 this는 new가 생성한 빈 객체를 가리킬 수 있게 한다.</span></span><br><span class="line"><span class="comment">//this를 통해 new가 생성한 빈 객체에 접근한다.</span></span><br><span class="line"><span class="comment">//new가 새로 생성한 객체에 함수의 값을 반환한다.</span></span><br></pre></td></tr></table></figure>
<h3 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h3><p>ES6에서 새롭게 도입된 화살표 함수(Arrow function)는 function 키워드 대신 화살표(=&gt;, Fat arrow)를 사용하여 보다 간략한 방법으로 함수를 선언할 수 있다. 화살표 함수는 항상 익명 함수로 정의한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<h2 id="반환문"><a href="#반환문" class="headerlink" title="반환문"></a>반환문</h2><ul>
<li>함수의 실행을 중단하고 함수 몸체를 빠져나간다.</li>
<li>반환문 이후에 다른 문이 존재하면 그 문은 무시된다.</li>
<li>반환문을 생략하면 <code>undefined</code>가 반환된다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y; <span class="comment">//반환문</span></span><br><span class="line">  <span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//실행되지 않는다.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="다양한-함수의-형태"><a href="#다양한-함수의-형태" class="headerlink" title="다양한 함수의 형태"></a>다양한 함수의 형태</h2><h3 id="즉시실행함수"><a href="#즉시실행함수" class="headerlink" title="즉시실행함수"></a>즉시실행함수</h3><p>함수 정의와 동시에 즉시 호출된다. <code>단 한번</code>만 호출되며 다시 호출할 수 없다. 보통 익명함수를 사용함.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 익명 즉시 실행 함수</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="재귀-함수"><a href="#재귀-함수" class="headerlink" title="재귀 함수"></a>재귀 함수</h3><p>함수가 자기 자신을 호출하는, 재귀 호출을 수행하는 함수를 말한다. <em>재귀 함수는 자신을 무한 재귀 호출하므로 반드시 탈출 조건을 만들어야한다.</em> 그렇지 않으면 에러가 발생한다. 대부분 재귀 함수는 for문이나 while문으로 구현할 수 있다. 하지만 재귀함수를 쓰면 반복문 없이도 구현이 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countdown</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">  countdown(n - <span class="number">1</span>); <span class="comment">// 재귀 호출</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countdown(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h3 id="중첩-함수"><a href="#중첩-함수" class="headerlink" title="중첩 함수"></a>중첩 함수</h3><p>함수 내부에 정의된 함수이며, 내부 함수라 부르기도 한다. 중첩 함수를 포함하는 함수는 외부 함수라 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 중첩 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 외부 함수의 변수를 참조할 수 있다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(x + y); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<h3 id="콜백-함수"><a href="#콜백-함수" class="headerlink" title="콜백 함수"></a>콜백 함수</h3><p>함수의 매개변수를 통해 전달되는 함수를 콜백 함수(Callback function)라고 하며, 콜백 함수를 매개변수를 통해 전달받은 함수를 고차 함수(Higher-Order Function, HOF)라고 한다.</p>
<p>콜백 함수는 고차 함수에 전달되어 헬퍼 함수의 역할을 한다.<br>함수 외부에서 고차 함수 내부로 주입하므로 자유롭게 교체가 가능하다.<br>고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정하여 호출한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//함수를 호출하면 함수를 만들어서 리턴</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base + num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plus5 = plus(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(plus5(<span class="number">10</span>)); <span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 또다른 함수를 만들 수 있다.</span></span><br><span class="line"><span class="keyword">const</span> plus7 = plus(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(plus7(<span class="number">15</span>)); <span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//함수를 호출할 때, 인자로 함수 사용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"callback"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//hello -&gt; 콜백 순으로 실행</span></span><br></pre></td></tr></table></figure>
<h3 id="순수-함수와-비순수-함수"><a href="#순수-함수와-비순수-함수" class="headerlink" title="순수 함수와 비순수 함수"></a>순수 함수와 비순수 함수</h3><p>순수 함수(Pure function): 어떤 외부 상태에 의존하지도 않고 변경시키지도 않는, 즉 부수 효과가 없는 함수, 동일한 인수가 전달되면 동일한 값을 반환한다.<br>비순수 함수(Impure function): 외부 상태를 변경시키는 즉, 부수 효과가 있는 함수</p>
<hr>
<p><em>References</em></p>
<p><a href="http://tcpschool.com/javascript/js_function_parameterArgument" target="_blank" rel="noopener">TCP SCHOOL</a><br><a href="https://www.oreilly.com/library/view/javascript-the-good/9780596517748/ch04s02.html" target="_blank" rel="noopener">OREILLY</a><br><a href="https://medium.com/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1" target="_blank" rel="noopener">Medium</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Obsolete_Pages/Core_JavaScript_1.5_Guide/Creating_New_Objects/Using_a_Constructor_Function" target="_blank" rel="noopener">MDN</a><br><a href="https://www.youtube.com/watch?v=23AOrSN-wmI&amp;t=314s" target="_blank" rel="noopener">Programming with Mosh</a><br><a href="https://poiemaweb.com/fastcampus/function#41-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%EB%AC%B8" target="_blank" rel="noopener">Poiemaweb</a><br><a href="https://www.fastcampus.co.kr/courses/201133/clips/" target="_blank" rel="noopener">fastcampus</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/02/25/200225_scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/200225_scope/" class="post-title-link" itemprop="url">스코프 / Scope</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-26 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-26T00:00:00+09:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-02 18:20:24" itemprop="dateModified" datetime="2022-03-02T18:20:24+09:00">2022-03-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h2><p>모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프(Scope, 유효범위)라 한다. <em>즉, 스코프는 식별자가 유효한 범위를 말한다.</em></p>
<p>스코프(유효 범위)를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있도록 한다. 스코프 내에서 식별자는 유일한 것으로 중복되어선 안된다. 따라서 만약 한 스코프 내에 ‘variable’라는 이름의 식별자가 있다면, 이 스코프 내에서는 한 번만 사용할 수 있다. 그러나 다른 스코프에서 동일한 이름의 ‘variable’라는 식별자를 사용하는 것은 가능하다.</p>
<h2 id="스코프가-왜-중요한가"><a href="#스코프가-왜-중요한가" class="headerlink" title="스코프가 왜 중요한가?"></a>스코프가 왜 중요한가?</h2><ul>
<li>네임스페이스 충돌을 방지할 수 있다.</li>
<li>변수가 임의 수정되는 현상을 방지할 수 있다.</li>
</ul>
<h2 id="스코프의-종류"><a href="#스코프의-종류" class="headerlink" title="스코프의 종류"></a>스코프의 종류</h2><p>변수는 자신이 선언된 위치(전역 or 지역)에 의해 자신이 유효한 범위인 스코프가 결정됨.</p>
<ul>
<li><code>전역(global)</code>: 코드의 가장 바깥 영역, 전역 스코프, 전역 변수<ul>
<li>전역 변수는 어디에서나 참조할 수 있다.</li>
<li>함수나 블록 안에 들어 있지 않은 모든 변수를 의미한다.</li>
</ul>
</li>
<li><code>지역(local)</code>: 함수 몸체 내부, 지역 스코프, 지역 변수<ul>
<li>자신이 선언된 지역과 하위 지역(중첩 함수)에서만 참조할 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="스코프-체인"><a href="#스코프-체인" class="headerlink" title="스코프 체인"></a>스코프 체인</h2><p>스코프는 함수의 중첩에 의해 계층적 구조를 갖고, 모든 지역의 최상위 스코프는 <code>전역 스코프</code>이다. <strong>이처럼 스코프가 계층적으로 연결된 것을 스코프 체인</strong>이라 한다. <u>스코프 체인은 실행 컨텍스트의 렉시컬 환경(코드가 어기서 실행되었고, 주변에 어떤 코드가 있는 지에 관한 context)을 단방향으로 연결한 것이다.</u></p>
<ul>
<li><code>외부 함수</code>: 중첩 함수를 포함하는 함수</li>
<li><code>중첩 함수</code>: 함수 몸체 내부에 정의한 함수</li>
</ul>
<p>자바스크립트 엔진은 스코프 체인을 따라 <strong>변수를 참조하는 코드의 스코프에서 상위 스코프 방향으로 이동</strong>하며 선언된 변수를 검색한다. 절대 하위 스코프로 내려가면서 식별자를 검색하는 일은 없다. 이는 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 <u>하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다는 것을 의미한다.</u></p>
<h2 id="함수-레벨-스코프"><a href="#함수-레벨-스코프" class="headerlink" title="함수 레벨 스코프"></a>함수 레벨 스코프</h2><ul>
<li><code>함수 레벨 스코프</code>: 코드 블록이 아닌 <code>함수</code>에 의해서 생성된 코드 블록을 지역 스코프로 인정한다.</li>
<li><code>블록 레벨 스코프</code>: 함수 몸체 만이 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만든다. e.g. java, c 등</li>
<li>단, var키워드는 함수 내부가 아닌 곳에서 선언하면 코드 블록 내에서 선언되었다 하더라도 <code>전역 변수</code>라서 중복선언을 허용하는데, 함수의 코드 블록만이 <code>지역 스코프</code>로 인정된다.</li>
</ul>
<h2 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h2><ul>
<li><code>동적 스코프</code>: 함수 정의 시점에는 함수가 어디서 호출될 지 알 수 없다. 따라서 함수가 호출되는 시점에 동적으로 상위 스코프를 결정하는 것을 말한다.</li>
<li><code>렉시컬 스코프 (정적 스코프)</code>: 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정, 자바스크립트는 함수를 어디서 정의했는지에 따라 상위 스코프를 결정하므로 렉시컬 스코프를 따른다.</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">스코프</th>
<th style="text-align:center">조건</th>
<th style="text-align:left">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">동적 스코프</td>
<td style="text-align:center">함수를 <code>호출</code>한 곳</td>
<td style="text-align:left">함수 정의 시점에 함수가 호출될 곳이 어딘지 알 수 없음. <strong>함수가 호출되는 시점에 동적으로 상위 스코프 결정</strong></td>
</tr>
<tr>
<td style="text-align:center">정적(렉시컬) 스코프</td>
<td style="text-align:center">함수를 <code>정의</code>한 곳</td>
<td style="text-align:left">함수 정의 시점에 상위 스코프가 정적으로 결정됨. <strong>함수 호출 위치와는 관련없음.</strong></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><em>References</em><br><a href="https://poiemaweb.com/fastcampus/scope" target="_blank" rel="noopener">poiemaweb</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/02/25/0225_rubberduck/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/0225_rubberduck/" class="post-title-link" itemprop="url">200225 러버덕 정리</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-25 20:07:25" itemprop="dateCreated datePublished" datetime="2020-02-25T20:07:25+09:00">2020-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-02 18:20:24" itemprop="dateModified" datetime="2022-03-02T18:20:24+09:00">2022-03-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="연산자-—의-부수효과"><a href="#연산자-—의-부수효과" class="headerlink" title="연산자 ++,—의 부수효과"></a>연산자 ++,—의 부수효과</h2><p>단항 산술 연산자는 이항 산술연산자와는 달리 값을 변경하는 부수효과가 있다.<br>예를 들어 1 + 1 은 값을 변경하는 것이 아니라 2라는 새로운 값을 반환하는 것 뿐이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a++의 경우 선할당 후증가</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">a++; <span class="comment">// 1</span></span><br><span class="line">a; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//++a의 경우 선증가 후할당</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">++a; <span class="comment">// 2</span></span><br><span class="line">a; <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h2 id="for문의-실행순서"><a href="#for문의-실행순서" class="headerlink" title="for문의 실행순서"></a>for문의 실행순서</h2><p>for문은 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (할당문 or 선언문, 조건식, 증감식)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">조건식이 참인 경우 반복 실행될 문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>할당문 or 선언문 실행(최초 한 번만 실행, 그렇지 않으면 반복될 때마다 값이 초기화됨)</li>
<li>조건식 실행하여 true/false 판단</li>
<li>true일 경우 코드블록의 문을 실행</li>
<li>증감식으로 이동하여 값을 증가함.</li>
<li>다시 조건식으로 돌아가 true/false 판단 (false라고 판단되었을 때 문의 실행은 종료)</li>
</ol>
<h2 id="if문과-삼항연산자"><a href="#if문과-삼항연산자" class="headerlink" title="if문과 삼항연산자"></a>if문과 삼항연산자</h2><p><code>if문</code>: 참/거짓을 판단하여 주어진 조건식의 평가 결과에 따라 코드블록 실행</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (조건식<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//조건식이 참일 때 실행</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (조건식<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">//조건식이 참일 때 실행 &#123;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//조건식1/2가 모두 거짓일 때 실행</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//else if는 여러 번 사용가능.</span></span><br></pre></td></tr></table></figure>
<p><code>삼항조건연산자</code>: 참/거짓을 판단하여 조건식의 결과에 따른 값을 반환하므로 if문을 대체하여 사용가능<br>조건식 ? 조건식이 참일 때 반환할 값 : 조건식이 거짓일 때 반환할 값</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/02/23/0224_rubberduck/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/23/0224_rubberduck/" class="post-title-link" itemprop="url">200224 러버덕 정리</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-24 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-24T00:00:00+09:00">2020-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-02 18:20:24" itemprop="dateModified" datetime="2022-03-02T18:20:24+09:00">2022-03-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="리터럴"><a href="#리터럴" class="headerlink" title="리터럴"></a>리터럴</h2><p>값을 생성하는 가장 간단한 방법<br>사람이 이해할 수 있는 문자로 값을 생성<br>런타임 때 값을 평가하여 생성함</p>
<h2 id="표현식인-문과-표현식이-아닌-문"><a href="#표현식인-문과-표현식이-아닌-문" class="headerlink" title="표현식인 문과 표현식이 아닌 문"></a>표현식인 문과 표현식이 아닌 문</h2><p>값: 표현식이 평가되어 생성된 결과<br>표현식: 값으로 평가될 수 있는 문<br>문: 컴퓨터에 내리는 명령. 선언문, 할당문, 조건 문 등<br>표현식인 문: 변수에 할당할 수 있는 문으로 값을 생성한다.<br>표현식이 아닌 문: 변수에 할당할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">-&gt;<span class="literal">undefined</span></span><br><span class="line"><span class="comment">//변수 선언문은 표현식이 아닌 문이기 때문에</span></span><br><span class="line"><span class="comment">//평가할 수 없어서 완료된 평가값이 나올 자리에</span></span><br><span class="line"><span class="comment">//평가값 대신 undefined가 출력된다.</span></span><br><span class="line"><span class="comment">//undefined는 평가된 값이 아닌 완료값이다.</span></span><br><span class="line"> a = <span class="number">1</span>;</span><br><span class="line">-&gt;<span class="number">2</span></span><br><span class="line"><span class="comment">//변수 할당문은 표현식인 문이기 때문에 평가된 값 2가 출력된다.</span></span><br></pre></td></tr></table></figure>
<h2 id="데이터-타입"><a href="#데이터-타입" class="headerlink" title="데이터 타입"></a>데이터 타입</h2><p>원시타입: string, number, boolean, null, undefined, symbol<br>객체: object, array, function…</p>
<p>원시타입은 변경불가하고, 객체는 변경가능하다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/02/23/200224_type_casting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/23/200224_type_casting/" class="post-title-link" itemprop="url">타입 변환과 단축 평가 / Type casting</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-24 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-24T00:00:00+09:00">2020-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-02 18:20:24" itemprop="dateModified" datetime="2022-03-02T18:20:24+09:00">2022-03-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="타입-변환"><a href="#타입-변환" class="headerlink" title="타입 변환"></a>타입 변환</h2><blockquote>
<p>하나의 데이터 타입이 다른 데이터 타입으로 자동 또는 암묵적으로 변환되는 것.<br>타입 캐스팅(Type conversion (or typecasting))은 명시적(explicit)과 암묵적(implicit)인 타입 변환이 동시에 이루어진다.</p>
</blockquote>
<p>컴파일러가 자동으로 데이터 타입을 할당할 때 암묵적 타입변환이 자동으로 발생하는데, 소스코드에서도 명시적인 변환이 필요하다.</p>
<p><code>5+2.0</code>에서 부동소수점 <code>2.0</code>은 암묵적으로 정수로 타입변환되는데, Number(“0x11”)에서 문자열인 “0x11”은 숫자 17로 명시적으로 변환된다.(16진수로 계산하여 17 (1 * 16 + 1 = 17)</p>
<p>타입 강제변환(type coercion)은 암묵적인 타입 변환이 이루어진다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value1 = <span class="string">"5"</span>;</span><br><span class="line"><span class="keyword">const</span> value2 = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">let</span> sum = value1 + value2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
<p>숫자 리터럴 <code>9</code>는 문자열로 변환되고, value1과 value2의 값이 연결되어 문자열 <code>59</code>가 출력된다. 자바스크립트는 문자열과 숫자가 있을 때 문자열을 이용하기 때문이다. 따라서 만약 숫자 <code>5 + 9</code>를 더한 <code>14</code>의 결과를 출력하고 싶다면 number() 메소드를 통해서 명시적인 타입 변환을 해주어야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="built_in">Number</span>(value1) + value2;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>명시적 타입 변환(Explicit coercion) 또는 타입 캐스팅(Type casting)<br>개발자가 의도적으로 값의 타입을 변환하는 것</li>
<li>암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)<br>개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것.</li>
</ul>
<p>이러한 명시적 또는 암묵적 타입 변환이 기존 원시값을 직접 변경하는 것은 아니다. 원시값은 변경불가이기 때문이다. 타입 변환이란 기존 원시값을 사용하여 다른 타입의 새로운 원시값을 생성하는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 원시값 1이 '1'로 직접 변경되는 것이 아니다.</span></span><br><span class="line"><span class="comment">// 1을 사용해 타입이 다른 '1'을 새롭게 생성하여 '1' + ''을 평가한다.</span></span><br><span class="line"><span class="number">1</span> + <span class="string">""</span>; <span class="comment">// '1'</span></span><br></pre></td></tr></table></figure>
<h2 id="암묵적-타입-변환"><a href="#암묵적-타입-변환" class="headerlink" title="암묵적 타입 변환"></a>암묵적 타입 변환</h2><p>표현식을 평가할 때 코드 문맥에 부합하지 않더라도 자바스크립트는 암묵적 타입 변환을 통해 표현식을 평가하고, 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">"2"</span>; <span class="comment">//"12" 문자열 타입으로 변환</span></span><br><span class="line"><span class="number">1</span> - <span class="string">"1"</span>; <span class="comment">//0 숫자열 타입으로 변환</span></span><br><span class="line"><span class="comment">//불리언 타입으로 변환</span></span><br></pre></td></tr></table></figure>
<h2 id="명시적-타입-변환"><a href="#명시적-타입-변환" class="headerlink" title="명시적 타입 변환"></a>명시적 타입 변환</h2><p>개발자의 의도에 의해 명시적으로 타입을 변환한다.</p>
<ul>
<li><p>문자열 타입으로 변환</p>
<ul>
<li>String 생성자 함수를 new 연산자 없이 호출하는 방법 ex) String(1); -&gt; “1”</li>
<li>Object.prototype.toString 메소드를 사용하는 방법 ex) (1).toString(); -&gt; “1”</li>
<li>문자열 연결 연산자를 이용하는 방법 1 + ‘’; -&gt; “1”</li>
</ul>
</li>
<li><p>숫자 타입으로 변환</p>
<ul>
<li>number 생성자 함수를 new 연산자 없이 호출하는 방법 ex) Number(‘0’) -&gt; 0</li>
<li>parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능) ex) parseInt(‘0’) -&gt; 0</li>
<li>단항 산술 연산자를 이용하는 방법 ex) +’0’; -&gt; 0</li>
<li>산술 연산자를 이용하는 방법 ex) ‘0’ * 1 -&gt; 0</li>
<li>빈 문자열(‘’), 빈 배열([]), null, false는 0으로 변환된다.</li>
<li>true는 1로 변환된다. ex) true * 1; -&gt; 1</li>
<li>객체와 빈 배열이 아닌 배열, undefined는 변환되지 않으므로 null이 된다.</li>
</ul>
</li>
<li><p>불리언 타입으로 변환: 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환.</p>
<ul>
<li>Boolean 생성자 함수를 new 연산자 없이 호출하는 방법 ex)Boolean(‘x’) -&gt; true</li>
<li>! 부정 논리 연산자를 두번 사용하는 방법 ex) !!’x’ -&gt; true</li>
<li><code>falsy값: false, undefined, null, 0, -0, NaN, 빈 문자열</code></li>
<li>truthy값: false 값을 제외한 모든 값</li>
</ul>
</li>
</ul>
<hr>
<h2 id="단축-평가"><a href="#단축-평가" class="headerlink" title="단축 평가"></a>단축 평가</h2><blockquote>
<p>논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. <em>논리합(||), 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.</em> 표현식을 평가하는 도중 결과가 확정되면 나머지 평가 과정을 중단하는 것이다. 이러한 성질을 이용하여 논리곱(&amp;&amp;)과 논리합(||)연산자는 if문을 대체할 수 있기도 하다.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> || anything	<span class="literal">true</span></span><br><span class="line"><span class="literal">false</span> || anything	anything</span><br><span class="line"><span class="literal">true</span> &amp;&amp; anything	anything</span><br><span class="line"><span class="literal">false</span> &amp;&amp; anything	<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 논리합(||) 연산자</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">true</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">false</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">true</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">false</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리곱(&amp;&amp;) 연산자</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>
<p><code>&#39;Cat&#39; &amp;&amp; &#39;Dog&#39; // &#39;Dog&#39;</code><br>논리곱(&amp;&amp;)연산자는 두 개의 피연산자 모두 true일 때 true를 반환한다. 첫 번째 피연산자 <code>Cat</code>을 평가했을 때 true로 평가되지만 두번째 피연산자까지 평가해보아야 완전한 평가가 이루어진다. 따라서 두번째 피연산자인 <code>Dog</code>까지 평가한 후 <code>Dog</code>를 반환한다.</p>
<p><code>&#39;Cat&#39; || &#39;Dog&#39; // &#39;Cat&#39;</code><br>논리합(||) 연산자는 두 개의 피연산자 중 하나만 true여도 true를 반환하기 때문에 첫 번째 피연산자 <code>Cat</code>이 true이므로 두번째 피연산자 <code>Dog</code>를 평가하지 않고 바로 <code>Cat</code>을 반환한다.</p>
<hr>
<p><em>References</em></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Glossary/Type_conversion" target="_blank" rel="noopener">MDN</a><br><a href="https://developer.mozilla.org/ko/docs/Glossary/Type_coercion" target="_blank" rel="noopener">MDN</a><br><a href="https://poiemaweb.com/fastcampus/type-casting" target="_blank" rel="noopener">poiemaweb</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/02/23/200224_object_literal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/23/200224_object_literal/" class="post-title-link" itemprop="url">객체 리터럴 / Object</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-24 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-24T00:00:00+09:00">2020-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-02 18:20:24" itemprop="dateModified" datetime="2022-03-02T18:20:24+09:00">2022-03-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="객체란"><a href="#객체란" class="headerlink" title="객체란?"></a>객체란?</h2><p>객체는 다양한 타입의 값(원시 값 또는 다른 객체)들을 하나의 단위로 구성한 복합적인 자료 구조이다. 0개 이상인 속성명(property)과 객체의 관련된 값이 중괄호({})로 묶여진다. 즉 <em>키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합</em>이라고 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">키워드 식별자 = &#123;</span><br><span class="line">  key(속성) : value(값)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  number : <span class="number">0</span>, <span class="comment">//프로퍼티</span></span><br><span class="line">  increase: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.num++; <span class="comment">//메소드</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>자바스크립트에 사용할 수 있는 모든 값이 프로퍼티 값이 될 수 있고, 함수도 사용할 수 있다. 이 경우 일반 함수와 구분하기 위해 메소드(Method)라 부른다.</p>
<p><code>프로퍼티와 메소드의 역할</code></p>
<ul>
<li>프로퍼티: key와 value를 통해 객체의 상태를 나타낸다.</li>
<li>메소드: 프로퍼티를 참조하고 조작할 수 있는 동작을 말한다.</li>
</ul>
<hr>
<h2 id="객체-리터럴에-의한-객체-생성"><a href="#객체-리터럴에-의한-객체-생성" class="headerlink" title="객체 리터럴에 의한 객체 생성"></a>객체 리터럴에 의한 객체 생성</h2><p>클래스 기반 객체지향 언어: 클래스 사전정의, 필요한 시점에 new연산자와 생성자를 호출하여 인스턴스를 생성하여 객체 생성 (C++, java 등)<br>프로토타입 기반 객체지향 언어: 자바스크립트. <code>객체 리터럴</code>, Object 생성자 함수, 생성자 함수, Object.create 메소드, 클래스 (ES6) 등의 방법으로 객체 생성</p>
<p><code>객체 리터럴</code><br>객체를 생성하는 표기법이며, 변수에 할당이 이루어지는 시점에 자바스크립트 엔진은 객체 리터럴을 해석하여 객체를 생성한다. <code>var empty = {};</code>와 같이 프로퍼티를 정의하지 않으면 빈 객체가 생성된다. 서버에게 주소를 넣어달라고 요청하는 것처럼 연속된 구조체나 연관된 데이터를 일정한 방법으로 변환하고자 할 때 많이 쓰인다.</p>
<blockquote>
<p>객체 리터럴의 중괄호({})는 코드블록이 아니다. 코드블록에는 중괄호 뒤이 세미콜론이 붙지 않지만, 객체 리터럴은 값으로 평가되는 표현식이므로 중괄호 뒤에 세미콜론을 붙인다.</p>
</blockquote>
<hr>
<h2 id="프로퍼티"><a href="#프로퍼티" class="headerlink" title="프로퍼티"></a>프로퍼티</h2><ul>
<li>프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값</li>
<li>프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값</li>
</ul>
<p>프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름이며, 식별자 역할을 하며 식별자 네이밍 규칙을 준수하는 것이 권장된다.</p>
<h2 id="프로퍼티-접근"><a href="#프로퍼티-접근" class="headerlink" title="프로퍼티 접근"></a>프로퍼티 접근</h2><p>마침표(.)를 사용하는 마침표 표기법(Dot notation) 또는 대괄호([…])를 사용하는 대괄호 표기법(Bracket notation)을 사용한다. 대괄호 표기법을 사용하는 경우, 대괄호 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. 자바스크립트에서 사용 가능한 유효한 이름이 아닐 때도 반드시 대괄호 표기법을 사용하며, 대괄호 내의 프로퍼티 키는 따옴표로 감싼 문자열이어야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Lee"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 마침표 표기법에 의한 프로퍼티 접근</span></span><br><span class="line"><span class="comment">// 객체이름.접근하고자 하는 항목</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Lee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 대괄호 표기법에 의한 프로퍼티 접근</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"name"</span>]); <span class="comment">// Lee</span></span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><code>존재하지 않는 프로퍼티에 접근</code>: undefined를 반환. <em>referenceError가 발생하지 않는다.</em></li>
<li><code>프로퍼티 값 갱신</code>: 이미 존재하는 프로퍼티에 값을 할당한다. <em>나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.</em></li>
<li><code>프로퍼티 동적 생성</code>: 존재하지 않는 프로퍼티에 값을 할당한다.</li>
<li><code>프로퍼티 삭제</code>: delete 연산자를 사용한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러없이 무시된다.</li>
<li><code>프로퍼티 키 생략</code>: ES6에서 프로퍼티 값으로 변수를 사용할 때 변수 이름과 프로퍼티 키가 동일한 이름이면 프로퍼티 키를 생략할 수 있다.</li>
</ul>
<hr>
<p><em>References</em></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Object_literals" target="_blank" rel="noopener">MDN</a><br><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Basics" target="_blank" rel="noopener">MDN</a><br><a href="https://poiemaweb.com/fastcampus/object-literal" target="_blank" rel="noopener">Poiemaweb</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/02/21/200223_operator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/21/200223_operator/" class="post-title-link" itemprop="url">연산자 / operator</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-22 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-22T00:00:00+09:00">2020-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-02 18:20:24" itemprop="dateModified" datetime="2022-03-02T18:20:24+09:00">2022-03-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h2><p>하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation) 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자(Operand)라 하고, 이는 값으로 평가될 수 있는 표현식이어야 한다.</p>
<ul>
<li>변수와 값을 어떻게 작동하게 할 것인지에 관한 것.</li>
<li>프로그래밍 언어에서 특정 연산을 하도록 하는 문자.</li>
<li>테스트 수행, 연산, 문자열 합치기 등등에 사용.</li>
<li><code>연산자의 부수 효과:</code>s 대부분의 연산자는 다른 코드에 영향을 주지 않는다. 하지만 일부 연산자는 부수 효과가 있다. 부수 효과가 있는 연산자는 할당(=) 연산자, 증가/감소(++/–) 연산자, delete 연산자이다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target variable = source value</span><br><span class="line">a = <span class="number">42</span> (<span class="number">42</span> 값을 a에 할당한다.)</span><br><span class="line">값 + 값 = 새로운 값</span><br></pre></td></tr></table></figure>
<p><code>피연산자, 피연산자 + 연산자의 조합으로 이루어진 연산자 표현식 모두 &#39;값&#39;으로 평가될 수 있어야 한다.</code></p>
<h2 id="산술-연산자-Arithmetic-Operator"><a href="#산술-연산자-Arithmetic-Operator" class="headerlink" title="산술 연산자 (Arithmetic Operator)"></a>산술 연산자 (Arithmetic Operator)</h2><p>피연산자를 대상으로 수학적 계산(사칙 연산)을 수행해 새로운 숫자 값을 만들며, 피연산자의 개수에 따라 이항 산술 연산자 or 단항 산술 연산자로 구분한다. <em>산술 연산이 불가능한 경우, NaN을 반환한다.</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">덧셈(+) : <span class="number">5</span> + <span class="number">2</span>; <span class="comment">// 7</span></span><br><span class="line">뺄셈(-) : <span class="number">5</span> - <span class="number">2</span>; <span class="comment">// 3</span></span><br><span class="line">곱셈(*) : <span class="number">5</span> * <span class="number">2</span>; <span class="comment">// 10</span></span><br><span class="line">나눗셈(<span class="regexp">/) : 5 /</span> <span class="number">2</span>; <span class="comment">// 2.5</span></span><br><span class="line">나머지(%) : <span class="number">5</span> % <span class="number">2</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="이항-산술-연산자-Binary-operators"><a href="#이항-산술-연산자-Binary-operators" class="headerlink" title="이항 산술 연산자 (Binary operators)"></a>이항 산술 연산자 (Binary operators)</h3><p>2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. <em>피연산자의 값을 변경하는 부수 효과는 없다. 언제나 새로운 값을 만들 뿐이다.</em></p>
<blockquote>
<p>operand1 operator operand2 ex) 3 + 4</p>
</blockquote>
<h3 id="단항-산술-연산자-Unary-operators"><a href="#단항-산술-연산자-Unary-operators" class="headerlink" title="단항 산술 연산자 (Unary operators)"></a>단항 산술 연산자 (Unary operators)</h3><p>1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 주로 반복문에서 많이 쓰인다.</p>
<blockquote>
<p>operator operand or operand operator ex) a++ or ++a</p>
</blockquote>
<p><code>주의: 이항 산술 연산자와 달리 증가/감소(++/–) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.</code></p>
<p><code>증가/감소(++/--) 연산자는 위치에 따른 의미</code><br>.전위 증가/감소 연산자: 피연산자의 앞에 위치하여 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.<br>.증가/감소(++/—) 연산자: 피연산자의 뒤에 위치하여 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">4</span>;</span><br><span class="line">++num1; <span class="comment">// -&gt; 5;</span></span><br><span class="line">num1; <span class="comment">// -&gt; 5;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ++num1는 num1의 값을 먼저 증가시킨 후 할당한다.</span></span><br><span class="line"><span class="comment">(선증가 후할당) */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">4</span>;</span><br><span class="line">num2++; <span class="comment">// -&gt; 4;</span></span><br><span class="line">num2; <span class="comment">//-&gt; 5;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* num2++은 num2의 값을 먼저 할당한 후 증가시킨다.</span></span><br><span class="line"><span class="comment">(선할당 후증가) */</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="문자열-연결-연산자-String-operators"><a href="#문자열-연결-연산자-String-operators" class="headerlink" title="문자열 연결 연산자 (String operators)"></a>문자열 연결 연산자 (String operators)</h2><p><code>+</code>연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 참고로 javascript에서 true는 1, false는 0과 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"my "</span> + <span class="string">"string"</span>); <span class="comment">// console logs the string "my string".</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 연결 연산자</span></span><br><span class="line"><span class="string">"1"</span> + <span class="number">2</span>; <span class="comment">// -&gt; '12'</span></span><br><span class="line"><span class="number">1</span> + <span class="string">"2"</span>; <span class="comment">// -&gt; '12'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true는 1로 타입 변환된다.</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">true</span>; <span class="comment">// -&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false는 0으로 타입 변환된다.</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">false</span>; <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>
<p><code>암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)</code><br>개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 위 예제에서 1 + true를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입의 값인 true를 숫자 타입인 1로 타입을 강제 변환한 후 연산을 수행한다.</p>
<hr>
<h2 id="할당-연산자-Assignment-Operator"><a href="#할당-연산자-Assignment-Operator" class="headerlink" title="할당 연산자 (Assignment Operator)"></a>할당 연산자 (Assignment Operator)</h2><ul>
<li>우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.</li>
<li>좌항의 피연산자는 우항의 피연산자의 값에 기초한다.</li>
<li>x = y는 y의 값을 x에 할당하겠다는 뜻이다.</li>
</ul>
<p><code>할당 연산자는 좌항의 변수에 값을 할당하므로 변수의 값이 변하는 부수 효과가 있다.</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">=	: x = <span class="number">5</span>	    = x = <span class="number">5</span></span><br><span class="line">+=	: x += <span class="number">5</span>	= x = x + <span class="number">5</span></span><br><span class="line">-=	: x -= <span class="number">5</span>	= x = x - <span class="number">5</span></span><br><span class="line">*=	: x *= <span class="number">5</span>	= x = x * <span class="number">5</span></span><br><span class="line">/=	: x /= <span class="number">5</span>	= x = x / <span class="number">5</span></span><br><span class="line">%=	: x %= <span class="number">5</span>	= x = x % <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//우항의 값을 좌항의 변수값에 할당한 후, 새로운 변수 값을 반환한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>; <span class="comment">//x는 3이라는 값을 담고 있다.</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">4</span>; <span class="comment">//y는 4라는 값을 담고 있다.</span></span><br><span class="line"></span><br><span class="line">x *= y; <span class="comment">//x는  12라는 값을 담고 있다.</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="비교-연산자-Comparison-operators"><a href="#비교-연산자-Comparison-operators" class="headerlink" title="비교 연산자 (Comparison operators)"></a>비교 연산자 (Comparison operators)</h2><p>두 값(좌항과 우항)의 피연산자를 비교한 다음 그 결과로 <code>불리언 값을 반환</code>한다. 비교 연산자는 <em>if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다.</em></p>
<h3 id="동등-일치-비교-연산자"><a href="#동등-일치-비교-연산자" class="headerlink" title="동등/일치 비교 연산자"></a>동등/일치 비교 연산자</h3><p>좌항과 우항의 피연산자가 같은 값을 갖는지 비교하여 <code>불리언 값을 반환</code>한다. 동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다.</p>
<ul>
<li>== 동등 비교: x == y x와 y의 값이 같음</li>
<li>=== 일치 비교: x === y x와 y의 값과 타입이 같음</li>
<li>!= 부동등 비교: x != y //x와 y의 값이 다름</li>
<li>!== 불일치 비교: x !== y //x와 y의 값과 타입이 다름</li>
</ul>
<blockquote>
<p>동등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후, 같은 값인지 비교한다.<br>타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.<br>5 == ‘5’; // -&gt; true</p>
</blockquote>
<p>다음을 주의하여야 한다.</p>
<ul>
<li>NaN === NaN; : false;</li>
<li>0 === -0; : true;</li>
<li>0 == -0 : true;</li>
</ul>
<h3 id="대소-관계-비교-연산자"><a href="#대소-관계-비교-연산자" class="headerlink" title="대소 관계 비교 연산자"></a>대소 관계 비교 연산자</h3><p>피연산자의 크기를 비교하여 불리언 값을 반환한다.</p>
<ul>
<li><code>&gt;</code>: x &gt; y : x가 y보다 크다</li>
<li><code>&lt;</code>: x &lt; y : x가 y보다 작다</li>
<li><code>&gt;=</code>: x &gt;= y : x가 y보다 같거나 크다</li>
<li><code>&lt;=</code>: x &lt;= y : x가 y보다 같거나 크다</li>
</ul>
<hr>
<h2 id="삼항-조건-연산자-ternary-operator"><a href="#삼항-조건-연산자-ternary-operator" class="headerlink" title="삼항 조건 연산자 (ternary operator)"></a>삼항 조건 연산자 (ternary operator)</h2><blockquote>
<p>조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값</p>
</blockquote>
<p>조건식의 평가 결과에 따라 반환할 값을 결정한다. 조건식이 참이면 콜론(:) 앞의 두번째 피연산자가 평가되어 반환되고, 거짓이면 콜론(:) 뒤의 세번째 피연산자가 평가되어 반환된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.</span></span><br><span class="line"><span class="keyword">var</span> result = x % <span class="number">2</span> ? <span class="string">"홀수"</span> : <span class="string">"짝수"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 짝수</span></span><br></pre></td></tr></table></figure>
<h2 id="논리-연산자-Logical-Operator"><a href="#논리-연산자-Logical-Operator" class="headerlink" title="논리 연산자 (Logical Operator)"></a>논리 연산자 (Logical Operator)</h2><p>우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">||	논리합(OR)	✕</span><br><span class="line">&amp;&amp;	논리곱(AND)	✕</span><br><span class="line">!	  부정(NOT)  ✕</span><br></pre></td></tr></table></figure>
<p>논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단, 피연산자가 반드시 불리언 값일 필요는 없다. 논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.</p>
<h2 id="쉼표-연산자"><a href="#쉼표-연산자" class="headerlink" title="쉼표 연산자"></a>쉼표 연산자</h2><p>왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y, z;</span><br><span class="line"></span><br><span class="line">(x = <span class="number">1</span>), (y = <span class="number">2</span>), (z = <span class="number">3</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="그룹-연산자"><a href="#그룹-연산자" class="headerlink" title="그룹 연산자"></a>그룹 연산자</h2><p>연산자 우선순위(Operator precedence)와 관련있다. 일부 연산자는 합계 (프로그래밍에서 표현식이라고 함)의 결과를 계산할 때 다른 연산자보다 먼저 적용된다. JavaScript의 연산자 우선 순위는 수학 시간에 배운 것처럼 곱하기와 나누기는 항상 먼저 수행 한 다음 더하기와 빼기 (합은 항상 왼쪽에서 오른쪽으로 평가됨) 따라서 먼저 연산하고 싶은 부분을 그룹 연산자<code>()</code>로 묶어서 우선 순위를 조절할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> * <span class="number">2</span> + <span class="number">3</span>; <span class="comment">// -&gt; 23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 그룹 연산자를 사용하여 우선 순위 조절</span></span><br><span class="line"><span class="number">10</span> * (<span class="number">2</span> + <span class="number">3</span>); <span class="comment">// -&gt; 50</span></span><br></pre></td></tr></table></figure>
<h2 id="typeof-연산자"><a href="#typeof-연산자" class="headerlink" title="typeof 연산자"></a>typeof 연산자</h2><p>피연산자의 데이터 타입을 문자열로 반환한다. typeof 연산자는 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환한다. “null”을 반환하는 경우는 없으며 함수의 경우 “function”을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> foo === <span class="literal">null</span>; <span class="comment">// -&gt; false</span></span><br><span class="line">foo === <span class="literal">null</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>
<p>typeof 연산자로 null 값을 연산해 보면 “null”이 아닌 “object”를 반환하는데 이는 자바스크립트의 첫 번째 버전의 버그이다. 따라서 null 타입을 확인할 때는 typeof 연산자 보다는 연산자(===)을 사용하는 것이 좋다. 또한 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 “undefined”를 반환한다.</p>
<h2 id="지수-연산자"><a href="#지수-연산자" class="headerlink" title="지수 연산자"></a>지수 연산자</h2><p>ES7에서 새롭게 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환한다. 이항 연산자 중 우선순위가 가장 높다. 참고로 지수 연산자 이전에는 Math.pow(2,2)와 같이 사용하였다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span>; <span class="comment">// -&gt; 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">2.5</span>; <span class="comment">// -&gt; 5.65685424949238</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">0</span>; <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">-2</span>; <span class="comment">// -&gt; 0.25</span></span><br><span class="line">(<span class="number">-5</span>) ** <span class="number">2</span>; <span class="comment">// -&gt; 25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">5</span>;</span><br><span class="line">num **= <span class="number">2</span>; <span class="comment">// -&gt;25</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="옵셔널-체이닝-optional-chaining"><a href="#옵셔널-체이닝-optional-chaining" class="headerlink" title="옵셔널 체이닝(optional chaining)"></a>옵셔널 체이닝(optional chaining)</h2><blockquote>
<p>obj?.prop<br>obj?.[expr]<br>arr?.[index]<br>func?.(args)</p>
</blockquote>
<p>좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다. <em>논리 연산자 &amp;&amp;와 같은 기능이다.</em></p>
<ol>
<li><p>&amp;&amp;를 사용할 때: 중첩된 구조의 객체 obj에서 하위 중첩된 하위 속성을 찾을 때 다음과 같이 사용한다. obj.first는 태스트 없이 obj.first.second에 직접 접근할 때 생기는 에러를 방지하기 위해서 값에 접근하기 전에 null 또는 undefined가 아니라는 점을 검증하는 것이다.</p>
<blockquote>
<p>let nestedProp = obj.first &amp;&amp; obj.first.second;</p>
</blockquote>
</li>
<li><p>옵셔널 체이닝을 사용: &amp;&amp;를 사용할 때 처럼 명시적인 테스트가 필요없다.<br><code>?.</code>의 옵셔널 체이닝을 사용함으로써 obj.first.second에 접근하기 전에 obj.first가 null 또는 undefined가 아니라는 것을 암묵적으로 확인한다.</p>
<blockquote>
<p>let nestedProp = obj.first?.second;</p>
</blockquote>
</li>
<li><p>obj.first가 null or undefined라면 undefined가 반환된다. 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.</p>
<blockquote>
<p>let nestedProp =<br>obj.first === null || obj.first === undefined ? undefined : obj.first.second;</p>
</blockquote>
</li>
</ol>
<p>다음과 같이 이벤트 핸들러를 다룰 때 유용하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Written as of ES2019</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">onContent, onError</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... do something with the data</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (onError) &#123;</span><br><span class="line">      <span class="comment">// Testing if onError really exists</span></span><br><span class="line">      onError(err.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using optional chaining with function calls</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">onContent, onError</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... do something with the data</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    onError?.(err.message); <span class="comment">// no exception if onError is undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><em>References</em></p>
<p><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/First_steps/Math" target="_blank" rel="noopener">MDN</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Operator_precedence" target="_blank" rel="noopener">MDN</a><br><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/A_first_splash" target="_blank" rel="noopener">MDN</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Optional_chaining" target="_blank" rel="noopener">MDN</a><br><a href="https://poiemaweb.com/fastcampus/operator" target="_blank" rel="noopener">Poiemaweb</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/02/21/200222_datatype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/21/200222_datatype/" class="post-title-link" itemprop="url">데이터 타입/ Data type</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-22 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-22T00:00:00+09:00">2020-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-02 18:20:24" itemprop="dateModified" datetime="2022-03-02T18:20:24+09:00">2022-03-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="데이터-타입"><a href="#데이터-타입" class="headerlink" title="데이터 타입"></a>데이터 타입</h2><p>자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트(ES6)는 7개의 데이터 타입을 제공한다. 7개의 데이터 타입은 원시 타입(primitive type)과 객체 타입(object/reference type)으로 분류할 수 있다.</p>
<ul>
<li><p><code>원시 타입(primitive type)</code>: 숫자, 문자열, 불리언, undefined, null, symbol</p>
</li>
<li><p><code>객체 타입(object/reference type)</code>: 객체, 함수, 배열 등</p>
</li>
</ul>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof를 사용하면 자료형이 무엇인지 확인할 수 있다. 아래와 같이 <code>typeof 피연산자</code>의 형태로 사용한다.</p>
<blockquote>
<p>typeof operand<br>typeof(operand)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">42</span>);</span><br><span class="line"><span class="comment">// expected output: "number"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"blubber"</span>);</span><br><span class="line"><span class="comment">// expected output: "string"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// expected output: "boolean"</span></span><br></pre></td></tr></table></figure>
<h3 id="typeof-null-‘object’-인-이유는"><a href="#typeof-null-‘object’-인-이유는" class="headerlink" title="typeof null === ‘object’ 인 이유는?"></a>typeof null === ‘object’ 인 이유는?</h3><p>typeof null은 ‘null’을 반환하지 않는다. <em>null의 타입은 원시타입인데, <code>object</code>를 반환한다.</em> 이는 첫 번째 자바스크립트 버전의 고칠 수 없는 버그이다. 만약 고치게 될 경우 기존 코드에 영향을 미칠 수 있기 때문이다.</p>
<hr>
<h2 id="숫자-타입"><a href="#숫자-타입" class="headerlink" title="숫자 타입"></a>숫자 타입</h2><p>자바스크립트의 숫자는 <code>실수 타입</code> 하나만 존재한다. (C, Java와 같은 언어는 정수와 실수 등으로 숫자를 구분함.) 정수나 음의 정수 등도 모두 실수로 처리한다.</p>
<ul>
<li>정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장</li>
<li>자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> binary = <span class="number">0b01000001</span>; <span class="comment">// 2진수</span></span><br><span class="line"><span class="keyword">var</span> octal = <span class="number">0o101</span>; <span class="comment">// 8진수</span></span><br><span class="line"><span class="keyword">var</span> hex = <span class="number">0x41</span>; <span class="comment">// 16진수</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 표기법만 다를 뿐 모두 같은 값이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(binary); <span class="comment">// 65</span></span><br><span class="line"><span class="built_in">console</span>.log(octal); <span class="comment">// 65</span></span><br><span class="line"><span class="built_in">console</span>.log(hex); <span class="comment">// 65</span></span><br><span class="line"><span class="built_in">console</span>.log(binary === octal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(octal === hex); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>javascript는 모든 수를 실수로 처리하기 때문에 정수와 정수를 나눴을 때 실수가 나올 수도 있다. (<code>ex. console.log(3/2) //1.5</code>)</p>
<ul>
<li>다음과 같은 3가지 특별한 값을 표현할 수도 있다. NaN의 경우 반드시 대소문자를 구별해야 한다.<ul>
<li>Infinity : 양의 무한대</li>
<li>Infinity : 음의 무한대</li>
<li>NaN : 산술 연산 불가(not-a-number)</li>
</ul>
</li>
</ul>
<h2 id="문자열-타입"><a href="#문자열-타입" class="headerlink" title="문자열 타입"></a>문자열 타입</h2><p>텍스트 데이터를 나타내는 데 사용하며, 0개 이상의 16bit 유니코드 문자(UTF-16) 들의 집합이다. 작은 따옴표(‘’), 큰 따옴표(“”) 또는 백틱(``)으로 텍스트를 감싸서 사용한다.</p>
<blockquote>
<p>‘abc’, ‘’, “”, `a` 모두 문자열이다.</p>
</blockquote>
<p><em>만약 문자열을 따옴표(‘’)로 감싸지 않는다면?</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">typeof</span> string; <span class="comment">// "string"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = hello;</span><br><span class="line"><span class="comment">//ReferenceError: hello is not defined</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 문자열을 따옴표(‘’)로 감싸지 않으면 자바스크립트 엔진은 문자열을 키워드나 식별자와 같은 토큰으로 인식하므로 에러가 발생한다. <em>문자열을 따옴표로 감싸는 이유는 키워드, 식별자 같은 토큰과 구분하기 위해서이기 때문이다.</em> 또한 스페이스와 같은 공백 문자도 따옴표 없이는 사용할 수 없다.</p>
<h2 id="템플럿-리터럴"><a href="#템플럿-리터럴" class="headerlink" title="템플럿 리터럴"></a>템플럿 리터럴</h2><p>ES6부터 도입되었으며, 작은 따옴표(‘’) 또는 큰 따옴표(“”) 같은 일반적인 따옴표 대신 백틱(backtick) (``)을 사용한다.</p>
<h3 id="멀티라인-문자열"><a href="#멀티라인-문자열" class="headerlink" title="멀티라인 문자열"></a>멀티라인 문자열</h3><p>일반문자열에서는 개행이 허용되지 않으므로 백슬래시(\)로 시작하는 이스케이프 시퀀스를 사용해야 하지만, 백틱(``)을 사용하면 개행하지 않아도 되고, 공백도 있는 그대로 적용된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//일반문자열은 이스케이프 시퀀스를 사용하여 줄바꿈한다. (줄바꿈 /n)</span></span><br><span class="line"><span class="keyword">var</span> template = <span class="string">'&lt;ul&gt;\n\t&lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(template);</span><br><span class="line"></span><br><span class="line"><span class="comment">//템플릿 문자열은 이스케이프 시퀀스가 없어도 줄바꿈 가능 (백틱사용)</span></span><br><span class="line"><span class="keyword">var</span> template = <span class="string">`&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(template);</span><br></pre></td></tr></table></figure>
<h3 id="표현식-삽입"><a href="#표현식-삽입" class="headerlink" title="표현식 삽입"></a>표현식 삽입</h3><p><code>${ }</code>으로 표현식을 감싸서 사용한다. 이때 표현식의 평가 결과가 문자열이 아니더라도 문자열로 강제 타입 변환되어 삽입된다. 단, 템플릿 리터럴을 일반 문자열에서 삽입하면 문자열로 취급된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//일반 문자열은 '+'연산자로 문자열을 연결한다.</span></span><br><span class="line"><span class="keyword">var</span> first = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> second = <span class="string">"world"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(first + <span class="string">" "</span> + second); <span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//템플릿 리터럴</span></span><br><span class="line"><span class="keyword">var</span> first = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> second = <span class="string">"world"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;second&#125;</span>`</span>); <span class="comment">//hello world</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="불리언-타입"><a href="#불리언-타입" class="headerlink" title="불리언 타입"></a>불리언 타입</h2><p>논리적 참, 거짓을 나타내는 <code>true</code>와 <code>false</code>를 말한다. 제어문에서 주로 사용한다.</p>
<h2 id="undefined-타입"><a href="#undefined-타입" class="headerlink" title="undefined 타입"></a>undefined 타입</h2><p>개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값. 변수 선언이 되면 자바스크립트 엔진은 <code>undefined</code>를 암묵적으로 할당한다. <em>변수 참조 시 <code>undefined</code>가 반환된다면 변수 선언 후 아직 할당이 이루어지지 않았음을 알 수 있다.</em></p>
<h2 id="null-타입"><a href="#null-타입" class="headerlink" title="null 타입"></a>null 타입</h2><p>변수에 값이 없다는 것을 의도적으로 명시(의도적 부재 Intentional absence)하고 싶다면 <code>undefined</code>가 아니라 <code>null</code>을 할당한다. <em><code>null</code>을 할당하는 것은 변수가 이전에 참조하던 값을 더이상 참조하지 않겠다는 의미이며, 가비지 컬렉팅이 이루어질 것이다.</em></p>
<h2 id="symbole-타입"><a href="#symbole-타입" class="headerlink" title="symbole 타입"></a>symbole 타입</h2><p>ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입이며, 다른 값과 중복되지 않는다. 심볼은 주로 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키(property key)를 만들기 위해 사용한다. 함수를 호출해 생성하지만 참조할 수는 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 심볼 값 생성</span></span><br><span class="line"><span class="keyword">var</span> key = <span class="built_in">Symbol</span>(<span class="string">"key"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> key); <span class="comment">// symbol</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 생성</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 심볼 key를 이름의 충돌 위험이 없는 유일한 프로퍼티 키로 사용한다.</span></span><br><span class="line">obj[key] = <span class="string">"value"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj[key]); <span class="comment">// value</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="데이터-타입의-필요성"><a href="#데이터-타입의-필요성" class="headerlink" title="데이터 타입의 필요성"></a>데이터 타입의 필요성</h2><ul>
<li><p>데이터 타입에 의한 메모리 공간의 확보와 참조<br>자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다. 즉, 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.</p>
</li>
<li><p>데이터 타입에 의한 값의 해석</p>
<ul>
<li>값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해</li>
<li>값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해</li>
<li>메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해</li>
</ul>
</li>
</ul>
<h2 id="정적-타입-static-strong-type"><a href="#정적-타입-static-strong-type" class="headerlink" title="정적 타입(static/strong type)"></a>정적 타입(static/strong type)</h2><p>C나 Java와 같은 정적 타입(Static/Strong type) 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야 한다. 이를 명시적 타입 선언(explicit type declaration)이라 한다.</p>
<h2 id="동적-타입-Dynamic-Weak-type"><a href="#동적-타입-Dynamic-Weak-type" class="headerlink" title="동적 타입(Dynamic/Weak type)"></a>동적 타입(Dynamic/Weak type)</h2><p>자바스크립트는 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고 변수의 타입을 언제든지 자유롭게 변경할 수 있다. <em>다시 말해 자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정된다.</em> 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.</p>
<ul>
<li>변수는 꼭 필요한 경우에만 사용, 변수보다는 상수를 사용하여 값의 변경을 억제한다.</li>
<li>식별자 네이밍 규칙에 따라 변수 이름은 의미를 파악하기 쉽게 네이밍한다.</li>
<li>변수의 유효 범위(스코프)는 최대한 좁게 만들며, 전역 변수는 최대한 사용하지 않는다.</li>
</ul>
<hr>
<p><em>References</em><br><a href="https://poiemaweb.com/fastcampus/type" target="_blank" rel="noopener">Poiemaweb</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">MDN</a><br><a href="https://2ality.com/2013/10/typeof-null.html" target="_blank" rel="noopener">2ality</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://heejinlee07.github.io/2020/02/21/200222_expression_statement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Heejin Lee">
      <meta itemprop="description" content="Today I Learned">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Heejin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/21/200222_expression_statement/" class="post-title-link" itemprop="url">표현식과 문 / expression & statement</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-22 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-22T00:00:00+09:00">2020-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-02 18:20:24" itemprop="dateModified" datetime="2022-03-02T18:20:24+09:00">2022-03-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="값-value"><a href="#값-value" class="headerlink" title="값(value)"></a>값(value)</h2><p>식(표현식, expression)이 평가(evaluate)되어 생성된 결과 <code>var result = 10 + 20;</code>에서 10과 20이라는 숫자는 런타임(할당 이전)에 평가되어 값을 생성하고, 런타임 때 10 + 20을 평가하여 30이라는 값을 <code>result</code>에 할당한다. 즉, 변수 result가 기억하는 메모리 공간의 값은 <code>10 + 20이 아닌 값 30</code>이다.</p>
<h2 id="리터럴-literal"><a href="#리터럴-literal" class="headerlink" title="리터럴(literal)"></a>리터럴(literal)</h2><blockquote>
<p>사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기 방식</p>
<p>자바스크립트 엔진은 코드가 실행되는 시점(런타임, runtime)에 리터럴을 평가하여 값을 생성한다. 즉, 리터럴은 값을 생성하기 위해 미리 약속한 표기법(notation)이라고 할 수 있다.</p>
</blockquote>
<ol>
<li>10, 20은 사람들 사이에서 숫자리는 기호로 약속되어 있는데, 이를 숫자 리터럴이라고 한다.</li>
<li>숫자 리터럴 10과 20을 코드 내에 <code>var result = 10 + 20;</code>이라고 작성하면 자바스크립트는 이를 평가하여 런타임 이전에 숫자 값 10과 20을 생성한다.</li>
<li>런타임 때 코드가 실행되는데 이때 리터럴은 평가되어 값을 생성한다. 즉 <code>10 + 20</code>의 값을 평가한 결과 <code>30</code>을 result라는 변수의 값이 생성된다.</li>
</ol>
<hr>
<h2 id="표현식-expression"><a href="#표현식-expression" class="headerlink" title="표현식 (expression)"></a>표현식 (expression)</h2><p><em>값으로 평가(evaluation)될 수 있는 문(statement)이다.</em> 즉, 표현식이 평가되면 값을 생성하거나 값을 참조한다. 따라서 값으로 평가되는 문은 모두 표현식이다. 이때 표현식과 표현식이 평가된 값은 동등한 관계, 즉 동치(equivalent)이다.</p>
<ul>
<li>변수에 값을 할당<br><code>x = 7</code>은 x에 7을 할당시키기 위해 연산자(=)를 사용한 것으로, 7로 계산된다.</li>
<li>단순히 값을 가짐.<br><code>3 + 4</code>는 위 예시처럼 변수에 7을 할당하는 것이 아니라 그 자체로 3과 4를 더한 값을 갖는다.</li>
<li>표현범주: 산수(산술 연산자), 문자열, 논리(참, 거짓), 일차식, 좌변식</li>
</ul>
<h2 id="문-statement"><a href="#문-statement" class="headerlink" title="문(statement)"></a>문(statement)</h2><p><em>프로그램을 구성하는 기본 단위이자 최소 실행 단위.</em> 문의 집합으로 이루어진 것이 프로그램이며 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다. 문은 여러 토큰들로 구성된다. 토큰(token)이란 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미한다. 선언문, 할당문, 조건문, 반복문 등이 있다.</p>
<p><em>문은 반복문이나 if문처럼 action을 수행하게 하기 때문에 명령문이라고도 한다.</em> 자바스크립트 엔진이 문이 있기를 기대하는 곳에 표현식을 쓸 수 있는데, 이를 표현식인 문이라고 한다. 그러나 그 반대는 불가하다. 즉 표현식이 있기를 기대하는 곳에 문을 쓸 수는 없다. 예를들어 if문은 함수의 인수가 될 수 없다.</p>
<h3 id="세미콜론과-세미콜론-자동-삽입-기능"><a href="#세미콜론과-세미콜론-자동-삽입-기능" class="headerlink" title="세미콜론과 세미콜론 자동 삽입 기능"></a>세미콜론과 세미콜론 자동 삽입 기능</h3><p>세미콜론( ; )은 문의 종료를 나타내며, <em>문은 반드시 세미콜론으로 끝나야 한다.</em> 단, 0개 이상의 문을 중괄호로 묶은 코드 블록 { … } 뒤에는 세미콜론을 붙이지 않는다. 예를 들어 if 문, for 문, 함수 등의 코드 블록 뒤에는 세미콜론을 붙이지 않는다. 이들 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성(self closing)을 갖기 때문이다.</p>
<hr>
<h2 id="표현식과-문"><a href="#표현식과-문" class="headerlink" title="표현식과 문"></a>표현식과 문</h2><p>표현식: <code>become a value</code>. 값이 생성되거나 문의 일부가 될 수 있다.<br>문: <code>perform action</code>. 값이 생성되지 않고, 실행문이나 코드블록의 action을 컨트롤할 뿐이다.</p>
<p><code>const x = 5;</code>는 숫자 리터럴 5를 해석하여 값 5를 생성하는 것이다.<br><code>const y = getAnswer();</code>는 어떤 값을 반환하도록 호출하는 것이므로 역시 표현식이다.</p>
<h2 id="표현식인-문과-표현식이-아닌-문"><a href="#표현식인-문과-표현식이-아닌-문" class="headerlink" title="표현식인 문과 표현식이 아닌 문"></a>표현식인 문과 표현식이 아닌 문</h2><blockquote>
<p>표현식인 문과 표현식이 아닌 문을 구별하는 방법은 변수에 할당하는 것이다. 변수에 할당이 가능하면 표현식인 문, 그렇지 않으면 표현식이 아닌 문이다.</p>
</blockquote>
<p><code>문:</code> 실행되거나 특정한 action을 수행할 수 있는 코드의 조각을 말한다.<br><code>표현식:</code> 평가되어 값을 생성할 수 있는 코드의 조각을 말한다.<br><code>표현식인 문:</code> 값으로 평가될 수 있는 문. ex.변수 할당문<br><code>표현식이 아닌 문:</code> 값으로 평가될 수 없는 문 ex.변수 선언문</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x; <span class="comment">//변수 선언문</span></span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>; <span class="comment">//변수 할당문</span></span><br><span class="line"><span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>구글 개발자 도구에서 위의 <code>var x;</code>와 같이 변수 선언문을 실행하면 <code>undefined</code>가 반환된다. <em>변수 선언문은 표현식이 아닌 문이므로</em> 값을 반환해야할 자리에 평가된 값이 아닌 <code>undefined</code>가 출력되는 것이고, 이를 <code>완료값</code>이라고 한다. 이는 자바스크립트 엔진이 암묵적으로 할당해주는 것이며, 변수에 담을 수 없고, 참조할 수 없는 값이다. 반면 변수에 할당을 하면 할당된 값이 출력되므로 <em>할당문은 표현식인 문</em>이라고 할 수 있다.</p>
<hr>
<p><em>References</em></p>
<p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Expressions_and_Operators" target="_blank" rel="noopener">MDN</a><br><a href="https://2ality.com/2012/09/expressions-vs-statements.html" target="_blank" rel="noopener">2ality</a><br><a href="https://poiemaweb.com/fastcampus/expression" target="_blank" rel="noopener">Poiemaweb</a><br><a href="https://www.youtube.com/watch?v=WVyCrI1cHi8" target="_blank" rel="noopener">Codexpanse</a><br><a href="https://exploringjs.com/impatient-js/ch_syntax.html#statement-vs-expression" target="_blank" rel="noopener">JavaScript for impatient programmers</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Heejin Lee</p>
  <div class="site-description" itemprop="description">Today I Learned</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heejin Lee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
